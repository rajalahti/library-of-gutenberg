<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A digital library filled with real books from Project Gutenberg. Walk through hexagonal rooms and read classic literature.">
    <title>The Library of Gutenberg</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ“š</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=IBM+Plex+Mono:wght@400;500&family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --deco-bg: rgba(15, 11, 8, 0.92);
            --deco-bg-soft: rgba(25, 18, 12, 0.82);
            --deco-brass: #c6a15a;
            --deco-brass-dim: #8d7141;
            --deco-ivory: #e6d8b8;
            --deco-line: rgba(198, 161, 90, 0.35);
            --deco-shadow: rgba(0, 0, 0, 0.55);
        }

        body {
            font-family: 'Cormorant Garamond', serif;
            background: #0a0806;
            color: #d4c5a0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #scene {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.7) 100%);
            pointer-events: none;
            z-index: 2;
        }

        #deco-frame {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 2;
            opacity: 0.72;
        }

        #deco-frame::before,
        #deco-frame::after {
            content: '';
            position: absolute;
            inset: 16px;
            border: 1px solid rgba(198, 161, 90, 0.22);
            box-shadow: inset 0 0 0 1px rgba(198, 161, 90, 0.08);
        }

        #deco-frame::after {
            inset: 28px;
            border: none;
            background:
                linear-gradient(90deg, rgba(198, 161, 90, 0.55), transparent 52%) top left / 180px 2px no-repeat,
                linear-gradient(0deg, rgba(198, 161, 90, 0.55), transparent 52%) top left / 2px 180px no-repeat,
                linear-gradient(270deg, rgba(198, 161, 90, 0.55), transparent 52%) top right / 180px 2px no-repeat,
                linear-gradient(180deg, rgba(198, 161, 90, 0.55), transparent 52%) top right / 2px 180px no-repeat,
                linear-gradient(90deg, rgba(198, 161, 90, 0.55), transparent 52%) bottom left / 180px 2px no-repeat,
                linear-gradient(0deg, rgba(198, 161, 90, 0.55), transparent 52%) bottom left / 2px 180px no-repeat,
                linear-gradient(270deg, rgba(198, 161, 90, 0.55), transparent 52%) bottom right / 180px 2px no-repeat,
                linear-gradient(180deg, rgba(198, 161, 90, 0.55), transparent 52%) bottom right / 2px 180px no-repeat;
            filter: drop-shadow(0 0 12px rgba(198, 161, 90, 0.14));
        }

        #film-grain {
            position: fixed;
            inset: -120px;
            pointer-events: none;
            z-index: 2;
            opacity: 0.12;
            mix-blend-mode: soft-light;
            background-image:
                radial-gradient(circle at 20% 30%, rgba(255, 255, 255, 0.11) 0 1px, transparent 2px),
                radial-gradient(circle at 70% 60%, rgba(255, 255, 255, 0.08) 0 1px, transparent 2px),
                radial-gradient(circle at 45% 80%, rgba(255, 255, 255, 0.09) 0 1px, transparent 2px);
            background-size: 180px 180px, 220px 220px, 200px 200px;
            animation: grainShift 9s steps(8) infinite;
        }

        @keyframes grainShift {
            0% { transform: translate3d(0, 0, 0); }
            25% { transform: translate3d(-24px, 18px, 0); }
            50% { transform: translate3d(16px, -22px, 0); }
            75% { transform: translate3d(-10px, -12px, 0); }
            100% { transform: translate3d(0, 0, 0); }
        }

        #transition-fade {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0806;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        #transition-fade.active {
            opacity: 1;
        }

        #title-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 11px 22px;
            font-size: 13px;
            letter-spacing: 4px;
            color: rgba(198, 161, 90, 0.74);
            z-index: 3;
            background:
                linear-gradient(to bottom, rgba(7, 5, 3, 0.94) 0%, rgba(7, 5, 3, 0.45) 65%, transparent 100%),
                repeating-linear-gradient(
                    90deg,
                    rgba(198, 161, 90, 0.06) 0px,
                    rgba(198, 161, 90, 0.06) 2px,
                    transparent 2px,
                    transparent 10px
                );
            border-bottom: 1px solid rgba(198, 161, 90, 0.24);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #title-bar > * {
            pointer-events: auto;
        }

        .title-bar-controls {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        #brightness-slider, #volume-slider {
            width: 60px;
            height: 3px;
            -webkit-appearance: none;
            appearance: none;
            background: #4a3520;
            outline: none;
            opacity: 0.7;
            vertical-align: middle;
            cursor: pointer;
            border-radius: 2px;
        }

        #brightness-slider:hover, #volume-slider:hover {
            opacity: 1;
        }

        #brightness-slider::-webkit-slider-thumb, #volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #c4943a;
            cursor: pointer;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: #5a4a32;
        }

        .control-icon {
            font-size: 14px;
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .control-icon:hover {
            opacity: 1;
        }

        .control-icon.active {
            opacity: 1;
            color: #c4943a;
        }

        #intro {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000 url('images/hero.png') center center / cover no-repeat;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 1;
            transition: opacity 1.5s ease-out;
            cursor: pointer;
        }

        #intro::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.55);
        }

        #intro.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #intro-text {
            max-width: 700px;
            padding: 40px;
            text-align: center;
            position: relative;
            z-index: 1;
        }

        .intro-quote {
            font-size: 26px;
            font-style: italic;
            line-height: 1.8;
            color: #d4c5a0;
            opacity: 0;
            animation: fadeInText 2.5s ease-in forwards;
            letter-spacing: 0.3px;
        }

        .intro-attribution {
            margin-top: 24px;
            font-size: 16px;
            color: #8b7355;
            opacity: 0;
            animation: fadeInText 1.5s ease-in 1.5s forwards;
        }

        .intro-prompt {
            margin-top: 48px;
            font-size: 14px;
            color: #5a4a32;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0;
            animation: fadeInText 1s ease-in 3s forwards, pulse 2s ease-in-out 4s infinite;
        }

        @keyframes fadeInText {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            z-index: 10;
            display: none;
            pointer-events: none;
            transform: translate(-50%, -50%) rotate(45deg);
            border: 1px solid rgba(212, 197, 160, 0.5);
            transition: border-color 0.15s ease;
        }

        #crosshair.visible {
            display: block;
        }

        #instructions {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(180deg, rgba(20, 14, 10, 0.92), rgba(12, 9, 6, 0.88));
            padding: 10px 22px;
            border-radius: 10px;
            border: 1px solid var(--deco-line);
            color: var(--deco-ivory);
            font-size: 14px;
            letter-spacing: 0.5px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(198, 161, 90, 0.22);
            z-index: 5;
            transition: opacity 0.3s;
        }

        #instructions.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #book-tooltip {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 18, 8, 0.95);
            padding: 10px 20px;
            border-radius: 4px;
            border: 1px solid #4a3520;
            color: #c4943a;
            font-size: 14px;
            z-index: 5;
            display: none;
            max-width: 400px;
            text-align: center;
            transition: opacity 0.2s ease;
        }

        #book-tooltip.visible {
            display: block;
            animation: tooltipFadeIn 0.2s ease;
        }

        @keyframes tooltipFadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(4px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        #book-tooltip .title {
            color: #c4943a;
            font-weight: 600;
        }

        #book-tooltip .author {
            color: #8b7355;
            font-size: 12px;
            margin-top: 4px;
        }

        #book-tooltip .location-hint {
            color: #5a4a32;
            font-size: 11px;
            margin-top: 6px;
            font-family: 'IBM Plex Mono', monospace;
        }

        #hud {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background:
                linear-gradient(to top, rgba(5, 4, 3, 0.94) 0%, rgba(10, 8, 6, 0.82) 60%, rgba(10, 8, 6, 0.2) 100%);
            padding: 10px 16px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            color: rgba(212, 197, 160, 0.78);
            z-index: 5;
            border-top: 1px solid rgba(198, 161, 90, 0.32);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 14px;
        }

        #hud-info {
            font-size: 11px;
            color: rgba(198, 161, 90, 0.72);
        }

        #toolbar {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 5;
            background: linear-gradient(180deg, rgba(14, 10, 7, 0.87), rgba(9, 7, 5, 0.82));
            border: 1px solid rgba(198, 161, 90, 0.26);
            border-radius: 12px;
            padding: 8px 10px;
            box-shadow: 0 14px 32px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(198, 161, 90, 0.18);
        }

        .toolbar-btn {
            background: linear-gradient(180deg, rgba(66, 45, 25, 0.75), rgba(36, 25, 15, 0.88));
            border: 1px solid rgba(198, 161, 90, 0.35);
            color: #e3cfaa;
            font-family: 'Cormorant Garamond', serif;
            font-size: 17px;
            letter-spacing: 0.4px;
            padding: 8px 17px;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 8px;
            box-shadow: inset 0 1px 0 rgba(230, 216, 184, 0.08), 0 2px 8px rgba(0, 0, 0, 0.26);
        }

        .toolbar-btn:hover {
            background: linear-gradient(180deg, rgba(89, 61, 33, 0.85), rgba(46, 30, 18, 0.95));
            border-color: rgba(198, 161, 90, 0.64);
            color: #fff0d0;
            transform: translateY(-1px) scale(1.01);
        }

        .toolbar-btn.has-indicator {
            position: relative;
        }

        .toolbar-btn .indicator {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 8px;
            height: 8px;
            background: #c4943a;
            border-radius: 50%;
            animation: indicatorPulse 2s infinite;
        }

        @keyframes indicatorPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.2); }
        }

        #reader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        #reader.visible {
            display: flex;
            animation: readerFadeIn 0.3s ease;
        }

        @keyframes readerFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .reader-container {
            display: flex;
            gap: 4px;
            width: 100%;
            height: 100%;
            align-items: center;
            justify-content: center;
        }

        .reader-page {
            width: min(1600px, 96vw);
            height: min(920px, 90vh);
            background: linear-gradient(170deg, #2a2015 0%, #1f1810 40%, #1a150e 100%);
            border: 1px solid #4a3520;
            border-radius: 3px;
            padding: 18px 22px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 60px rgba(0,0,0,0.8), inset 0 1px 0 rgba(196,148,58,0.06);
        }

        /* When in single-page mode, make the modal narrower for a better "book page" feel */
        .reader-page.single-page {
            width: min(980px, 72vw);
            height: min(920px, 90vh);
        }

        .reader-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 24px;
            padding-bottom: 12px;
            border-bottom: 1px solid #4a3520;
        }

        .reader-title {
            font-size: 22px;
            font-weight: 600;
            color: #c4943a;
        }

        .reader-author {
            font-size: 14px;
            color: #8b7355;
            margin-top: 4px;
        }

        .reader-coords {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            color: #5a4a32;
            margin-top: 8px;
        }

        .reader-close {
            background: none;
            border: none;
            color: #8b7355;
            font-size: 28px;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            width: 32px;
            height: 32px;
            transition: color 0.2s;
        }

        .reader-close:hover {
            color: #d4c5a0;
        }

        .reader-content {
            font-size: 16px;
            line-height: 1.8;
            color: #c4b590;
            white-space: pre-wrap;
            margin-bottom: 24px;
            overflow-x: auto;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
            padding: 16px;
            background: rgba(10, 8, 6, 0.4);
            border-radius: 2px;
        }

        .reader-content.hidden {
            display: none;
        }

        .reader-content.font-serif {
            font-family: 'Cormorant Garamond', serif;
        }

        .reader-content.font-baskerville {
            font-family: 'Libre Baskerville', serif;
        }

        .reader-content.font-mono {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            line-height: 1.6;
        }

        .reader-content.font-size-small {
            font-size: 14px;
        }

        .reader-content.font-size-medium {
            font-size: 16px;
        }

        .reader-content.font-size-large {
            font-size: 18px;
        }

        .reader-content.font-size-xlarge {
            font-size: 20px;
        }

        .reader-content.loading {
            color: #8b7355;
            font-style: italic;
            text-align: center;
            padding: 40px;
        }

        .reader-content .search-highlight {
            background: rgba(196, 148, 58, 0.4);
            border-radius: 2px;
            padding: 0 2px;
        }

        .reader-content .search-highlight.current {
            background: rgba(196, 148, 58, 0.8);
        }

        /* ============================================
           BOOK-STYLE READER (CSS only, no library)
           ============================================ */

        .book-spread {
            display: flex;
            flex: 1;
            min-height: 0;
            margin-bottom: 12px;
            perspective: 2000px;
            gap: 0;
        }

        .book-page {
            flex: 1;
            background: linear-gradient(135deg, #f4ece0 0%, #e8dcc8 50%, #ddd0b8 100%);
            color: #2a2015;
            padding: 20px 18px;
            overflow: hidden;
            position: relative;
            min-height: 340px;
            /* Height is controlled by the modal layout (flex), avoid vh-caps that waste space */
            max-height: none;
            display: flex;
            flex-direction: column;
            box-shadow: 
                inset 0 0 40px rgba(0,0,0,0.08),
                0 2px 20px rgba(0,0,0,0.3);
            transition: transform 0.4s ease, box-shadow 0.3s ease;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            will-change: transform, opacity, filter;
        }

        .book-page.left {
            border-radius: 4px 0 0 4px;
            box-shadow: 
                inset -20px 0 30px -20px rgba(0,0,0,0.15),
                inset 0 0 40px rgba(0,0,0,0.05),
                -4px 4px 15px rgba(0,0,0,0.25);
            transform-origin: right center;
        }

        .book-page.right {
            border-radius: 0 4px 4px 0;
            box-shadow: 
                inset 20px 0 30px -20px rgba(0,0,0,0.15),
                inset 0 0 40px rgba(0,0,0,0.05),
                4px 4px 15px rgba(0,0,0,0.25);
            transform-origin: left center;
        }

        /* Book spine/binding */
        .book-spine {
            width: 12px;
            background: linear-gradient(90deg, 
                #3a2a1a 0%, 
                #5a4530 20%, 
                #4a3520 50%,
                #5a4530 80%,
                #3a2a1a 100%);
            box-shadow: 
                inset 0 0 8px rgba(0,0,0,0.5),
                0 0 15px rgba(0,0,0,0.4);
            position: relative;
        }

        .book-spine::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 100%;
            background: linear-gradient(to bottom, 
                transparent 0%, 
                rgba(196,148,58,0.3) 10%,
                rgba(196,148,58,0.3) 90%,
                transparent 100%);
        }

        /* Page content styling */
        .book-page-content {
            font-size: 15px;
            line-height: 1.85;
            white-space: normal;
            text-align: left;
            hyphens: manual;
            word-break: normal;
            overflow-wrap: normal;
            flex: 1;
            min-height: 0;
        }

        .book-page-content p {
            margin: 0 0 0.65em 0;
            text-indent: 1.2em;
        }

        .book-page-content p:last-child {
            margin-bottom: 0;
        }

        .book-page-content p:first-child {
            text-indent: 0;
        }

        .book-page-content.font-serif { font-family: 'Cormorant Garamond', serif; }
        .book-page-content.font-baskerville { font-family: 'Libre Baskerville', serif; font-size: 14px; }
        .book-page-content.font-mono { font-family: 'IBM Plex Mono', monospace; font-size: 13px; line-height: 1.6; text-align: left; }
        .book-page-content.font-size-small { font-size: 13px; }
        .book-page-content.font-size-medium { font-size: 15px; }
        .book-page-content.font-size-large { font-size: 17px; }
        .book-page-content.font-size-xlarge { font-size: 19px; }

        /* Page number in corner */
        .book-page-num {
            position: absolute;
            bottom: 10px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            color: rgba(74,53,32,0.55);
        }
        .book-page.left .book-page-num { left: 20px; }
        .book-page.right .book-page-num { right: 20px; }

        /* Page turn animation */
        .book-page.turning-out.turn-next {
            animation: pageTurnOutNext 280ms cubic-bezier(0.45, 0.04, 0.75, 0.35) forwards;
        }
        .book-page.turning-in.turn-next {
            animation: pageTurnInNext 360ms cubic-bezier(0.18, 0.9, 0.25, 1) forwards;
        }
        .book-page.turning-out.turn-prev {
            animation: pageTurnOutPrev 280ms cubic-bezier(0.45, 0.04, 0.75, 0.35) forwards;
        }
        .book-page.turning-in.turn-prev {
            animation: pageTurnInPrev 360ms cubic-bezier(0.18, 0.9, 0.25, 1) forwards;
        }
        .book-page.settling {
            animation: pageSettle 360ms cubic-bezier(0.2, 0.82, 0.24, 1);
        }

        @keyframes pageTurnOutNext {
            0% { transform: rotateY(0deg) translateX(0px); opacity: 1; filter: brightness(1); }
            45% { filter: brightness(0.9); }
            100% { transform: rotateY(-78deg) translateX(-10px); opacity: 0.86; filter: brightness(0.74); }
        }
        @keyframes pageTurnInNext {
            0% { transform: rotateY(74deg) translateX(8px); opacity: 0.84; filter: brightness(0.76); }
            100% { transform: rotateY(0deg) translateX(0px); opacity: 1; filter: brightness(1); }
        }
        @keyframes pageTurnOutPrev {
            0% { transform: rotateY(0deg) translateX(0px); opacity: 1; filter: brightness(1); }
            45% { filter: brightness(0.9); }
            100% { transform: rotateY(78deg) translateX(10px); opacity: 0.86; filter: brightness(0.74); }
        }
        @keyframes pageTurnInPrev {
            0% { transform: rotateY(-74deg) translateX(-8px); opacity: 0.84; filter: brightness(0.76); }
            100% { transform: rotateY(0deg) translateX(0px); opacity: 1; filter: brightness(1); }
        }
        @keyframes pageSettle {
            0% { transform: translateX(0px); filter: brightness(0.96); }
            45% { transform: translateX(2px); filter: brightness(1.02); }
            100% { transform: translateX(0px); filter: brightness(1); }
        }

        /* Decorative corner flourishes */
        .book-page::before {
            content: '';
            position: absolute;
            top: 8px;
            width: 30px;
            height: 30px;
            opacity: 0.15;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath fill='%234a3520' d='M10,50 Q10,10 50,10 Q30,30 30,50 Q30,30 50,30 Q30,30 30,50'/%3E%3C/svg%3E");
            background-size: contain;
        }
        .book-page.left::before { left: 8px; }
        .book-page.right::before { right: 8px; transform: scaleX(-1); }

        .book-page::after {
            content: '';
            position: absolute;
            inset: 0;
            pointer-events: none;
            opacity: 0;
            background: linear-gradient(90deg, rgba(0,0,0,0.24) 0%, rgba(0,0,0,0.05) 35%, rgba(255,255,255,0.06) 70%, transparent 100%);
            transition: opacity 0.2s ease;
        }
        .book-page.turning-out::after,
        .book-page.turning-in::after {
            opacity: 1;
        }

        .book-page .search-highlight {
            background: rgba(196, 148, 58, 0.5);
            border-radius: 2px;
            padding: 0 2px;
        }

        .reader-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            padding-top: 10px;
            border-top: 1px solid #4a3520;
            flex-wrap: wrap;
        }

        .reader-page-num {
            color: #8b7355;
            font-size: 14px;
            white-space: nowrap;
        }

        .reader-nav {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .reader-nav button {
            background: rgba(74, 37, 16, 0.7);
            border: 1px solid #8b7355;
            color: #d4c5a0;
            font-family: 'Cormorant Garamond', serif;
            font-size: 15px;
            padding: 8px 14px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .reader-nav button:hover:not(:disabled) {
            background: rgba(94, 47, 20, 0.9);
            border-color: #c4943a;
        }

        .reader-nav button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .reader-page-jump {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .reader-page-jump input {
            width: 50px;
            background: #1a1208;
            border: 1px solid #4a3520;
            color: #d4c5a0;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            padding: 6px;
            border-radius: 4px;
            text-align: center;
        }

        .reader-page-jump input:focus {
            outline: none;
            border-color: #c4943a;
        }

        .reader-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .reader-action-btn {
            background: none;
            border: 1px solid transparent;
            color: #8b7355;
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .reader-action-btn:hover {
            color: #c4943a;
            border-color: #4a3520;
        }

        .reader-action-btn.active {
            color: #c4943a;
        }

        .reader-action-btn.bookmarked {
            color: #c4943a;
        }

        .page-flip {
            animation: pageFlip 160ms ease-in-out;
        }

        @keyframes pageFlip {
            0% { opacity: 0.35; transform: translateX(8px); }
            100% { opacity: 1; transform: translateX(0); }
        }

        #reader.reader-dark .reader-page {
            background: linear-gradient(170deg, #15181f 0%, #11151b 40%, #0d1015 100%);
            border-color: #303b4b;
            box-shadow: 0 0 60px rgba(0,0,0,0.84), inset 0 1px 0 rgba(181, 208, 255, 0.08);
        }
        #reader.reader-dark .reader-header {
            border-bottom-color: #303b4b;
        }
        #reader.reader-dark .reader-title {
            color: #bad2ff;
        }
        #reader.reader-dark .reader-author,
        #reader.reader-dark .reader-coords {
            color: #90a4c1;
        }
        #reader.reader-dark .reader-close {
            color: #8ba0be;
        }
        #reader.reader-dark .reader-close:hover {
            color: #d2dff4;
        }
        #reader.reader-dark .book-page {
            background: linear-gradient(140deg, #232a36 0%, #1a212c 45%, #161c25 100%);
            color: #d9e0ea;
            box-shadow:
                inset 0 0 42px rgba(0,0,0,0.32),
                0 2px 20px rgba(0,0,0,0.48);
        }
        #reader.reader-dark .book-page.left {
            box-shadow:
                inset -20px 0 30px -20px rgba(0,0,0,0.35),
                inset 0 0 40px rgba(0,0,0,0.2),
                -4px 4px 15px rgba(0,0,0,0.38);
        }
        #reader.reader-dark .book-page.right {
            box-shadow:
                inset 20px 0 30px -20px rgba(0,0,0,0.35),
                inset 0 0 40px rgba(0,0,0,0.2),
                4px 4px 15px rgba(0,0,0,0.38);
        }
        #reader.reader-dark .book-spine {
            background: linear-gradient(90deg, #10141b 0%, #202938 20%, #18202c 50%, #202938 80%, #10141b 100%);
        }
        #reader.reader-dark .book-page-content {
            color: #d9e0ea;
        }
        #reader.reader-dark .book-page-num {
            color: rgba(205, 223, 255, 0.55);
        }
        #reader.reader-dark .book-page::before {
            opacity: 0.1;
            filter: brightness(2.7);
        }
        #reader.reader-dark .book-page .search-highlight,
        #reader.reader-dark .reader-content .search-highlight {
            background: rgba(143, 175, 255, 0.32);
        }
        #reader.reader-dark .reader-footer {
            border-top-color: #303b4b;
        }
        #reader.reader-dark .reader-page-num {
            color: #9db1ce;
        }
        #reader.reader-dark .reader-action-btn {
            color: #9db1ce;
        }
        #reader.reader-dark .reader-action-btn:hover {
            color: #d1e1ff;
            border-color: #3a4c67;
        }
        #reader.reader-dark .reader-action-btn.active,
        #reader.reader-dark .reader-action-btn.bookmarked {
            color: #c5dbff;
        }
        #reader.reader-dark .reader-nav button {
            background: rgba(33, 43, 57, 0.78);
            border-color: #3a4c67;
            color: #d5e4ff;
        }
        #reader.reader-dark .reader-nav button:hover:not(:disabled) {
            background: rgba(52, 67, 88, 0.95);
            border-color: #87a8df;
        }
        #reader.reader-dark .reader-page-jump input {
            background: #131a24;
            border-color: #314059;
            color: #d5e4ff;
        }
        #reader.reader-dark .reader-page-jump input:focus {
            border-color: #87a8df;
        }
        #reader.reader-dark .reader-search-bar,
        #reader.reader-dark .typography-dropdown {
            background: rgba(17, 22, 31, 0.98);
            border-color: #314059;
        }
        #reader.reader-dark .reader-search-bar input,
        #reader.reader-dark .typography-dropdown select {
            background: #131a24;
            border-color: #314059;
            color: #d5e4ff;
        }
        #reader.reader-dark .reader-search-bar .search-info,
        #reader.reader-dark .reader-search-bar button {
            color: #9db1ce;
        }
        #reader.reader-dark .reader-search-bar button:hover {
            color: #d1e1ff;
        }
        #reader.reader-dark .typography-dropdown label {
            color: #9db1ce;
        }
        #reader.reader-dark .chapter-sidebar {
            background: #0f141d;
        }
        #reader.reader-dark .chapter-sidebar.visible {
            border-right-color: #314059;
        }
        #reader.reader-dark .chapter-sidebar-title {
            color: #bad2ff;
        }
        #reader.reader-dark .chapter-item {
            color: #c8d9f5;
        }
        #reader.reader-dark .chapter-item:hover {
            background: rgba(52, 67, 88, 0.5);
        }
        #reader.reader-dark .chapter-item.active {
            background: rgba(52, 67, 88, 0.72);
            border-left-color: #bad2ff;
        }
        #reader.reader-dark #reader-gutenberg-link {
            color: #9ec4ff !important;
        }

        /* In-book search bar */
        .reader-search-bar {
            display: none;
            position: absolute;
            top: 10px;
            right: 80px;
            background: rgba(26, 18, 8, 0.95);
            border: 1px solid #4a3520;
            border-radius: 4px;
            padding: 8px 12px;
            gap: 8px;
            align-items: center;
            z-index: 10;
        }

        .reader-search-bar.visible {
            display: flex;
        }

        .reader-search-bar input {
            width: 200px;
            background: #1a1208;
            border: 1px solid #4a3520;
            color: #d4c5a0;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 13px;
            padding: 6px 10px;
            border-radius: 4px;
        }

        .reader-search-bar input:focus {
            outline: none;
            border-color: #c4943a;
        }

        .reader-search-bar .search-info {
            color: #8b7355;
            font-size: 12px;
            white-space: nowrap;
        }

        .reader-search-bar button {
            background: none;
            border: none;
            color: #8b7355;
            font-size: 16px;
            cursor: pointer;
            padding: 4px;
        }

        .reader-search-bar button:hover {
            color: #c4943a;
        }

        /* Chapter sidebar */
        .chapter-sidebar {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: #12100a;
            z-index: 5;

            /* Keep it out of layout when hidden so the reader stays perfectly centered */
            width: 0;
            padding: 0;
            border-right: none;
            overflow: hidden;
            transition: width 0.25s ease, padding 0.25s ease;
        }

        .chapter-sidebar.visible {
            width: 280px;
            padding: 20px;
            border-right: 1px solid #4a3520;
            overflow-y: auto;
        }

        .chapter-sidebar-title {
            font-size: 16px;
            color: #c4943a;
            margin-bottom: 16px;
            letter-spacing: 1px;
        }

        .chapter-item {
            padding: 10px 12px;
            color: #d4c5a0;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            margin-bottom: 4px;
        }

        .chapter-item:hover {
            background: rgba(74, 37, 16, 0.5);
        }

        .chapter-item.active {
            background: rgba(74, 37, 16, 0.7);
            border-left: 2px solid #c4943a;
        }

        /* Typography settings dropdown */
        .typography-dropdown {
            position: absolute;
            right: 0;
            bottom: calc(100% + 10px); /* open upward so it won't go outside the reader */
            top: auto;
            background: rgba(26, 18, 8, 0.98);
            border: 1px solid #4a3520;
            border-radius: 4px;
            padding: 14px;
            display: none;
            min-width: 220px;
            max-height: 55vh;
            overflow: auto;
            z-index: 200;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
        }

        .typography-dropdown.visible {
            display: block;
        }

        .typography-dropdown label {
            display: block;
            color: #8b7355;
            font-size: 12px;
            margin-bottom: 6px;
            margin-top: 12px;
        }

        .typography-dropdown label:first-child {
            margin-top: 0;
        }

        .typography-dropdown select {
            width: 100%;
            background: #1a1208;
            border: 1px solid #4a3520;
            color: #d4c5a0;
            font-family: 'Cormorant Garamond', serif;
            font-size: 14px;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
        }

        .typography-dropdown select:focus {
            outline: none;
            border-color: #c4943a;
        }

        .panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 420px;
            height: 100vh;
            background:
                linear-gradient(180deg, rgba(19, 14, 10, 0.99), rgba(14, 10, 8, 0.98)),
                repeating-linear-gradient(
                    0deg,
                    rgba(198, 161, 90, 0.05) 0px,
                    rgba(198, 161, 90, 0.05) 1px,
                    transparent 1px,
                    transparent 9px
                );
            border-left: 1px solid rgba(198, 161, 90, 0.35);
            z-index: 90;
            transform: translateX(100%);
            transition: transform 0.3s ease-out;
            overflow-y: auto;
            padding: 32px;
            box-shadow: -18px 0 35px rgba(0, 0, 0, 0.42), inset 1px 0 0 rgba(230, 216, 184, 0.09);
        }

        .panel.visible {
            transform: translateX(0);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(198, 161, 90, 0.28);
        }

        .panel-title {
            font-size: 25px;
            font-weight: 600;
            color: var(--deco-brass);
            letter-spacing: 1.2px;
            text-transform: uppercase;
        }

        .panel-close {
            background: none;
            border: none;
            color: #8b7355;
            font-size: 28px;
            cursor: pointer;
            line-height: 1;
            transition: color 0.2s;
        }

        .panel-close:hover {
            color: #d4c5a0;
        }

        .panel label {
            display: block;
            margin-bottom: 8px;
            color: #b99967;
            font-size: 14px;
            letter-spacing: 0.4px;
        }

        .panel input, .panel select {
            width: 100%;
            background: rgba(10, 7, 5, 0.8);
            border: 1px solid rgba(198, 161, 90, 0.28);
            color: #e2d0ad;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 13px;
            padding: 10px;
            border-radius: 7px;
            margin-bottom: 12px;
            transition: border-color 0.2s;
            box-shadow: inset 0 1px 0 rgba(230, 216, 184, 0.05);
        }

        .panel input:focus, .panel select:focus {
            outline: none;
            border-color: #c4943a;
        }

        .panel select {
            cursor: pointer;
        }

        .panel button {
            width: 100%;
            background: linear-gradient(180deg, rgba(70, 47, 27, 0.78), rgba(40, 28, 17, 0.92));
            border: 1px solid rgba(198, 161, 90, 0.42);
            color: #e3d3b3;
            font-family: 'Cormorant Garamond', serif;
            font-size: 17px;
            letter-spacing: 0.5px;
            padding: 12px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
            margin-bottom: 12px;
        }

        .panel button:hover {
            background: linear-gradient(180deg, rgba(94, 63, 35, 0.92), rgba(52, 34, 20, 0.98));
            border-color: rgba(198, 161, 90, 0.75);
            transform: translateY(-1px);
        }

        .panel-header .panel-close {
            width: auto;
            min-width: 36px;
            height: 36px;
            margin: 0;
            padding: 0 8px;
            background: none;
            border: none;
            border-radius: 6px;
        }

        .panel-header .panel-close:hover {
            transform: none;
            background: rgba(74, 53, 30, 0.35);
            border: none;
        }

        .search-philosophy {
            font-style: italic;
            font-size: 15px;
            line-height: 1.6;
            color: #8b7355;
            margin-bottom: 20px;
        }

        .panel-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 20px;
            border-bottom: 1px solid #4a3520;
            padding-bottom: 12px;
        }

        .panel-tab {
            background: none;
            border: 1px solid transparent;
            color: #8b7355;
            font-family: 'Cormorant Garamond', serif;
            font-size: 15px;
            padding: 8px 14px;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            transition: all 0.2s;
            width: auto;
            margin-bottom: 0;
        }

        .panel-tab:hover {
            color: #d4c5a0;
            border-color: #4a3520;
        }

        .panel-tab.active {
            background: rgba(74, 37, 16, 0.5);
            color: #c4943a;
            border-color: #4a3520;
            border-bottom-color: #12100a;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: tabFadeIn 0.3s ease;
        }

        @keyframes tabFadeIn {
            from { opacity: 0; transform: translateY(4px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .filter-row {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .filter-row select {
            flex: 1;
            margin-bottom: 0;
        }

        #search-results {
            margin-top: 16px;
        }

        .search-result-item {
            background: rgba(26, 18, 8, 0.6);
            border: 1px solid #4a3520;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .search-result-item:hover, .search-result-item.selected {
            background: rgba(46, 28, 12, 0.8);
            border-color: #c4943a;
            transform: translateX(2px);
        }

        .search-result-item.selected {
            box-shadow: 0 0 0 1px #c4943a inset;
        }

        .search-result-title {
            color: #c4943a;
            font-size: 15px;
            font-weight: 600;
        }

        .search-result-author {
            color: #8b7355;
            font-size: 13px;
            margin-top: 4px;
        }

        .search-result-meta {
            color: #6a5a42;
            font-size: 11px;
            margin-top: 6px;
        }

        .search-result-location {
            color: #5a4a32;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            margin-top: 8px;
        }

        .search-result-progress {
            color: #6a5a42;
            font-size: 11px;
            margin-top: 4px;
        }

        .search-keyboard-hint {
            font-size: 11px;
            color: #5a4a32;
            margin-top: 12px;
            text-align: center;
        }

        .nav-field {
            margin-bottom: 20px;
        }

        .section-divider {
            margin: 24px 0;
            padding-top: 16px;
            border-top: 1px solid #4a3520;
        }

        .section-title {
            font-size: 14px;
            color: #8b7355;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 16px;
        }

        .panel-note {
            margin: -8px 0 16px;
            color: #9f8860;
            font-size: 12px;
            line-height: 1.45;
            letter-spacing: 0.2px;
        }

        .empty-state {
            text-align: center;
            padding: 24px;
            color: #5a4a32;
            font-style: italic;
        }

        .bookmark-item, .recent-item {
            background: rgba(26, 18, 8, 0.6);
            border: 1px solid #4a3520;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .bookmark-item:hover, .recent-item:hover {
            background: rgba(46, 28, 12, 0.8);
            border-color: #c4943a;
            transform: translateX(2px);
        }

        .bookmark-remove {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: #5a4a32;
            font-size: 16px;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
            width: auto;
            margin: 0;
            transition: color 0.2s;
        }

        .bookmark-remove:hover {
            color: #c4943a;
            background: none;
        }

        .continue-reading-banner {
            background: linear-gradient(135deg, rgba(74, 37, 16, 0.9), rgba(46, 28, 12, 0.9));
            border: 1px solid #c4943a;
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .continue-reading-banner:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(196, 148, 58, 0.2);
        }

        .continue-reading-label {
            font-size: 11px;
            color: #c4943a;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .continue-reading-title {
            font-size: 17px;
            color: #d4c5a0;
            font-weight: 600;
        }

        .continue-reading-progress {
            font-size: 12px;
            color: #8b7355;
            margin-top: 4px;
        }

        #about-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 700px;
            width: 90%;
            max-height: 90vh;
            background: #12100a;
            border: 1px solid #4a3520;
            border-radius: 4px;
            padding: 40px;
            z-index: 110;
            display: none;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.9);
        }

        #about-modal.visible {
            display: block;
            animation: modalFadeIn 0.3s ease;
        }

        @keyframes modalFadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        #about-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 105;
            display: none;
        }

        #about-overlay.visible {
            display: block;
        }

        .about-header {
            text-align: center;
            margin-bottom: 32px;
        }

        .about-title {
            font-size: 32px;
            font-weight: 600;
            color: #c4943a;
            margin-bottom: 16px;
            letter-spacing: 2px;
        }

        .about-quote {
            font-style: italic;
            font-size: 18px;
            line-height: 1.6;
            color: #d4c5a0;
            margin-bottom: 8px;
        }

        .about-content {
            font-size: 16px;
            line-height: 1.8;
            color: #d4c5a0;
            margin-bottom: 24px;
        }

        .about-content p {
            margin-bottom: 16px;
        }

        .about-section-title {
            font-size: 18px;
            font-weight: 600;
            color: #c4943a;
            margin-top: 32px;
            margin-bottom: 12px;
        }

        .about-close {
            width: 100%;
            background: rgba(74, 37, 16, 0.85);
            border: 1px solid #8b7355;
            color: #d4c5a0;
            font-family: 'Cormorant Garamond', serif;
            font-size: 16px;
            padding: 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            margin-top: 24px;
        }

        .about-close:hover {
            background: rgba(94, 47, 20, 0.95);
            border-color: #c4943a;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #4a3520;
            border-radius: 50%;
            border-top-color: #c4943a;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Toast notifications */
        #toast-container {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }

        .toast {
            background: rgba(26, 18, 8, 0.95);
            border: 1px solid #c4943a;
            border-radius: 6px;
            padding: 12px 24px;
            color: #d4c5a0;
            font-size: 14px;
            animation: toastIn 0.3s ease, toastOut 0.3s ease 2.7s forwards;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        @keyframes toastIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes toastOut {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-10px); }
        }

        /* Two-page layout */
        .reader-page-right {
            display: none;
        }

        .reader-page-right.visible {
            display: block;
        }

        /* Spine label overlay (CSS2D-style) */
        #spine-label-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 4;
        }

        .spine-label {
            position: absolute;
            background: rgba(26, 18, 8, 0.9);
            border: 1px solid rgba(196, 148, 58, 0.6);
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 11px;
            color: #d4c5a0;
            white-space: nowrap;
            transform: translate(-50%, -100%);
            opacity: 0;
            transition: opacity 0.2s ease;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .spine-label.visible {
            opacity: 1;
        }

        .spine-label .spine-title {
            font-weight: 600;
            color: #c4943a;
        }

        .spine-label .spine-author {
            font-size: 10px;
            color: #8b7355;
            margin-top: 2px;
        }
    
        #elevator-hint {
            position: fixed;
            left: 50%;
            bottom: 18px;
            transform: translateX(-50%);
            background: linear-gradient(180deg, rgba(18, 13, 9, 0.92), rgba(10, 8, 6, 0.9));
            border: 1px solid rgba(198, 161, 90, 0.45);
            padding: 9px 14px;
            border-radius: 10px;
            color: #efdfbf;
            font-family: "IBM Plex Mono", monospace;
            font-size: 13px;
            letter-spacing: 0.4px;
            z-index: 9999;
            pointer-events: none;
            box-shadow: 0 12px 30px rgba(0,0,0,0.5), inset 0 1px 0 rgba(230,216,184,0.12);
        }

        #elevator-current-floor {
            margin: 0 0 14px;
            padding: 8px 10px;
            border: 1px solid rgba(198, 161, 90, 0.22);
            border-radius: 8px;
            color: #ccbc9a;
            font-size: 12px;
            letter-spacing: 0.35px;
            background: rgba(11, 8, 6, 0.7);
        }

        .elevator-subtitle {
            margin: 6px 0 10px;
            color: #c8b18a;
            font-size: 13px;
            line-height: 1.4;
            letter-spacing: 0.35px;
        }

        #elevator-buttons {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        .floor-btn {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 2px;
            text-align: left;
            padding: 10px 12px;
            border-radius: 9px;
        }

        .floor-btn .floor-name {
            font-size: 16px;
            font-family: 'Cormorant Garamond', serif;
            letter-spacing: 0.4px;
            color: #ead8b0;
        }

        .floor-btn .floor-meta {
            font-size: 11px;
            font-family: "IBM Plex Mono", monospace;
            color: #ae9a74;
            letter-spacing: 0.35px;
        }

        .floor-btn.active {
            border-color: rgba(198, 161, 90, 0.78);
            box-shadow: inset 0 0 0 1px rgba(198, 161, 90, 0.35);
        }

        @media (max-width: 900px) {
            #toolbar {
                bottom: 62px;
                width: calc(100vw - 16px);
                justify-content: center;
                flex-wrap: wrap;
                gap: 8px;
            }

            .toolbar-btn {
                flex: 1 1 calc(33.333% - 8px);
                min-width: 94px;
                padding: 7px 10px;
                font-size: 15px;
            }

            .panel {
                width: 100vw;
                padding: 20px 16px 24px;
            }

            #instructions {
                width: calc(100vw - 20px);
                text-align: center;
                top: 60px;
            }

            #hud {
                font-size: 11px;
                padding: 9px 10px;
                flex-direction: column;
                align-items: flex-start;
                gap: 3px;
            }
        }
</style>
</head>
<body>
    <canvas id="scene"></canvas>
    <div id="transition-fade"></div>
    <div id="vignette"></div>
    <div id="deco-frame"></div>
    <div id="film-grain"></div>
    <div id="spine-label-container"></div>
    <div id="title-bar">
        <span>THE LIBRARY OF GUTENBERG <span id="build-tag" style="opacity:0.35;font-family:'IBM Plex Mono',monospace;font-size:10px;letter-spacing:1px;">â€”</span></span>
        <div class="title-bar-controls">
            <div class="control-group">
                <span class="control-icon" id="audio-toggle" title="Toggle ambient audio">ðŸ”‡</span>
                <input type="range" id="volume-slider" min="0" max="100" value="30" title="Volume">
            </div>
            <div class="control-group">
                <span>â˜€</span>
                <input type="range" id="brightness-slider" min="30" max="150" value="80" title="Brightness">
            </div>
        </div>
    </div>

    <div id="intro">
        <div id="intro-text">
            <div class="intro-quote">"A library is not a luxury but one of the necessities of life."</div>
            <div class="intro-attribution">â€” Henry Ward Beecher</div>
            <div class="intro-prompt">Click anywhere to enter the Library</div>
        </div>
    </div>

    <div id="crosshair"></div>

    <div id="instructions">
        Click to look around. WASD to walk. Click any book to read it.
    </div>

    <div id="book-tooltip">
        <div class="title"></div>
        <div class="author"></div>
        <div class="location-hint"></div>
    </div>

    <div id="hud">
        <span id="hud-coords">Room 1</span>
        <span id="hud-info">Loading library catalog...</span>
    </div>

    <div id="toolbar">
        <button class="toolbar-btn" onclick="openSearch()">Search</button>
        <button class="toolbar-btn" onclick="openNav()">Navigate</button>
        <button class="toolbar-btn has-indicator" id="library-btn" onclick="openLibrary()">My Library</button>
        <button class="toolbar-btn" onclick="randomRoom()">Random</button>
        <button class="toolbar-btn" onclick="openAbout()">About</button>
    </div>

    <div id="toast-container"></div>

    <div id="reader">
        <div class="chapter-sidebar" id="chapter-sidebar">
            <div class="chapter-sidebar-title">TABLE OF CONTENTS</div>
            <div id="chapter-list"></div>
        </div>
        <div class="reader-container">
            <div class="reader-page" id="reader-page-left">
                <div class="reader-search-bar" id="reader-search-bar">
                    <input type="text" id="reader-search-input" placeholder="Search in book...">
                    <span class="search-info" id="reader-search-info"></span>
                    <button onclick="readerSearchPrev()" title="Previous">â†‘</button>
                    <button onclick="readerSearchNext()" title="Next">â†“</button>
                    <button onclick="closeReaderSearch()" title="Close">Ã—</button>
                </div>
                <div class="reader-header">
                    <div>
                        <div class="reader-title" id="reader-title">Loading...</div>
                        <div class="reader-author" id="reader-author"></div>
                        <div class="reader-coords" id="reader-coords"></div>
                    </div>
                    <button class="reader-close" onclick="closeBook()">&times;</button>
                </div>
                <div class="book-spread" id="book-spread">
                    <div class="book-page left" id="book-page-left">
                        <div class="book-page-content font-serif font-size-medium" id="book-content-left">Loading...</div>
                        <div class="book-page-num" id="book-num-left"></div>
                    </div>
                    <div class="book-spine"></div>
                    <div class="book-page right" id="book-page-right">
                        <div class="book-page-content font-serif font-size-medium" id="book-content-right"></div>
                        <div class="book-page-num" id="book-num-right"></div>
                    </div>
                </div>
                <div id="paginator-measure" aria-hidden="true" style="position:fixed;left:-99999px;top:-99999px;visibility:hidden;pointer-events:none;"></div>
                <div class="reader-content font-serif font-size-medium hidden" id="reader-content">Loading book text...</div>
                <div class="reader-footer">
                    <div class="reader-page-num" id="reader-page-num">Page 1</div>
                    <div class="reader-actions">
                        <button class="reader-action-btn" id="toc-btn" onclick="toggleChapterSidebar()" title="Table of Contents">ðŸ“‘</button>
                        <button class="reader-action-btn" id="search-book-btn" onclick="openReaderSearch()" title="Search in book (Ctrl+F)">ðŸ”</button>
                        <button class="reader-action-btn" id="bookmark-btn" onclick="toggleBookmark()" title="Bookmark">ðŸ”–</button>
                        <button class="reader-action-btn" id="reader-theme-btn" onclick="toggleReaderTheme()" title="Switch to dark pages">â˜¾</button>
                        <div style="position:relative;">
                            <button class="reader-action-btn" id="typography-btn" onclick="toggleTypographyDropdown()" title="Typography">Aa</button>
                            <div class="typography-dropdown" id="typography-dropdown">
                                <label>Font</label>
                                <select id="font-select" onchange="changeFont(this.value)">
                                    <option value="serif">Cormorant Garamond</option>
                                    <option value="baskerville">Libre Baskerville</option>
                                    <option value="mono">IBM Plex Mono</option>
                                </select>
                                <label>Size</label>
                                <select id="font-size-select" onchange="changeFontSize(this.value)">
                                    <option value="small">Small</option>
                                    <option value="medium" selected>Medium</option>
                                    <option value="large">Large</option>
                                    <option value="xlarge">Extra Large</option>
                                </select>
                            </div>
                        </div>
                        <button class="reader-action-btn" id="two-page-btn" onclick="toggleTwoPage()" title="Single page view">ðŸ“–</button>
                    </div>
                    <div class="reader-nav">
                        <button onclick="prevPage()" id="prev-page-btn">&larr; Prev</button>
                        <div class="reader-page-jump">
                            <input type="number" id="page-jump-input" min="1" title="Jump to page">
                            <button onclick="jumpToPage()" style="padding:6px 10px;font-size:12px;">Go</button>
                        </div>
                        <button onclick="nextPage()" id="next-page-btn">Next &rarr;</button>
                    </div>
                    <a id="reader-gutenberg-link" href="#" target="_blank" style="color:#c4943a;font-size:14px;">View on Gutenberg</a>
                </div>
            </div>
        </div>
    </div>

    <div id="search-panel" class="panel">
        <div class="panel-header">
            <div class="panel-title">Search</div>
            <button class="panel-close" onclick="closeSearch()">&times;</button>
        </div>
        <p class="search-philosophy">Search Project Gutenberg's catalog of over 70,000 free eBooks. Find a book and teleport directly to its shelf.</p>
        
        <div class="section-divider" style="margin-top:0; padding-top:0; border-top:none;">
            <div class="section-title">Search by Title/Author</div>
        </div>
        <input type="text" id="search-input" placeholder="e.g., Pride and Prejudice, Shakespeare...">
        <div class="filter-row">
            <select id="search-language">
                <option value="">Any Language</option>
                <option value="en">English</option>
                <option value="fr">French</option>
                <option value="de">German</option>
                <option value="es">Spanish</option>
                <option value="it">Italian</option>
                <option value="pt">Portuguese</option>
                <option value="nl">Dutch</option>
                <option value="fi">Finnish</option>
                <option value="zh">Chinese</option>
                <option value="ja">Japanese</option>
            </select>
            <select id="search-topic">
                <option value="">Any Subject</option>
                <option value="Fiction">Fiction</option>
                <option value="Science Fiction">Science Fiction</option>
                <option value="Adventure">Adventure</option>
                <option value="Mystery">Mystery</option>
                <option value="Romance">Romance</option>
                <option value="Horror">Horror</option>
                <option value="Poetry">Poetry</option>
                <option value="Drama">Drama</option>
                <option value="History">History</option>
                <option value="Philosophy">Philosophy</option>
                <option value="Science">Science</option>
                <option value="Biography">Biography</option>
                <option value="Children">Children</option>
            </select>
        </div>
        <button onclick="performSearch()">Search</button>
        
        <div class="section-divider">
            <div class="section-title">Jump by Gutenberg ID</div>
        </div>
        <input type="number" id="search-gutenberg-id" min="1" placeholder="e.g., 1342 (Pride and Prejudice)">
        <button onclick="jumpToGutenbergId()">Go to Book</button>
        
        <div id="search-results"></div>
        <div class="search-keyboard-hint" id="search-keyboard-hint" style="display:none;">
            â†‘â†“ Navigate Â· Enter to open Â· Esc to close
        </div>
    </div>

    <div id="nav-panel" class="panel">
        <div class="panel-header">
            <div class="panel-title">Navigate</div>
            <button class="panel-close" onclick="closeNav()">&times;</button>
        </div>
        <div class="section-divider" style="margin-top:0; padding-top:0; border-top:none;">
            <div class="section-title">By Floor & Section</div>
        </div>
        <div class="nav-field">
            <label>Floor:</label>
            <select id="nav-floor"></select>
        </div>
        <div class="nav-field">
            <label>Section:</label>
            <select id="nav-section"></select>
        </div>
        <div class="panel-note" id="nav-floor-meta">Loading floor catalog...</div>
        <button onclick="navigateToSection()">Go to Section</button>

        <div class="section-divider">
            <div class="section-title">Exact Coordinates</div>
        </div>
        <div class="nav-field">
            <label>Room Number:</label>
            <input type="number" id="nav-room" min="1" max="111" value="1">
        </div>
        <div class="nav-field">
            <label>Wall (1-4):</label>
            <input type="number" id="nav-wall" min="1" max="4" value="1">
        </div>
        <div class="nav-field">
            <label>Shelf (1-5):</label>
            <input type="number" id="nav-shelf" min="1" max="5" value="1">
        </div>
        <div class="nav-field">
            <label>Volume (1-32):</label>
            <input type="number" id="nav-vol" min="1" max="32" value="1">
        </div>
        <button onclick="navigateToCoords()">Go There</button>
        <div class="section-divider">
            <div class="section-title">Jump by Gutenberg ID</div>
        </div>
        <input type="number" id="nav-gutenberg-id" min="1" placeholder="e.g., 1342">
        <button onclick="navigateToGutenbergId()">Go to Book</button>
    </div>

    <div id="elevator-hint" style="display:none;">Press <strong>E</strong> to call elevator</div>

    <div id="elevator-panel" class="panel">
        <div class="panel-header">
            <div class="panel-title">Elevator</div>
            <button class="panel-close" onclick="closeElevator()">&times;</button>
        </div>
        <p class="elevator-subtitle">
            Select a floor to travel by section.
        </p>
        <div id="elevator-current-floor">Current Floor: --</div>
        <div id="elevator-buttons"></div>
    </div>

    <div id="library-panel" class="panel">
        <div class="panel-header">
            <div class="panel-title">My Library</div>
            <button class="panel-close" onclick="closeLibrary()">&times;</button>
        </div>
        
        <div id="continue-reading-section"></div>
        
        <div class="panel-tabs">
            <button class="panel-tab active" data-tab="bookmarks">Bookmarks</button>
            <button class="panel-tab" data-tab="recents">Recent</button>
        </div>
        
        <div class="tab-content active" id="bookmarks-tab">
            <div id="bookmarks-list">
                <div class="empty-state">No bookmarks yet. Open a book and click ðŸ”– to add one.</div>
            </div>
        </div>
        
        <div class="tab-content" id="recents-tab">
            <div id="recents-list">
                <div class="empty-state">No recent books. Start exploring!</div>
            </div>
        </div>
    </div>

    <div id="about-overlay" onclick="closeAbout()"></div>
    <div id="about-modal">
        <div class="about-header">
            <div class="about-title">THE LIBRARY OF GUTENBERG</div>
            <div class="about-quote">
                "A room without books is like a body without a soul."
            </div>
        </div>
        <div class="about-content">
            <p>
                This virtual library contains real books from <a href="https://www.gutenberg.org" target="_blank" style="color:#c4943a;">Project Gutenberg</a>, the oldest digital library of free eBooks. Walk through hexagonal rooms filled with classic literature.
            </p>
            <p>
                Each hexagonal room contains <strong>640 books</strong> arranged across 4 walls, 5 shelves per wall, and 32 volumes per shelf. The library holds the first 70,000 books from Project Gutenberg.
            </p>
            <p>
                Click on any book to read its full text. Use the Search feature to find specific titles or authors and teleport directly to their location.
            </p>
        </div>
        <div class="about-section-title">NAVIGATION</div>
        <div class="about-content">
            <p><strong>WASD</strong> â€” Move around<br>
            <strong>Mouse</strong> â€” Look around (click to engage)<br>
            <strong>Click a book</strong> â€” Read it<br>
            <strong>ESC</strong> â€” Release mouse / Close panels<br>
            <strong>Ctrl+F</strong> â€” Search within book</p>
        </div>

        <div class="about-section-title">LAYOUT</div>
        <div class="about-content">
            <p style="color:#8b7355;font-size:12px;line-height:1.4;">
                The layout is now server-driven (floors/tags/loc). The old â€œthemed reshelvingâ€ toggle has been removed.
            </p>
        </div>
        <div class="about-section-title">CREDITS</div>
        <div class="about-content">
            <p>
                Built with Three.js. Visual design inspired by Jorge Luis Borges's "Library of Babel" and Ethan Mollick's digital recreation. Book data from <a href="https://gutendex.com" target="_blank" style="color:#c4943a;">Gutendex API</a>.
            </p>
        </div>
        <button class="about-close" onclick="closeAbout()">Close</button>
    </div>

    <!-- Ambient audio handled via Web Audio API -->

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // ============================================
        // LIBRARY CONFIGURATION
        // ============================================

        // Version stamp (helps ensure browser isn't using a cached index.html)
        const APP_BUILD = 'css-book-v16';
        window.__APP_BUILD = APP_BUILD;

        // ============================================
        // SERVER-DRIVEN LAYOUT (floors + tags + loc)
        // ============================================
        let LAYOUT = {
            floors: null,
            floorsById: null,
            roomsTotal: null,
            slotsByFloor: null,
            slotBookIdsByRoom: null, // roomIndex -> [bookId x 640]
            primaryLocByBookId: null, // bookId -> {room,wall,shelf,volume,floorId,subId}
            tagsCache: new Map(), // roomIndex -> tags json
            tagsLoading: new Map(),
        };

        async function loadFloorsLayout() {
            if (LAYOUT.floors) return LAYOUT.floors;
            const res = await fetch('/api/layout/floors');
            if (!res.ok) throw new Error('Failed to load /api/layout/floors');
            const data = await res.json();
            LAYOUT.floors = data.floors || [];
            LAYOUT.roomsTotal = data.roomsTotal;
            LAYOUT.floorsById = new Map(LAYOUT.floors.map(f => [f.id, f]));
            if (typeof LAYOUT.roomsTotal === 'number') {
                TOTAL_ROOMS = LAYOUT.roomsTotal;
                const navRoom = document.getElementById('nav-room');
                if (navRoom) navRoom.max = String(TOTAL_ROOMS);
            }
            return LAYOUT.floors;
        }

        async function getRoomTags(roomIndex) {
            if (LAYOUT.tagsCache.has(roomIndex)) return LAYOUT.tagsCache.get(roomIndex);
            if (LAYOUT.tagsLoading.has(roomIndex)) return await LAYOUT.tagsLoading.get(roomIndex);
            const pr = (async () => {
                const res = await fetch(`/api/layout/tags/room/${String(roomIndex).padStart(3,'0')}`);
                if (!res.ok) throw new Error('Failed to load room tags');
                const data = await res.json();
                LAYOUT.tagsCache.set(roomIndex, data);
                LAYOUT.tagsLoading.delete(roomIndex);
                return data;
            })();
            LAYOUT.tagsLoading.set(roomIndex, pr);
            return await pr;
        }

        async function getBookPrimaryLocation(bookId) {
            const res = await fetch(`/api/layout/loc?bookId=${encodeURIComponent(bookId)}`);
            if (!res.ok) throw new Error('Failed to resolve book location');
            return await res.json();
        }

        function slotOffsetInRoom(wall, shelf, volume) {
            return wall * BOOKS_PER_SHELF * SHELVES_PER_WALL + shelf * BOOKS_PER_SHELF + volume;
        }

        function slotOffsetToWallShelfVolume(slotOffset) {
            const wall = Math.floor(slotOffset / (BOOKS_PER_SHELF * SHELVES_PER_WALL));
            const inWall = slotOffset % (BOOKS_PER_SHELF * SHELVES_PER_WALL);
            const shelf = Math.floor(inWall / BOOKS_PER_SHELF);
            const volume = inWall % BOOKS_PER_SHELF;
            return { wall, shelf, volume };
        }

        async function loadSlotsLayout() {
            if (LAYOUT.slotsByFloor && LAYOUT.slotBookIdsByRoom && LAYOUT.primaryLocByBookId) return LAYOUT.slotsByFloor;
            await loadFloorsLayout();

            const res = await fetch('/data/layout/slots7.v1.json');
            if (!res.ok) throw new Error('Failed to load /data/layout/slots7.v1.json');
            const slotsJson = await res.json();

            const slotBookIdsByRoom = new Map();
            const primaryLocByBookId = new Map();

            for (const floor of (LAYOUT.floors || [])) {
                const floorSlots = slotsJson?.[floor.id];
                const bookIdBySlot = floorSlots?.bookIdBySlot;
                const subIdBySlot = floorSlots?.subIdBySlot;
                if (!Array.isArray(bookIdBySlot)) continue;

                for (let roomOff = 0; roomOff < floor.roomCount; roomOff++) {
                    const room = floor.roomStart + roomOff;
                    const roomSlotStart = roomOff * BOOKS_PER_ROOM;
                    const roomBookIds = bookIdBySlot.slice(roomSlotStart, roomSlotStart + BOOKS_PER_ROOM);
                    slotBookIdsByRoom.set(room, roomBookIds);

                    for (let i = 0; i < roomBookIds.length; i++) {
                        const bookId = roomBookIds[i];
                        if (!Number.isInteger(bookId) || bookId < 1 || bookId > TOTAL_BOOKS) continue;
                        if (primaryLocByBookId.has(bookId)) continue;

                        const sub = Array.isArray(subIdBySlot) ? subIdBySlot[roomSlotStart + i] : null;
                        const { wall, shelf, volume } = slotOffsetToWallShelfVolume(i);
                        primaryLocByBookId.set(bookId, {
                            room,
                            wall,
                            shelf,
                            volume,
                            floorId: floor.id,
                            subId: sub || null,
                        });
                    }
                }
            }

            LAYOUT.slotsByFloor = slotsJson;
            LAYOUT.slotBookIdsByRoom = slotBookIdsByRoom;
            LAYOUT.primaryLocByBookId = primaryLocByBookId;
            return slotsJson;
        }

        function bookIdToLocationCanonical(bookId) {
            const id = Number(bookId);
            if (!Number.isInteger(id) || id < 1) return null;
            const loc = LAYOUT.primaryLocByBookId?.get(id);
            if (!loc) return null;
            return {
                room: loc.room,
                wall: loc.wall,
                shelf: loc.shelf,
                volume: loc.volume,
                floorId: loc.floorId,
                subId: loc.subId,
                bookId: id,
                layout: 'slots7',
            };
        }

        function locationToBookIdCanonical(room, wall, shelf, volume) {
            const slotOffset = slotOffsetInRoom(wall, shelf, volume);
            const roomBookIds = LAYOUT.slotBookIdsByRoom?.get(room);
            if (!roomBookIds || slotOffset < 0 || slotOffset >= roomBookIds.length) return null;
            const id = roomBookIds[slotOffset];
            return Number.isInteger(id) && id >= 1 ? id : null;
        }

        const buildTagEl = document.getElementById('build-tag');
        if (buildTagEl) buildTagEl.textContent = APP_BUILD;

        const BOOKS_PER_SHELF = 32;
        const SHELVES_PER_WALL = 5;
        const WALLS_PER_ROOM = 4;
        const BOOKS_PER_ROOM = BOOKS_PER_SHELF * SHELVES_PER_WALL * WALLS_PER_ROOM; // 640
        const TOTAL_BOOKS = 70000;
        let TOTAL_ROOMS = 113; // overridden by /api/layout/floors (roomsTotal)

        const WALL_NAMES = ['North', 'East', 'South', 'West'];

        // ============================================
        // PERSISTENCE (localStorage)
        // ============================================

        const STORAGE_KEYS = {
            BOOKMARKS: 'gutenberg-library-bookmarks',
            RECENTS: 'gutenberg-library-recents',
            READING_PROGRESS: 'gutenberg-library-progress',
            METADATA_CACHE: 'gutenberg-library-meta-cache',
            SETTINGS: 'gutenberg-library-settings'
        };

        function loadFromStorage(key, defaultValue = null) {
            try {
                const stored = localStorage.getItem(key);
                return stored ? JSON.parse(stored) : defaultValue;
            } catch (e) {
                console.warn('Failed to load from storage:', key, e);
                return defaultValue;
            }
        }

        function saveToStorage(key, value) {
            try {
                localStorage.setItem(key, JSON.stringify(value));
            } catch (e) {
                console.warn('Failed to save to storage:', key, e);
            }
        }

        // Load persisted data
        let bookmarks = loadFromStorage(STORAGE_KEYS.BOOKMARKS, []);
        let recents = loadFromStorage(STORAGE_KEYS.RECENTS, []);
        let readingProgress = loadFromStorage(STORAGE_KEYS.READING_PROGRESS, {});
        let metadataCache = loadFromStorage(STORAGE_KEYS.METADATA_CACHE, {});
        let settings = loadFromStorage(STORAGE_KEYS.SETTINGS, { 
            layoutVersion: 1, // deprecated (kept for backward compat)
            singlePageMode: false, 
            font: 'serif', 
            fontSize: 'medium',
            readerDarkMode: false,
            audioEnabled: false,
            volume: 30
        });
        // Force layoutVersion off: layout is now server-driven
        if (settings.layoutVersion !== 1) {
            settings.layoutVersion = 1;
            saveToStorage(STORAGE_KEYS.SETTINGS, settings);
        }

        // Book catalog cache (in-memory + persisted)
        const bookCache = new Map(Object.entries(metadataCache));

        function persistMetadataCache() {
            // Only keep last 500 entries to avoid storage bloat
            const entries = Array.from(bookCache.entries()).slice(-500);
            saveToStorage(STORAGE_KEYS.METADATA_CACHE, Object.fromEntries(entries));
        }

        // ============================================
        // AUDIO SYSTEM (Web Audio API)
        // ============================================

        let audioEnabled = settings.audioEnabled || false;
        let audioVolume = settings.volume || 30;

        // Web Audio context and nodes
        let audioContext = null;
        let pageTurnBuffer = null;
        let ambientGain = null;
        let ambientNodes = [];

        async function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create page turn sound buffer (paper rustle)
                const duration = 0.18;
                const sampleRate = audioContext.sampleRate;
                const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    // Filtered noise with envelope for paper sound
                    const envelope = Math.exp(-t * 15) * Math.sin(t * 50) * 0.4;
                    const noise = (Math.random() * 2 - 1);
                    data[i] = noise * envelope;
                }
                pageTurnBuffer = buffer;
                
                // Create ambient background (subtle library hum)
                ambientGain = audioContext.createGain();
                ambientGain.gain.value = 0;
                ambientGain.connect(audioContext.destination);
                
                // Very low frequency hum (like distant HVAC)
                const osc1 = audioContext.createOscillator();
                osc1.type = 'sine';
                osc1.frequency.value = 60;
                const gain1 = audioContext.createGain();
                gain1.gain.value = 0.015;
                osc1.connect(gain1);
                gain1.connect(ambientGain);
                osc1.start();
                ambientNodes.push(osc1);
                
                // Subtle high frequency shimmer
                const osc2 = audioContext.createOscillator();
                osc2.type = 'sine';
                osc2.frequency.value = 2400;
                const gain2 = audioContext.createGain();
                gain2.gain.value = 0.003;
                // Add slight modulation
                const lfo = audioContext.createOscillator();
                lfo.frequency.value = 0.1;
                const lfoGain = audioContext.createGain();
                lfoGain.gain.value = 0.001;
                lfo.connect(lfoGain);
                lfoGain.connect(gain2.gain);
                lfo.start();
                osc2.connect(gain2);
                gain2.connect(ambientGain);
                osc2.start();
                ambientNodes.push(osc2, lfo);
                
            } catch (e) {
                console.warn('Audio initialization failed:', e);
            }
        }

        function playPageTurn() {
            if (!audioEnabled || !audioContext || !pageTurnBuffer) return;
            try {
                const source = audioContext.createBufferSource();
                const gain = audioContext.createGain();
                source.buffer = pageTurnBuffer;
                gain.gain.value = (audioVolume / 100) * 0.4;
                source.connect(gain);
                gain.connect(audioContext.destination);
                source.start();
            } catch (e) {
                // Ignore audio errors
            }
        }

        function setAmbientVolume(vol) {
            if (ambientGain) {
                // Smooth transition
                const target = (vol / 100) * 0.8;
                ambientGain.gain.linearRampToValueAtTime(target, audioContext.currentTime + 0.5);
            }
        }

        function toggleAudio() {
            audioEnabled = !audioEnabled;
            settings.audioEnabled = audioEnabled;
            saveToStorage(STORAGE_KEYS.SETTINGS, settings);
            
            const icon = document.getElementById('audio-toggle');
            if (audioEnabled) {
                icon.textContent = 'ðŸ”Š';
                icon.classList.add('active');
                if (!audioContext) {
                    initAudio().then(() => setAmbientVolume(audioVolume));
                } else {
                    setAmbientVolume(audioVolume);
                }
            } else {
                icon.textContent = 'ðŸ”‡';
                icon.classList.remove('active');
                setAmbientVolume(0);
            }
        }

        document.getElementById('audio-toggle').addEventListener('click', toggleAudio);
        
        document.getElementById('volume-slider').addEventListener('input', (e) => {
            audioVolume = parseInt(e.target.value);
            settings.volume = audioVolume;
            saveToStorage(STORAGE_KEYS.SETTINGS, settings);
            if (audioEnabled) {
                setAmbientVolume(audioVolume);
            }
        });

        // Initialize audio state (visual only - audio starts on user interaction)
        if (audioEnabled) {
            document.getElementById('audio-toggle').textContent = 'ðŸ”Š';
            document.getElementById('audio-toggle').classList.add('active');
        }
        document.getElementById('volume-slider').value = audioVolume;

        // ============================================
        // BOOKMARKS & RECENTS MANAGEMENT
        // ============================================

        function addToRecents(bookId, title, authors) {
            const existing = recents.findIndex(r => r.bookId === bookId);
            if (existing !== -1) {
                recents.splice(existing, 1);
            }
            recents.unshift({
                bookId,
                title,
                authors,
                timestamp: Date.now()
            });
            recents = recents.slice(0, 20); // Keep last 20
            saveToStorage(STORAGE_KEYS.RECENTS, recents);
            updateLibraryUI();
        }

        function isBookmarked(bookId) {
            return bookmarks.some(b => b.bookId === bookId);
        }

        function addBookmark(bookId, title, authors) {
            if (isBookmarked(bookId)) return;
            bookmarks.unshift({
                bookId,
                title,
                authors,
                timestamp: Date.now()
            });
            saveToStorage(STORAGE_KEYS.BOOKMARKS, bookmarks);
            updateLibraryUI();
            showToast('Bookmark added');
        }

        function removeBookmark(bookId) {
            bookmarks = bookmarks.filter(b => b.bookId !== bookId);
            saveToStorage(STORAGE_KEYS.BOOKMARKS, bookmarks);
            updateLibraryUI();
            showToast('Bookmark removed');
        }

        window.toggleBookmark = function() {
            if (!currentBookId) return;
            const titleEl = document.getElementById('reader-title');
            const authorEl = document.getElementById('reader-author');
            
            if (isBookmarked(currentBookId)) {
                removeBookmark(currentBookId);
                document.getElementById('bookmark-btn').classList.remove('bookmarked');
            } else {
                addBookmark(currentBookId, titleEl.textContent, authorEl.textContent);
                document.getElementById('bookmark-btn').classList.add('bookmarked');
            }
        };

        function saveReadingProgress(bookId, pageIndex, totalPages) {
            readingProgress[bookId] = {
                page: pageIndex,
                total: totalPages,
                timestamp: Date.now()
            };
            saveToStorage(STORAGE_KEYS.READING_PROGRESS, readingProgress);
        }

        function getReadingProgress(bookId) {
            return readingProgress[bookId] || null;
        }

        function getLastReadBook() {
            let lastBook = null;
            let lastTime = 0;
            for (const [bookId, progress] of Object.entries(readingProgress)) {
                if (progress.timestamp > lastTime && progress.page > 0) {
                    lastTime = progress.timestamp;
                    lastBook = { bookId: parseInt(bookId), ...progress };
                }
            }
            return lastBook;
        }

        // ============================================
        // TOAST NOTIFICATIONS
        // ============================================

        function showToast(message) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            container.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // ============================================
        // GUTENBERG API FUNCTIONS (with caching & debounce)
        // ============================================

        let hoverDebounceTimer = null;
        const HOVER_DEBOUNCE_MS = 150;

        async function fetchBookMetadata(bookId) {
            if (bookCache.has(bookId)) {
                return bookCache.get(bookId);
            }
            try {
                // Prefer local snapshot to avoid Gutendex rate limits
                try {
                    const localRes = await fetch(`/api/local/meta?bookId=${bookId}`);
                    if (localRes.ok) {
                        const data = await localRes.json();
                        const book = {
                            id: data.id,
                            title: data.title || 'Unknown Title',
                            authors: (Array.isArray(data.authors)
                                ? data.authors.map(a => (typeof a === 'string' ? a : a?.name)).filter(Boolean).join(', ')
                                : '') || 'Unknown Author',
                            subjects: data.subjects || [],
                            languages: data.languages || [],
                        };
                        bookCache.set(bookId, book);
                        if (bookCache.size % 10 === 0) persistMetadataCache();
                        return book;
                    }
                } catch (e) {}

                const response = await fetch(`/.netlify/functions/gutenberg?meta=${bookId}`);
                if (!response.ok) return null;
                const data = await response.json();
                const book = {
                    id: data.id,
                    title: data.title || 'Unknown Title',
                    authors: (Array.isArray(data.authors)
                        ? data.authors.map(a => (typeof a === 'string' ? a : a?.name)).filter(Boolean).join(', ')
                        : '') || 'Unknown Author',
                    subjects: data.subjects || [],
                    languages: data.languages || [],
                };
                bookCache.set(bookId, book);
                // Persist cache occasionally
                if (bookCache.size % 10 === 0) {
                    persistMetadataCache();
                }
                return book;
            } catch (e) {
                console.error('Failed to fetch book metadata:', e);
                return null;
            }
        }

        function fetchBookMetadataDebounced(bookId, callback) {
            if (hoverDebounceTimer) {
                clearTimeout(hoverDebounceTimer);
            }
            // Return cached immediately if available
            if (bookCache.has(bookId)) {
                callback(bookCache.get(bookId));
                return;
            }
            hoverDebounceTimer = setTimeout(async () => {
                const meta = await fetchBookMetadata(bookId);
                callback(meta);
            }, HOVER_DEBOUNCE_MS);
        }

        async function fetchBookText(bookId) {
            try {
                const response = await fetch(`/.netlify/functions/gutenberg?id=${bookId}`);
                if (!response.ok) return null;
                return await response.text();
            } catch (e) {
                console.error('Failed to fetch book text:', e);
                return null;
            }
        }

        async function searchBooks(query, language = '', topic = '') {
            try {
                let url = `/.netlify/functions/gutenberg?search=${encodeURIComponent(query)}`;
                if (language) url += `&languages=${language}`;
                if (topic) url += `&topic=${encodeURIComponent(topic)}`;
                
                const response = await fetch(url);
                if (!response.ok) return [];
                const data = await response.json();
                // Cache the results
                if (data.results) {
                    for (const book of data.results) {
                        const cached = {
                            id: book.id,
                            title: book.title || 'Unknown Title',
                            authors: book.authors?.map(a => a.name).join(', ') || 'Unknown Author',
                            subjects: book.subjects || [],
                            languages: book.languages || [],
                        };
                        bookCache.set(book.id, cached);
                    }
                    persistMetadataCache();
                }
                return data.results || [];
            } catch (e) {
                console.error('Failed to search books:', e);
                return [];
            }
        }

        // ============================================
        // DETERMINISTIC BOOK LOCATION MAPPING (layout v1/v2)
        // ============================================

        const THEMES_V2 = [
            { id: 'fiction', label: 'FICTION' },
            { id: 'history', label: 'HISTORY & WAR' },
            { id: 'science', label: 'SCIENCE & TECH' },
            { id: 'philosophy', label: 'PHILOSOPHY & RELIGION' },
            { id: 'poetry', label: 'POETRY & DRAMA' },
            { id: 'mystery', label: 'MYSTERY & HORROR' },
            { id: 'children', label: 'CHILDREN' },
            { id: 'general', label: 'GENERAL WORKS' },
        ];

        // Elevator buttons are built after /api/layout/floors has loaded (server-driven)

        // Allocate rooms per theme so total stays exactly TOTAL_ROOMS
        const ROOMS_PER_THEME_V2 = (() => {
            const n = THEMES_V2.length;
            const base = Math.floor(TOTAL_ROOMS / n);
            const rem = TOTAL_ROOMS % n;
            return Array.from({ length: n }, (_, i) => base + (i < rem ? 1 : 0));
        })();

        const THEME_ROOM_BASE_V2 = (() => {
            const bases = [];
            let acc = 0;
            for (const r of ROOMS_PER_THEME_V2) {
                bases.push(acc);
                acc += r;
            }
            return bases;
        })();

        function themeRange(themeIndex) {
            if (LAYOUT && Array.isArray(LAYOUT.floors) && LAYOUT.floors.length) {
                const f = LAYOUT.floors[themeIndex];
                if (f) {
                    const start = f.roomStart;
                    const count = f.roomCount;
                    const end = Math.max(start, start + count - 1);
                    return { start, end, count };
                }
            }
            const start = THEME_ROOM_BASE_V2[themeIndex] ?? 0;
            const count = ROOMS_PER_THEME_V2[themeIndex] ?? 0;
            const end = Math.max(start, start + count - 1);
            return { start, end, count };
        }

        function themeIndexForRoom(roomIndex) {
            if (LAYOUT && Array.isArray(LAYOUT.floors) && LAYOUT.floors.length) {
                for (let i = 0; i < LAYOUT.floors.length; i++) {
                    const { start, end } = themeRange(i);
                    if (roomIndex >= start && roomIndex <= end) return i;
                }
                return 0;
            }
            for (let i = 0; i < THEMES_V2.length; i++) {
                const { start, end } = themeRange(i);
                if (roomIndex >= start && roomIndex <= end) return i;
            }
            return 0;
        }

        // "Floor" state: one theme section at a time
        let currentThemeIndex = 0;

        function setThemeFloor(themeIndex, localRoom = 0) {
            currentThemeIndex = Math.max(0, Math.min(THEMES_V2.length - 1, themeIndex));
            const { start, end } = themeRange(currentThemeIndex);
            const clampedLocal = Math.max(0, Math.min(end - start, localRoom));
            currentRoomIndex = start + clampedLocal;
        }


        const THEME_CAPACITY_V2 = ROOMS_PER_THEME_V2.map(r => r * BOOKS_PER_ROOM);
        const THEME_CAP_PREFIX_V2 = (() => {
            const pref = [];
            let acc = 0;
            for (const cap of THEME_CAPACITY_V2) {
                acc += cap;
                pref.push(acc);
            }
            return pref;
        })();

        // Feistel permutation over 17-bit space with cycle-walking to [0, TOTAL_BOOKS)
        const FEISTEL_BITS = 17;
        const FEISTEL_MASK = (1 << FEISTEL_BITS) - 1; // 131071
        const FEISTEL_LBITS = 8;
        const FEISTEL_RBITS = FEISTEL_BITS - FEISTEL_LBITS; // 9
        const FEISTEL_LMASK = (1 << FEISTEL_LBITS) - 1;
        const FEISTEL_RMASK = (1 << FEISTEL_RBITS) - 1;
        const FEISTEL_ROUNDS = 6;
        const FEISTEL_KEY = 0xC0DEF00D;

        function feistelF(r, k) {
            // r: 9-bit
            let x = (r ^ k) >>> 0;
            x ^= (x << 13) >>> 0;
            x ^= (x >>> 17) >>> 0;
            x ^= (x << 5) >>> 0;
            return (x >>> 0) & FEISTEL_LMASK; // 8-bit output
        }

        function feistelPermute17(x) {
            x &= FEISTEL_MASK;
            let L = x & FEISTEL_LMASK;
            let R = (x >>> FEISTEL_LBITS) & FEISTEL_RMASK;
            for (let i = 0; i < FEISTEL_ROUNDS; i++) {
                const k = (FEISTEL_KEY + i * 0x9E3779B9) >>> 0;
                const newL = R & FEISTEL_LMASK; // truncate to 8 bits
                const f = feistelF(R, k);
                const newR = (L ^ f) & FEISTEL_RMASK;
                L = newL;
                R = newR;
            }
            return ((R << FEISTEL_LBITS) | L) & FEISTEL_MASK;
        }

        function feistelUnpermute17(x) {
            x &= FEISTEL_MASK;
            let L = x & FEISTEL_LMASK;
            let R = (x >>> FEISTEL_LBITS) & FEISTEL_RMASK;
            for (let i = FEISTEL_ROUNDS - 1; i >= 0; i--) {
                const k = (FEISTEL_KEY + i * 0x9E3779B9) >>> 0;
                const prevR = L & FEISTEL_RMASK;
                const f = feistelF(prevR, k);
                const prevL = (R ^ f) & FEISTEL_LMASK;
                R = prevR;
                L = prevL;
            }
            return ((R << FEISTEL_LBITS) | L) & FEISTEL_MASK;
        }

        function permuteIndex(i) {
            // cycle-walk inside 17-bit space until < TOTAL_BOOKS
            let x = i & FEISTEL_MASK;
            do {
                x = feistelPermute17(x);
            } while (x >= TOTAL_BOOKS);
            return x;
        }

        function unpermuteIndex(j) {
            let x = j & FEISTEL_MASK;
            do {
                x = feistelUnpermute17(x);
            } while (x >= TOTAL_BOOKS);
            return x;
        }

        function themeForPermutedIndex(j) {
            // Find theme block by capacity prefix; j < TOTAL_BOOKS <= total capacity
            for (let t = 0; t < THEME_CAP_PREFIX_V2.length; t++) {
                if (j < THEME_CAP_PREFIX_V2[t]) {
                    const prev = t === 0 ? 0 : THEME_CAP_PREFIX_V2[t - 1];
                    return { themeIndex: t, slotInTheme: j - prev };
                }
            }
            // fallback
            return { themeIndex: THEME_CAP_PREFIX_V2.length - 1, slotInTheme: 0 };
        }

        function themeForRoomV2(room) {
            for (let t = 0; t < THEMES_V2.length; t++) {
                const base = THEME_ROOM_BASE_V2[t];
                const len = ROOMS_PER_THEME_V2[t];
                if (room >= base && room < base + len) return t;
            }
            return 0;
        }

        function bookIdToLocation_v1(bookId) {
            const index = bookId - 1;
            const room = Math.floor(index / BOOKS_PER_ROOM);
            const inRoom = index % BOOKS_PER_ROOM;
            const wall = Math.floor(inRoom / (BOOKS_PER_SHELF * SHELVES_PER_WALL));
            const inWall = inRoom % (BOOKS_PER_SHELF * SHELVES_PER_WALL);
            const shelf = Math.floor(inWall / BOOKS_PER_SHELF);
            const volume = inWall % BOOKS_PER_SHELF;
            return { room, wall, shelf, volume, bookId, layout: 1 };
        }

        function bookIdToLocation_v2(bookId) {
            const i = bookId - 1;
            const j = permuteIndex(i);
            const { themeIndex, slotInTheme } = themeForPermutedIndex(j);
            const roomBase = THEME_ROOM_BASE_V2[themeIndex];
            const room = roomBase + Math.floor(slotInTheme / BOOKS_PER_ROOM);
            const inRoom = slotInTheme % BOOKS_PER_ROOM;
            const wall = Math.floor(inRoom / (BOOKS_PER_SHELF * SHELVES_PER_WALL));
            const inWall = inRoom % (BOOKS_PER_SHELF * SHELVES_PER_WALL);
            const shelf = Math.floor(inWall / BOOKS_PER_SHELF);
            const volume = inWall % BOOKS_PER_SHELF;
            return { room, wall, shelf, volume, bookId, layout: 2, themeIndex };
        }

        function bookIdToLocation_legacy(bookId) {
            return (settings.layoutVersion === 2) ? bookIdToLocation_v2(bookId) : bookIdToLocation_v1(bookId);
        }

        function locationToBookId_v1(room, wall, shelf, volume) {
            const index = room * BOOKS_PER_ROOM +
                          wall * BOOKS_PER_SHELF * SHELVES_PER_WALL +
                          shelf * BOOKS_PER_SHELF +
                          volume;
            return index + 1;
        }

        function locationToBookId_v2(room, wall, shelf, volume) {
            const themeIndex = themeForRoomV2(room);
            const roomBase = THEME_ROOM_BASE_V2[themeIndex];
            const roomInTheme = room - roomBase;
            const slotInTheme = roomInTheme * BOOKS_PER_ROOM +
                                wall * BOOKS_PER_SHELF * SHELVES_PER_WALL +
                                shelf * BOOKS_PER_SHELF +
                                volume;

            const prev = themeIndex === 0 ? 0 : THEME_CAP_PREFIX_V2[themeIndex - 1];
            const j = prev + slotInTheme;
            if (j < 0 || j >= TOTAL_BOOKS) return null;
            const i = unpermuteIndex(j);
            return i + 1;
        }

        function locationToBookId_legacy(room, wall, shelf, volume) {
            return (settings.layoutVersion === 2) ? locationToBookId_v2(room, wall, shelf, volume) : locationToBookId_v1(room, wall, shelf, volume);
        }

        function bookIdToLocation(bookId) {
            return bookIdToLocationCanonical(bookId) || bookIdToLocation_legacy(bookId);
        }

        function locationToBookId(room, wall, shelf, volume) {
            return locationToBookIdCanonical(room, wall, shelf, volume) || locationToBookId_legacy(room, wall, shelf, volume);
        }

        // ============================================
        // THREE.JS SCENE SETUP
        // ============================================

        const canvas = document.getElementById('scene');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.8;

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 50);
        camera.position.set(0, 1.6, 0);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0806);
        scene.fog = new THREE.FogExp2(0x0a0806, 0.08);

        const ambientLight = new THREE.AmbientLight(0x201510, 0.4);
        scene.add(ambientLight);
        const decoSkyFill = new THREE.HemisphereLight(0x4d3920, 0x070504, 0.13);
        scene.add(decoSkyFill);

        // Materials
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x2a1f15, roughness: 0.9, metalness: 0.0 });
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1208, roughness: 0.95 });
        const ceilingMaterial = new THREE.MeshStandardMaterial({ color: 0x1f1a12, roughness: 0.9 });
        const shelfMaterial = new THREE.MeshStandardMaterial({ color: 0x4a2510, roughness: 0.7 });

        const BOOK_COLORS = [
            0x8B1A1A, 0x1A3C5A, 0x2B5329, 0x4A3728, 0x3A2E4D,
            0x5C4033, 0x2D4A2D, 0x4A1A2A, 0x1A4A4A, 0x5A4A32,
            0x3D2B1F, 0x2B3D5A, 0x6B3A2A, 0x2A4A3D, 0x4D3A5A,
            0x5A3A28, 0x283A5A, 0x3A5A28, 0x5A2838, 0x38285A,
        ];

        const columnMaterial = new THREE.MeshStandardMaterial({ color: 0x2a1f15, roughness: 0.85 });
        const signMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1208, roughness: 0.8 });
        const decoBrassMaterial = new THREE.MeshStandardMaterial({ color: 0xa78347, roughness: 0.36, metalness: 0.76 });
        const decoInlayMaterial = new THREE.MeshBasicMaterial({
            color: 0xc6a15a,
            transparent: true,
            opacity: 0.28,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const decoGlassMaterial = new THREE.MeshStandardMaterial({
            color: 0xf2d8aa,
            emissive: 0x6f5230,
            emissiveIntensity: 0.5,
            roughness: 0.24,
            metalness: 0.05,
            transparent: true,
            opacity: 0.72
        });
        const sharedMaterials = new Set([
            wallMaterial,
            floorMaterial,
            ceilingMaterial,
            shelfMaterial,
            columnMaterial,
            signMaterial,
            decoBrassMaterial,
            decoInlayMaterial,
            decoGlassMaterial
        ]);

        // Sign texture loader
        const textureLoader = new THREE.TextureLoader();

        // ============================================
        // BOOK HIGHLIGHTING SYSTEM
        // ============================================

        let highlightedBookInfo = null;
        let highlightStartTime = 0;
        const HIGHLIGHT_DURATION = 4000; // 4 seconds
        const HIGHLIGHT_COLOR = new THREE.Color(0xFFD700); // Gold

        function highlightBook(bookId) {
            const location = bookIdToLocation(bookId);
            highlightedBookInfo = {
                bookId,
                room: location.room,
                wall: location.wall,
                shelf: location.shelf,
                volume: location.volume
            };
            highlightStartTime = performance.now();
        }

        function clearHighlight() {
            highlightedBookInfo = null;
        }

        // ============================================
        // TEXT CANVAS FOR IN-WORLD SIGNS
        // ============================================

        function createTextTexture(text, options = {}) {
            const {
                fontSize = 48,
                fontFamily = 'Georgia, serif',
                color = '#c4943a',
                backgroundColor = 'rgba(26, 18, 8, 0.9)',
                padding = 20,
                width = 256,
                height = 64,
                lineGap = 6
            } = options;

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            // Background
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, width, height);

            // Border
            ctx.strokeStyle = '#4a3520';
            ctx.lineWidth = 2;
            ctx.strokeRect(2, 2, width - 4, height - 4);

            // Text (supports multi-line with \n)
            const lines = String(text || '').split('\n').map(s => s.trim()).filter(Boolean);
            ctx.fillStyle = color;
            ctx.font = `${fontSize}px ${fontFamily}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const usableH = height - padding * 2;
            const lineH = fontSize + lineGap;
            const blockH = lines.length * lineH - lineGap;
            const startY = padding + (usableH - blockH) / 2 + fontSize / 2;

            lines.forEach((ln, i) => {
                ctx.fillText(ln, width / 2, startY + i * lineH);
            });

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function createArtDecoPlaqueTexture(title, subtitle = '', options = {}) {
            const {
                width = 320,
                height = 114,
                titleSize = 54,
                subtitleSize = 22,
            } = options;

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            const grad = ctx.createLinearGradient(0, 0, 0, height);
            grad.addColorStop(0, '#2c2218');
            grad.addColorStop(0.5, '#1b140d');
            grad.addColorStop(1, '#120d08');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);

            ctx.strokeStyle = 'rgba(198,161,90,0.92)';
            ctx.lineWidth = 4;
            ctx.strokeRect(2, 2, width - 4, height - 4);
            ctx.strokeStyle = 'rgba(198,161,90,0.35)';
            ctx.lineWidth = 1;
            ctx.strokeRect(8, 8, width - 16, height - 16);

            ctx.fillStyle = 'rgba(198,161,90,0.55)';
            const motifW = 18;
            const motifY = 10;
            for (const x of [width * 0.5 - 34, width * 0.5 - 8, width * 0.5 + 18]) {
                ctx.beginPath();
                ctx.moveTo(x, motifY);
                ctx.lineTo(x + motifW, motifY);
                ctx.lineTo(x + motifW * 0.5, motifY + 11);
                ctx.closePath();
                ctx.fill();
            }

            ctx.fillStyle = '#dbc494';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = `700 ${titleSize}px "Cormorant Garamond", serif`;
            ctx.fillText(String(title || '').toUpperCase(), width / 2, subtitle ? height * 0.42 : height * 0.52);

            if (subtitle) {
                ctx.strokeStyle = 'rgba(198,161,90,0.45)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(width * 0.2, height * 0.59);
                ctx.lineTo(width * 0.8, height * 0.59);
                ctx.stroke();

                ctx.fillStyle = 'rgba(198,161,90,0.95)';
                ctx.font = `600 ${subtitleSize}px "IBM Plex Mono", monospace`;
                ctx.fillText(String(subtitle), width / 2, height * 0.77);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.generateMipmaps = false;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.needsUpdate = true;
            return texture;
        }

        function createShelfLabel(text, options = {}) {
            const {
                fontSize = 24,
                width = 128,
                height = 32
            } = options;

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            // Dark background
            ctx.fillStyle = 'rgba(26, 18, 8, 0.85)';
            ctx.fillRect(0, 0, width, height);

            // Subtle border
            ctx.strokeStyle = 'rgba(74, 53, 32, 0.6)';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, width, height);

            // Text
            ctx.fillStyle = '#8b7355';
            ctx.font = `${fontSize}px "IBM Plex Mono", monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, width / 2, height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.generateMipmaps = false;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.needsUpdate = true;
            return texture;
        }

        function createLightShaftTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            grad.addColorStop(0, 'rgba(255, 232, 185, 0.66)');
            grad.addColorStop(0.35, 'rgba(240, 192, 128, 0.26)');
            grad.addColorStop(1, 'rgba(160, 110, 70, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.globalCompositeOperation = 'destination-in';
            const radial = ctx.createRadialGradient(
                canvas.width / 2,
                canvas.height * 0.15,
                6,
                canvas.width / 2,
                canvas.height * 0.7,
                canvas.width * 0.46
            );
            radial.addColorStop(0, 'rgba(255,255,255,1)');
            radial.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = radial;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            return texture;
        }

        // ============================================
        // HEXAGONAL ROOM GEOMETRY
        // ============================================

        const R = 3;
        const ROOM_HEIGHT = 3.2;
        const CORRIDOR_LENGTH = 2.5;
        const ROOM_DEPTH = R * Math.sqrt(3) + CORRIDOR_LENGTH;

        const HEX_VERTICES = [];
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i;
            HEX_VERTICES.push(new THREE.Vector3(R * Math.cos(angle), 0, R * Math.sin(angle)));
        }

        const BOOKSHELF_WALLS = [0, 2, 3, 5];
        const SHELF_HEIGHTS = [0.3, 0.85, 1.4, 1.95, 2.5];

        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        const lightShaftTexture = createLightShaftTexture();

        function addArtDecoCenterpiece(group, roomIndex) {
            const inlayGroup = new THREE.Group();
            inlayGroup.position.y = 0.003;
            group.add(inlayGroup);

            const ringBands = [
                [0.38, 0.46],
                [0.92, 1.02],
                [1.34, 1.46],
            ];
            for (const [innerR, outerR] of ringBands) {
                const ring = new THREE.Mesh(new THREE.RingGeometry(innerR, outerR, 6, 1), decoInlayMaterial);
                ring.rotation.x = -Math.PI / 2;
                inlayGroup.add(ring);
            }

            for (let i = 0; i < 12; i++) {
                const ang = (Math.PI * 2 * i) / 12;
                const ray = new THREE.Mesh(new THREE.BoxGeometry(0.035, 0.003, 1.45), decoInlayMaterial);
                ray.position.set(Math.sin(ang) * 0.76, 0, Math.cos(ang) * 0.76);
                ray.rotation.y = ang;
                inlayGroup.add(ray);
            }

            const medallion = new THREE.Group();
            medallion.position.y = ROOM_HEIGHT - 0.08;
            group.add(medallion);

            const medallionBase = new THREE.Mesh(new THREE.CylinderGeometry(0.92, 1.0, 0.04, 28), decoBrassMaterial);
            medallionBase.position.y = -0.02;
            medallion.add(medallionBase);

            const medallionInner = new THREE.Mesh(new THREE.TorusGeometry(0.44, 0.03, 10, 28), decoBrassMaterial);
            medallionInner.rotation.x = Math.PI / 2;
            medallion.add(medallionInner);

            const chandelierPivot = new THREE.Group();
            chandelierPivot.position.set(0, ROOM_HEIGHT - 0.11, 0);
            group.add(chandelierPivot);

            const chain = new THREE.Mesh(new THREE.CylinderGeometry(0.014, 0.014, 0.62, 10), decoBrassMaterial);
            chain.position.y = -0.31;
            chandelierPivot.add(chain);

            const chandelier = new THREE.Group();
            chandelier.position.y = -0.62;
            chandelierPivot.add(chandelier);

            const chandelierRing = new THREE.Mesh(new THREE.TorusGeometry(0.54, 0.05, 10, 32), decoBrassMaterial);
            chandelierRing.rotation.x = Math.PI / 2;
            chandelier.add(chandelierRing);

            const innerRing = new THREE.Mesh(new THREE.TorusGeometry(0.3, 0.023, 10, 28), decoBrassMaterial);
            innerRing.rotation.x = Math.PI / 2;
            innerRing.position.y = -0.045;
            chandelier.add(innerRing);

            for (let i = 0; i < 12; i++) {
                const glass = new THREE.Mesh(new THREE.BoxGeometry(0.028, 0.24, 0.028), decoGlassMaterial);
                const ang = (Math.PI * 2 * i) / 12;
                glass.position.set(Math.cos(ang) * 0.5, -0.08, Math.sin(ang) * 0.5);
                chandelier.add(glass);
            }

            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.095, 16, 16),
                new THREE.MeshStandardMaterial({
                    color: 0xf3d7a4,
                    emissive: 0x8d6536,
                    emissiveIntensity: 0.9,
                    roughness: 0.34,
                    metalness: 0.08
                })
            );
            core.position.y = -0.06;
            chandelier.add(core);

            const chandelierLight = new THREE.PointLight(0xffddae, 1.35, 8.2, 1.45);
            chandelierLight.position.set(0, ROOM_HEIGHT - 0.74, 0);
            group.add(chandelierLight);

            const shaftGeom = new THREE.ConeGeometry(0.36, 1.68, 20, 1, true);
            const lightShafts = [];
            for (const lampX of [-0.8, 0.8]) {
                const shaft = new THREE.Mesh(
                    shaftGeom,
                    new THREE.MeshBasicMaterial({
                        map: lightShaftTexture,
                        color: 0xffd9a4,
                        transparent: true,
                        opacity: 0.13,
                        side: THREE.DoubleSide,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false
                    })
                );
                shaft.position.set(lampX, ROOM_HEIGHT - 1.02, 0);
                shaft.renderOrder = 8;
                group.add(shaft);
                lightShafts.push(shaft);
            }

            return {
                inlayGroup,
                chandelierPivot,
                chandelierLight,
                lightShafts,
                motionSeed: roomIndex * 0.41,
            };
        }

        function createFullRoom(roomIndex, offsetZ) {
            const group = new THREE.Group();
            group.position.z = offsetZ;

            // Floor
            const floorShape = new THREE.Shape();
            for (let i = 0; i <= 6; i++) {
                const angle = (Math.PI / 3) * (i % 6);
                const x = R * Math.cos(angle);
                const z = R * Math.sin(angle);
                if (i === 0) floorShape.moveTo(x, z);
                else floorShape.lineTo(x, z);
            }
            const floorGeom = new THREE.ShapeGeometry(floorShape);
            floorGeom.rotateX(-Math.PI / 2);
            const floorMesh = new THREE.Mesh(floorGeom, floorMaterial);
            group.add(floorMesh);

            // Ceiling
            const ceilGeom = floorGeom.clone();
            const ceilMesh = new THREE.Mesh(ceilGeom, ceilingMaterial);
            ceilMesh.position.y = ROOM_HEIGHT;
            ceilMesh.rotation.x = Math.PI;
            group.add(ceilMesh);
            const decoCenterpiece = addArtDecoCenterpiece(group, roomIndex);

            // Bookshelf walls
            for (const wallIdx of BOOKSHELF_WALLS) {
                const va = HEX_VERTICES[wallIdx];
                const vb = HEX_VERTICES[(wallIdx + 1) % 6];
                const wallLen = va.distanceTo(vb);
                const wallGeom = new THREE.PlaneGeometry(wallLen, ROOM_HEIGHT);
                const wallMesh = new THREE.Mesh(wallGeom, wallMaterial);

                const midpoint = new THREE.Vector3((va.x + vb.x) / 2, ROOM_HEIGHT / 2, (va.z + vb.z) / 2);
                wallMesh.position.copy(midpoint);

                const center = new THREE.Vector3((va.x + vb.x) / 2, 0, (va.z + vb.z) / 2);
                const inwardAngle = Math.atan2(-center.x, -center.z);
                wallMesh.rotation.y = inwardAngle;

                group.add(wallMesh);
            }

            // Passage archways
            const PASSAGE_WALLS = [1, 4];
            for (const passIdx of PASSAGE_WALLS) {
                const va = HEX_VERTICES[passIdx];
                const vb = HEX_VERTICES[(passIdx + 1) % 6];
                const center = new THREE.Vector3((va.x + vb.x) / 2, 0, (va.z + vb.z) / 2);
                const passAngle = Math.atan2(-center.x, -center.z);

                // Top beam
                const beamGeom = new THREE.BoxGeometry(R, 0.15, 0.2);
                const beamMesh = new THREE.Mesh(beamGeom, shelfMaterial);
                beamMesh.position.set(center.x, ROOM_HEIGHT - 0.075, center.z);
                beamMesh.rotation.y = passAngle;
                group.add(beamMesh);

                // Art Deco marquee sign above passage
                const roomNum = roomIndex + 1;
                const floorInfo = (LAYOUT && Array.isArray(LAYOUT.floors))
                    ? LAYOUT.floors.find(f => roomIndex >= f.roomStart && roomIndex < (f.roomStart + f.roomCount))
                    : null;
                const sectionLabel = floorInfo?.label || (THEMES_V2[themeIndexForRoom(roomIndex)]?.label || 'SECTION');
                const signTexture = createArtDecoPlaqueTexture(`Room ${roomNum}`, sectionLabel.toUpperCase(), {
                    width: 360,
                    height: 126,
                    titleSize: 50,
                    subtitleSize: 18,
                });
                const plaqueMat = new THREE.MeshBasicMaterial({ map: signTexture, transparent: true });
                const signMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.98, 0.34), plaqueMat);
                const signOffsetDir = new THREE.Vector3(-center.x, 0, -center.z).normalize();
                signMesh.position.set(center.x, ROOM_HEIGHT - 0.24, center.z);
                signMesh.position.add(signOffsetDir.clone().multiplyScalar(0.14));
                signMesh.rotation.y = passAngle;
                group.add(signMesh);

                const capMat = new THREE.MeshStandardMaterial({ color: 0x7b6034, roughness: 0.45, metalness: 0.65 });
                const signCap = new THREE.Mesh(new THREE.BoxGeometry(1.04, 0.03, 0.04), capMat);
                signCap.position.copy(signMesh.position).add(signOffsetDir.clone().multiplyScalar(0.02));
                signCap.position.y += 0.19;
                signCap.rotation.y = passAngle;
                group.add(signCap);

                // Sunburst brass ribs to accent each passage marquee
                for (let rib = -3; rib <= 3; rib++) {
                    const ribMesh = new THREE.Mesh(new THREE.BoxGeometry(0.018, 0.24, 0.018), decoBrassMaterial);
                    ribMesh.position.copy(signMesh.position);
                    ribMesh.position.y += 0.29 + Math.abs(rib) * 0.012;
                    ribMesh.position.add(signOffsetDir.clone().multiplyScalar(0.028 + Math.abs(rib) * 0.004));
                    const spread = rib * 0.09;
                    const sideDir = new THREE.Vector3(Math.cos(passAngle), 0, -Math.sin(passAngle));
                    ribMesh.position.add(sideDir.multiplyScalar(spread));
                    ribMesh.rotation.y = passAngle;
                    ribMesh.rotation.z = rib * -0.07;
                    group.add(ribMesh);
                }

                // Side columns
                const colGeom = new THREE.BoxGeometry(0.15, ROOM_HEIGHT, 0.2);
                const col1 = new THREE.Mesh(colGeom, columnMaterial);
                col1.position.set(va.x, ROOM_HEIGHT / 2, va.z);
                col1.rotation.y = passAngle;
                group.add(col1);
                const col2 = new THREE.Mesh(colGeom, columnMaterial);
                col2.position.set(vb.x, ROOM_HEIGHT / 2, vb.z);
                col2.rotation.y = passAngle;
                group.add(col2);

                // Corridor
                const corridorWidth = 1.8;
                const corridorDepth = CORRIDOR_LENGTH / 2;
                const outwardDir = new THREE.Vector3(center.x, 0, center.z).normalize();
                const rightDir = new THREE.Vector3(-outwardDir.z, 0, outwardDir.x);

                const passageEdgeZ = R * Math.sqrt(3) / 2;
                const corridorCenter = center.clone().normalize().multiplyScalar(passageEdgeZ + corridorDepth / 2);

                // Corridor floor
                const corridorFloorGeom = new THREE.PlaneGeometry(corridorWidth, corridorDepth);
                const corridorFloor = new THREE.Mesh(corridorFloorGeom, floorMaterial);
                corridorFloor.rotation.x = -Math.PI / 2;
                corridorFloor.position.copy(corridorCenter);
                corridorFloor.position.y = 0;
                group.add(corridorFloor);

                // Corridor ceiling
                const corridorCeiling = new THREE.Mesh(corridorFloorGeom, ceilingMaterial);
                corridorCeiling.rotation.x = Math.PI / 2;
                corridorCeiling.position.copy(corridorCenter);
                corridorCeiling.position.y = ROOM_HEIGHT;
                group.add(corridorCeiling);

                // Corridor walls
                const corridorWallGeom = new THREE.PlaneGeometry(corridorDepth, ROOM_HEIGHT);

                const leftWallPos = corridorCenter.clone().add(rightDir.clone().multiplyScalar(-corridorWidth / 2));
                const leftWall = new THREE.Mesh(corridorWallGeom, wallMaterial);
                leftWall.position.copy(leftWallPos);
                leftWall.position.y = ROOM_HEIGHT / 2;
                leftWall.rotation.y = passAngle + Math.PI / 2;
                group.add(leftWall);

                const rightWallPos = corridorCenter.clone().add(rightDir.clone().multiplyScalar(corridorWidth / 2));
                const rightWall = new THREE.Mesh(corridorWallGeom, wallMaterial);
                rightWall.position.copy(rightWallPos);
                rightWall.position.y = ROOM_HEIGHT / 2;
                rightWall.rotation.y = passAngle - Math.PI / 2;
                group.add(rightWall);

                // Infill walls
                const gapPerSide = (R - corridorWidth) / 2;
                if (gapPerSide > 0.01) {
                    const infillGeom = new THREE.PlaneGeometry(gapPerSide, ROOM_HEIGHT);

                    const leftInfill = new THREE.Mesh(infillGeom, wallMaterial);
                    const leftInfillPos = center.clone()
                        .add(rightDir.clone().multiplyScalar(-(corridorWidth / 2 + gapPerSide / 2)));
                    leftInfill.position.copy(leftInfillPos);
                    leftInfill.position.y = ROOM_HEIGHT / 2;
                    leftInfill.rotation.y = passAngle;
                    group.add(leftInfill);

                    const rightInfill = new THREE.Mesh(infillGeom, wallMaterial);
                    const rightInfillPos = center.clone()
                        .add(rightDir.clone().multiplyScalar(corridorWidth / 2 + gapPerSide / 2));
                    rightInfill.position.copy(rightInfillPos);
                    rightInfill.position.y = ROOM_HEIGHT / 2;
                    rightInfill.rotation.y = passAngle;
                    group.add(rightInfill);
                }
            }

            // Lamps with more dynamic flicker
            const lampGeom = new THREE.SphereGeometry(0.12, 16, 16);
            const lampMat = new THREE.MeshBasicMaterial({ color: 0xFFE0A0 });
            const lamp1 = new THREE.Mesh(lampGeom, lampMat);
            lamp1.position.set(0.8, ROOM_HEIGHT - 0.2, 0);
            group.add(lamp1);
            const lamp2 = new THREE.Mesh(lampGeom, lampMat);
            lamp2.position.set(-0.8, ROOM_HEIGHT - 0.2, 0);
            group.add(lamp2);

            const light1 = new THREE.PointLight(0xFFD280, 2.0, 10, 1.2);
            light1.position.copy(lamp1.position);
            group.add(light1);
            const light2 = new THREE.PointLight(0xFFD280, 2.0, 10, 1.2);
            light2.position.copy(lamp2.position);
            group.add(light2);

            // Add bookshelves with books and wall/shelf signs
            const { bookMesh, bookMap, originalColors } = addBookshelves(group, roomIndex);

            

            // Elevator at pipe ends (visual + interaction point)
            let elevatorLocal = null;
            const tr = themeRange(themeIndexForRoom(roomIndex));
            if (roomIndex === tr.start || roomIndex === tr.end) {
                // Use one of the passage corridors as the elevator bay
                const elevatorPassIdx = (roomIndex === tr.start) ? 4 : 1;
                const vaE = HEX_VERTICES[elevatorPassIdx];
                const vbE = HEX_VERTICES[(elevatorPassIdx + 1) % 6];
                const cE = new THREE.Vector3((vaE.x + vbE.x) / 2, 0, (vaE.z + vbE.z) / 2);
                const outwardE = cE.clone().normalize();
                const passAngleE = Math.atan2(-cE.x, -cE.z);
                const corridorDepthE = CORRIDOR_LENGTH / 2;
                const passageEdgeZE = R * Math.sqrt(3) / 2;
                const corridorEndE = passageEdgeZE + corridorDepthE;

                elevatorLocal = outwardE.clone().multiplyScalar(corridorEndE - 0.35);
                elevatorLocal.y = 0;

                const elev = new THREE.Group();
                elev.position.copy(elevatorLocal);
                elev.position.y = 0;
                elev.rotation.y = passAngleE;

                const trimMat = new THREE.MeshStandardMaterial({ color: 0x8d6d3b, roughness: 0.38, metalness: 0.72 });
                const frameMat = new THREE.MeshStandardMaterial({ color: 0x2a2016, roughness: 0.72, metalness: 0.25 });
                const doorMat = new THREE.MeshStandardMaterial({ color: 0x15110d, roughness: 0.56, metalness: 0.52 });
                const indicatorMat = new THREE.MeshBasicMaterial({ color: 0xc6a15a, transparent: true, opacity: 0.35 });

                const backPanel = new THREE.Mesh(new THREE.BoxGeometry(1.18, 2.58, 0.1), frameMat);
                backPanel.position.set(0, 1.3, -0.24);
                elev.add(backPanel);

                const outerFrame = new THREE.Mesh(new THREE.BoxGeometry(1.3, 2.72, 0.12), trimMat);
                outerFrame.position.set(0, 1.36, -0.18);
                elev.add(outerFrame);

                const doorLeft = new THREE.Mesh(new THREE.BoxGeometry(0.49, 2.18, 0.07), doorMat);
                doorLeft.position.set(-0.255, 1.1, -0.26);
                elev.add(doorLeft);

                const doorRight = new THREE.Mesh(new THREE.BoxGeometry(0.49, 2.18, 0.07), doorMat);
                doorRight.position.set(0.255, 1.1, -0.26);
                elev.add(doorRight);

                const seam = new THREE.Mesh(new THREE.BoxGeometry(0.03, 2.2, 0.03), trimMat);
                seam.position.set(0, 1.1, -0.245);
                elev.add(seam);

                for (const x of [-0.34, -0.16, 0.16, 0.34]) {
                    const rib = new THREE.Mesh(new THREE.BoxGeometry(0.024, 2.0, 0.024), trimMat);
                    rib.position.set(x, 1.1, -0.235);
                    elev.add(rib);
                }

                const callPanel = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.56, 0.05), trimMat);
                callPanel.position.set(0.72, 1.18, -0.2);
                elev.add(callPanel);

                const callFace = new THREE.Mesh(new THREE.PlaneGeometry(0.12, 0.5), new THREE.MeshBasicMaterial({ color: 0x1a130c }));
                callFace.position.set(0.72, 1.18, -0.172);
                elev.add(callFace);

                const upLight = new THREE.Mesh(new THREE.CircleGeometry(0.026, 20), indicatorMat.clone());
                upLight.position.set(0.72, 1.30, -0.168);
                elev.add(upLight);

                const downLight = new THREE.Mesh(new THREE.CircleGeometry(0.026, 20), indicatorMat.clone());
                downLight.position.set(0.72, 1.04, -0.168);
                elev.add(downLight);

                const dirLabel = roomIndex === tr.start ? 'UP' : 'DOWN';
                const signTex = createArtDecoPlaqueTexture('Lift', dirLabel, {
                    width: 280,
                    height: 92,
                    titleSize: 38,
                    subtitleSize: 18,
                });
                const sign = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.9, 0.27),
                    new THREE.MeshBasicMaterial({ map: signTex, transparent: true })
                );
                sign.position.set(0, 2.33, -0.11);
                elev.add(sign);

                const transomBar = new THREE.Mesh(new THREE.BoxGeometry(1.22, 0.06, 0.05), trimMat);
                transomBar.position.set(0, 2.46, -0.17);
                elev.add(transomBar);

                const elevLight = new THREE.PointLight(0xffd79c, 1.05, 4.5, 1.4);
                elevLight.position.set(0, 2.02, 0.38);
                elev.add(elevLight);

                group.add(elev);
            }

            return {
                group,
                bookMesh,
                bookMap,
                originalColors,
                lights: [light1, light2],
                lamps: [lamp1, lamp2],
                roomIndex,
                elevatorLocal,
                inlayGroup: decoCenterpiece.inlayGroup,
                chandelierPivot: decoCenterpiece.chandelierPivot,
                chandelierLight: decoCenterpiece.chandelierLight,
                lightShafts: decoCenterpiece.lightShafts,
                decoMotionSeed: decoCenterpiece.motionSeed,
            };
        }

        function addBookshelves(group, roomIndex) {
            const SHELF_DEPTH = 0.25;
            const SHELF_THICKNESS = 0.02;

            // Shelf planks and wall/shelf labels
            for (let w = 0; w < BOOKSHELF_WALLS.length; w++) {
                const wallIdx = BOOKSHELF_WALLS[w];
                const va = HEX_VERTICES[wallIdx];
                const vb = HEX_VERTICES[(wallIdx + 1) % 6];
                const wallCenter = new THREE.Vector3((va.x + vb.x) / 2, 0, (va.z + vb.z) / 2);
                const inwardDir = new THREE.Vector3(-wallCenter.x, 0, -wallCenter.z).normalize();
                const wallAngle = Math.atan2(-wallCenter.x, -wallCenter.z);

                // Wall marker (deco mini plaque)
                const wallLabelTexture = createArtDecoPlaqueTexture(`Wall ${w + 1}`, WALL_NAMES[w].toUpperCase(), {
                    width: 228,
                    height: 84,
                    titleSize: 28,
                    subtitleSize: 14,
                });
                const wallLabelGeom = new THREE.PlaneGeometry(0.58, 0.15);
                const wallLabelMat = new THREE.MeshBasicMaterial({ map: wallLabelTexture, transparent: true });
                const wallLabelMesh = new THREE.Mesh(wallLabelGeom, wallLabelMat);
                const wallLabelPos = wallCenter.clone().add(inwardDir.clone().multiplyScalar(0.3));
                wallLabelPos.y = ROOM_HEIGHT - 0.18;
                wallLabelMesh.position.copy(wallLabelPos);
                wallLabelMesh.rotation.y = wallAngle;
                group.add(wallLabelMesh);

                for (let s = 0; s < SHELF_HEIGHTS.length; s++) {
                    const shelfGeom = new THREE.BoxGeometry(R - 0.1, SHELF_THICKNESS, SHELF_DEPTH);
                    const shelfMesh = new THREE.Mesh(shelfGeom, shelfMaterial);

                    const shelfPos = wallCenter.clone().add(inwardDir.clone().multiplyScalar(SHELF_DEPTH / 2 + 0.02));
                    shelfPos.y = SHELF_HEIGHTS[s];
                    shelfMesh.position.copy(shelfPos);
                    shelfMesh.rotation.y = wallAngle;
                    group.add(shelfMesh);

                }
            }

            // Books as instanced mesh
            const totalBooks = BOOKSHELF_WALLS.length * SHELF_HEIGHTS.length * BOOKS_PER_SHELF;
            const bookGeom = new THREE.BoxGeometry(0.07, 0.20, 0.18);
            const bookMat = new THREE.MeshStandardMaterial({ roughness: 0.6, metalness: 0.05 });
            const bookMesh = new THREE.InstancedMesh(bookGeom, bookMat, totalBooks);

            const bookMap = [];
            const originalColors = new Float32Array(totalBooks * 3);
            let instanceId = 0;
            const matrix = new THREE.Matrix4();
            const color = new THREE.Color();

            for (let w = 0; w < BOOKSHELF_WALLS.length; w++) {
                const wallIdx = BOOKSHELF_WALLS[w];
                const va = HEX_VERTICES[wallIdx];
                const vb = HEX_VERTICES[(wallIdx + 1) % 6];
                const wallCenter = new THREE.Vector3((va.x + vb.x) / 2, 0, (va.z + vb.z) / 2);
                const wallDir = new THREE.Vector3().subVectors(vb, va).normalize();
                const inwardDir = new THREE.Vector3(-wallCenter.x, 0, -wallCenter.z).normalize();
                const wallAngle = Math.atan2(-wallCenter.x, -wallCenter.z);

                for (let s = 0; s < SHELF_HEIGHTS.length; s++) {
                    for (let v = 0; v < BOOKS_PER_SHELF; v++) {
                        const slot = v - BOOKS_PER_SHELF / 2;
                        const slotWidth = (R - 0.2) / BOOKS_PER_SHELF;

                        const bookPos = wallCenter.clone()
                            .add(wallDir.clone().multiplyScalar(slot * slotWidth))
                            .add(inwardDir.clone().multiplyScalar(0.18));

                        const bookId = locationToBookId(roomIndex, w, s, v);
                        const seed = bookId;
                        const bookHeight = 0.18 + seededRandom(seed) * 0.06;
                        bookPos.y = SHELF_HEIGHTS[s] + SHELF_THICKNESS / 2 + bookHeight / 2;

                        matrix.identity();
                        matrix.makeRotationY(wallAngle);
                        matrix.setPosition(bookPos);
                        matrix.scale(new THREE.Vector3(1, bookHeight / 0.20, 1));
                        bookMesh.setMatrixAt(instanceId, matrix);

                        const colorIndex = bookId % BOOK_COLORS.length;
                        color.setHex(BOOK_COLORS[colorIndex]);
                        bookMesh.setColorAt(instanceId, color);
                        
                        // Store original color
                        originalColors[instanceId * 3] = color.r;
                        originalColors[instanceId * 3 + 1] = color.g;
                        originalColors[instanceId * 3 + 2] = color.b;

                        bookMap.push({ wall: w, shelf: s, vol: v, bookId, instanceId, worldPos: bookPos.clone() });
                        instanceId++;
                    }
                }
            }

            bookMesh.instanceMatrix.needsUpdate = true;
            bookMesh.instanceColor.needsUpdate = true;
            group.add(bookMesh);

            return { bookMesh, bookMap, originalColors };
        }

        

        // ============================================
        // SHELF SECTION TAGS (server-driven, per-room)
        // ============================================

        function prettifyTagLabel(label) {
            if (!label) return 'SECTION';
            const s = String(label);
            if (s.startsWith('RELATED:')) {
                const id = s.slice('RELATED:'.length);
                const f = (LAYOUT && LAYOUT.floorsById) ? LAYOUT.floorsById.get(id) : null;
                return `Related: ${f?.label || id}`;
            }
            return s;
        }

        function shortenLabel(s, maxLen = 24) {
            const str = String(s);
            if (str.length <= maxLen) return str;
            return str.slice(0, maxLen - 1) + 'â€¦';
        }

        function isRelatedTagLabel(label) {
            return String(label || '').startsWith('RELATED:');
        }

        function buildRenderableShelfTags(rawTags) {
            const EDGE_PAD_VOLS = 3;
            const MIN_GAP_VOLS = 5;
            const MAX_TAGS_PER_SHELF = 4;
            const byShelf = new Map();

            for (const tag of rawTags) {
                const w = Number(tag.wall);
                const s = Number(tag.shelf);
                const v = Number(tag.volStart);
                if (!Number.isInteger(w) || !Number.isInteger(s) || !Number.isInteger(v)) continue;
                if (w < 0 || w >= BOOKSHELF_WALLS.length) continue;
                if (s < 0 || s >= SHELF_HEIGHTS.length) continue;
                if (v < 0 || v >= BOOKS_PER_SHELF) continue;
                const key = `${w}:${s}`;
                if (!byShelf.has(key)) byShelf.set(key, []);
                byShelf.get(key).push(tag);
            }

            const out = [];
            for (const [key, shelfTags] of byShelf) {
                const [wStr, sStr] = key.split(':');
                const w = Number(wStr);
                const s = Number(sStr);
                shelfTags.sort((a, b) => a.volStart - b.volStart);

                const hasPrimaryTags = shelfTags.some(t => !isRelatedTagLabel(t.label || t.subId));
                const filtered = hasPrimaryTags
                    ? shelfTags.filter(t => !isRelatedTagLabel(t.label || t.subId))
                    : shelfTags;

                const kept = [];
                for (const tag of filtered) {
                    const rawLabel = (tag.label || tag.subId || 'SECTION');
                    const label = shortenLabel(prettifyTagLabel(rawLabel), 24);
                    const clampedVol = Math.max(EDGE_PAD_VOLS, Math.min(BOOKS_PER_SHELF - 1 - EDGE_PAD_VOLS, tag.volStart));

                    const prev = kept[kept.length - 1];
                    if (prev && prev.label === label) continue;
                    if (prev && Math.abs(clampedVol - prev.volStart) < MIN_GAP_VOLS) continue;

                    kept.push({ wall: w, shelf: s, volStart: clampedVol, label });
                    if (kept.length >= MAX_TAGS_PER_SHELF) break;
                }

                if (kept.length === 0 && filtered.length > 0) {
                    const fallback = filtered[0];
                    const rawLabel = (fallback.label || fallback.subId || 'SECTION');
                    kept.push({
                        wall: w,
                        shelf: s,
                        volStart: Math.max(EDGE_PAD_VOLS, Math.min(BOOKS_PER_SHELF - 1 - EDGE_PAD_VOLS, fallback.volStart)),
                        label: shortenLabel(prettifyTagLabel(rawLabel), 24),
                    });
                }

                out.push(...kept);
            }

            return out;
        }

        function attachShelfTagsToRoom(roomData, tagsJson) {
            if (!roomData || !roomData.group || !tagsJson || !Array.isArray(tagsJson.tags)) return;
            if (roomData.shelfTagsGroup) {
                roomData.group.remove(roomData.shelfTagsGroup);
            }
            const g = new THREE.Group();
            g.name = 'shelf-tags';

            const SHELF_DEPTH = 0.25;
            const SHELF_THICKNESS = 0.02;
            const TAG_INSET = 0.18;

            const tagsToRender = buildRenderableShelfTags(tagsJson.tags);
            for (const tag of tagsToRender) {
                const w = tag.wall;
                const s = tag.shelf;
                const v = tag.volStart;
                const label = tag.label || 'SECTION';

                if (w < 0 || w >= BOOKSHELF_WALLS.length) continue;
                if (s < 0 || s >= SHELF_HEIGHTS.length) continue;
                if (v < 0 || v >= BOOKS_PER_SHELF) continue;

                const wallIdx = BOOKSHELF_WALLS[w];
                const va = HEX_VERTICES[wallIdx];
                const vb = HEX_VERTICES[(wallIdx + 1) % 6];
                const wallCenter = new THREE.Vector3((va.x + vb.x) / 2, 0, (va.z + vb.z) / 2);
                const wallDir = new THREE.Vector3().subVectors(vb, va).normalize();
                const inwardDir = new THREE.Vector3(-wallCenter.x, 0, -wallCenter.z).normalize();
                const wallAngle = Math.atan2(-wallCenter.x, -wallCenter.z);

                const slot = v - BOOKS_PER_SHELF / 2;
                const slotWidth = (R - 0.2) / BOOKS_PER_SHELF;

                const shelfPos = wallCenter.clone().add(inwardDir.clone().multiplyScalar(SHELF_DEPTH / 2 + 0.02));
                shelfPos.y = SHELF_HEIGHTS[s];

                const tagPos = shelfPos.clone()
                    .add(wallDir.clone().multiplyScalar(slot * slotWidth))
                    .add(inwardDir.clone().multiplyScalar(TAG_INSET));
                tagPos.y = SHELF_HEIGHTS[s] + SHELF_THICKNESS + 0.04;

                // Backing plate
                const backGeom = new THREE.PlaneGeometry(0.40, 0.072);
                const backMat = new THREE.MeshStandardMaterial({
                    color: 0x120c07,
                    roughness: 0.95,
                    metalness: 0.05,
                    transparent: true,
                    opacity: 0.92,
                    depthWrite: false
                });
                const back = new THREE.Mesh(backGeom, backMat);
                back.position.copy(tagPos);
                back.position.y -= 0.002;
                back.rotation.y = wallAngle;
                back.renderOrder = 20;
                g.add(back);

                // Text plate
                const tex = createShelfLabel(label, { fontSize: 16, width: 200, height: 30 });
                const plateGeom = new THREE.PlaneGeometry(0.38, 0.064);
                const plateMat = new THREE.MeshBasicMaterial({
                    map: tex,
                    transparent: true,
                    alphaTest: 0.08,
                    depthWrite: false
                });
                const plate = new THREE.Mesh(plateGeom, plateMat);
                plate.position.copy(tagPos);
                plate.rotation.y = wallAngle;
                plate.renderOrder = 21;
                g.add(plate);

                // Subtle glow strip
                const glowGeom = new THREE.PlaneGeometry(0.40, 0.01);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: 0xc4943a,
                    transparent: true,
                    opacity: 0.18,
                    depthWrite: false
                });
                const glow = new THREE.Mesh(glowGeom, glowMat);
                glow.position.copy(tagPos);
                glow.position.y += 0.028;
                glow.rotation.y = wallAngle;
                glow.renderOrder = 22;
                g.add(glow);
            }

            roomData.shelfTagsGroup = g;
            roomData.group.add(g);
        }

        async function ensureRoomTagsApplied(roomIndex) {
            try {
                const tagsJson = await getRoomTags(roomIndex);
                const roomData = rooms.get(roomIndex);
                if (roomData) attachShelfTagsToRoom(roomData, tagsJson);
            } catch (e) {
                // ignore
            }
        }
// ============================================
        // ROOM MANAGEMENT
        // ============================================

        let currentRoomIndex = 0;
        // Initialize to first theme floor
        setTimeout(async () => {
            try {
                await loadFloorsLayout();
                await loadSlotsLayout();
                ensureElevatorButtons();
                setThemeFloor(0, 0);
                updateRooms();
                updateHUD();
            } catch (e) {
                console.warn('layout init failed', e);
                setThemeFloor(0, 0);
                updateRooms();
                updateHUD();
            }
        }, 0);
        const rooms = new Map();

        function disposeRoom(room) {
            scene.remove(room.group);
            room.group.traverse((obj) => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material && !sharedMaterials.has(obj.material)) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => { if (!sharedMaterials.has(mat)) mat.dispose(); });
                    } else {
                        obj.material.dispose();
                    }
                }
            });
        }

        function clearAllRooms() {
            for (const [idx, room] of rooms) {
                disposeRoom(room);
            }
            rooms.clear();
        }

        function teleportTo(roomIndex, callback, highlightBookId = null) {
            roomIndex = Math.max(0, Math.min(TOTAL_ROOMS - 1, roomIndex));
            const fade = document.getElementById('transition-fade');
            fade.classList.add('active');
            setTimeout(() => {
                currentRoomIndex = roomIndex;
                currentThemeIndex = themeIndexForRoom(currentRoomIndex);
                camera.position.set(0, 1.6, 0);
                clearAllRooms();
                updateRooms();
                updateHUD();
                
                // Start highlight if requested
                if (highlightBookId) {
                    highlightBook(highlightBookId);
                }
                
                setTimeout(() => {
                    fade.classList.remove('active');
                    if (callback) callback();
                }, 100);
            }, 300);
        }

        function updateRooms() {
            const { start, end } = themeRange(currentThemeIndex);

            const needed = new Set();
            for (let offset = -2; offset <= 2; offset++) {
                const idx = currentRoomIndex + offset;
                if (idx < start || idx > end) continue;
                needed.add(idx);
            }

            // Remove rooms outside the active window
            for (const [idx, room] of rooms) {
                if (!needed.has(idx)) {
                    disposeRoom(room);
                    rooms.delete(idx);
                }
            }

            // Realign remaining rooms to the new currentRoomIndex so the world stays continuous
            for (const [idx, room] of rooms) {
                room.group.position.z = (idx - currentRoomIndex) * ROOM_DEPTH;
            }

            // Add missing rooms
            for (const idx of needed) {
                if (!rooms.has(idx)) {
                    const offsetZ = (idx - currentRoomIndex) * ROOM_DEPTH;
                    const roomData = createFullRoom(idx, offsetZ);
                    scene.add(roomData.group);
                    rooms.set(idx, roomData);
                    ensureRoomTagsApplied(idx);
                }
            }
        }

        function checkRoomTransition() {
            const localZ = camera.position.z;
            const halfDepth = ROOM_DEPTH / 2;
            const { start, end } = themeRange(currentThemeIndex);

            if (localZ > halfDepth) {
                if (currentRoomIndex >= end) {
                    camera.position.z = halfDepth - 0.05;
                    showToast('End of floor â€” use the elevator');
                    return;
                }
                currentRoomIndex++;
                camera.position.z -= ROOM_DEPTH;
                updateRooms();
                updateHUD();
            } else if (localZ < -halfDepth) {
                if (currentRoomIndex <= start) {
                    camera.position.z = -halfDepth + 0.05;
                    showToast('Start of floor â€” use the elevator');
                    return;
                }
                currentRoomIndex--;
                camera.position.z += ROOM_DEPTH;
                updateRooms();
                updateHUD();
            }
        }

        // ============================================
        // POINTER LOCK CONTROLS
        // ============================================

        const controls = new PointerLockControls(camera, document.body);

        let readerOpen = false;
        let searchOpen = false;
        let navOpen = false;
        let aboutOpen = false;
        let libraryOpen = false;
        let elevatorOpen = false;
        let elevatorInRange = false;

        let introHidden = false;

        canvas.addEventListener('click', (e) => {
            if (!readerOpen && !searchOpen && !navOpen && !aboutOpen && !libraryOpen && introHidden) {
                controls.lock();
            }
        });

        controls.addEventListener('lock', () => {
            document.getElementById('crosshair').classList.add('visible');
            document.getElementById('instructions').classList.add('hidden');
            // Start ambient audio on interaction (requires user gesture)
            if (audioEnabled && !audioContext) {
                initAudio().then(() => setAmbientVolume(audioVolume));
            }
        });

        controls.addEventListener('unlock', () => {
            document.getElementById('crosshair').classList.remove('visible');
            if (introHidden && !readerOpen && !searchOpen && !navOpen && !aboutOpen && !libraryOpen) {
                document.getElementById('instructions').classList.remove('hidden');
            }
        });

        // ============================================
        // MOVEMENT
        // ============================================

        const moveSpeed = 3.0;
        const keys = { forward: false, backward: false, left: false, right: false };

        window.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': keys.forward = true; break;
                case 'KeyS': if (controls.isLocked) keys.backward = true; break;
                case 'KeyA': keys.left = true; break;
                case 'KeyD': keys.right = true; break;
                case 'KeyE': if (elevatorInRange) { openElevator(); } break;
            }
        });

        window.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': keys.forward = false; break;
                case 'KeyS': keys.backward = false; break;
                case 'KeyA': keys.left = false; break;
                case 'KeyD': keys.right = false; break;
            }
        });

        // Collision detection
        const passageEdgeZ = R * Math.sqrt(3) / 2;
        const corridorHalfW = 0.9;
        const corridorEnd = passageEdgeZ + CORRIDOR_LENGTH / 2;

        const CORRIDOR_WALLS = [
            [corridorHalfW, passageEdgeZ, corridorHalfW, corridorEnd],
            [-corridorHalfW, passageEdgeZ, -corridorHalfW, corridorEnd],
            [-corridorHalfW, -passageEdgeZ, -corridorHalfW, -corridorEnd],
            [corridorHalfW, -passageEdgeZ, corridorHalfW, -corridorEnd],
            [corridorHalfW, passageEdgeZ, R / 2, passageEdgeZ],
            [-corridorHalfW, passageEdgeZ, -R / 2, passageEdgeZ],
            [corridorHalfW, -passageEdgeZ, R / 2, -passageEdgeZ],
            [-corridorHalfW, -passageEdgeZ, -R / 2, -passageEdgeZ],
        ];

        function checkSegmentCollision(pos, ax, az, bx, bz, minDist) {
            const dx = bx - ax, dz = bz - az;
            const len = Math.sqrt(dx * dx + dz * dz);
            if (len < 0.001) return;
            const nx = dx / len, nz = dz / len;
            const toCamX = pos.x - ax, toCamZ = pos.z - az;
            const proj = Math.max(0, Math.min(len, toCamX * nx + toCamZ * nz));
            const closeX = ax + nx * proj, closeZ = az + nz * proj;
            const dist = Math.sqrt((pos.x - closeX) ** 2 + (pos.z - closeZ) ** 2);
            if (dist < minDist && dist > 0.001) {
                const px = (pos.x - closeX) / dist, pz = (pos.z - closeZ) / dist;
                pos.x = closeX + px * minDist;
                pos.z = closeZ + pz * minDist;
            }
        }

        function applyCollision() {
            const pos = camera.position;
            const minDist = 0.35;

            for (const wallIdx of BOOKSHELF_WALLS) {
                const va = HEX_VERTICES[wallIdx];
                const vb = HEX_VERTICES[(wallIdx + 1) % 6];
                checkSegmentCollision(pos, va.x, va.z, vb.x, vb.z, minDist);
            }

            for (const seg of CORRIDOR_WALLS) {
                checkSegmentCollision(pos, seg[0], seg[1], seg[2], seg[3], minDist);
            }
        }

        function updateElevatorHint() {
            const hint = document.getElementById('elevator-hint');
            if (!hint) return;
            const room = rooms.get(currentRoomIndex);
            elevatorInRange = false;
            if (room && room.elevatorLocal && controls.isLocked && !readerOpen && !searchOpen && !navOpen && !aboutOpen && !libraryOpen && !elevatorOpen) {
                const localPos = camera.position.clone().applyMatrix4(new THREE.Matrix4().copy(room.group.matrixWorld).invert());
                const dx = localPos.x - room.elevatorLocal.x;
                const dz = localPos.z - room.elevatorLocal.z;
                const d2 = dx*dx + dz*dz;
                if (d2 < 1.1 * 1.1) elevatorInRange = true;
            }
            hint.style.display = elevatorInRange ? 'block' : 'none';
        }


        // ============================================
        // RAYCASTING FOR BOOK SELECTION
        // ============================================

        const raycaster = new THREE.Raycaster();
        raycaster.far = 3;

        let hoveredBookId = null;

        document.addEventListener('click', async (event) => {
            if (!controls.isLocked) return;

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            for (const [idx, room] of rooms) {
                const intersects = raycaster.intersectObject(room.bookMesh);
                if (intersects.length > 0) {
                    const instanceId = intersects[0].instanceId;
                    const bookInfo = room.bookMap[instanceId];
                    if (!bookInfo || !Number.isInteger(bookInfo.bookId) || bookInfo.bookId < 1) return;
                    openBook(bookInfo.bookId);
                    controls.unlock();
                    return;
                }
            }
        });

        // ============================================
        // SPINE LABEL SYSTEM (screen-space overlay)
        // ============================================

        let currentSpineLabel = null;

        function updateSpineLabel(bookInfo, screenPos) {
            let label = document.querySelector('.spine-label');
            if (!label) {
                label = document.createElement('div');
                label.className = 'spine-label';
                label.innerHTML = '<div class="spine-title"></div><div class="spine-author"></div>';
                document.getElementById('spine-label-container').appendChild(label);
            }
            
            label.style.left = `${screenPos.x}px`;
            label.style.top = `${screenPos.y - 30}px`;
            label.classList.add('visible');
            
            currentSpineLabel = { label, bookId: bookInfo.bookId };
            
            // Update content
            const titleEl = label.querySelector('.spine-title');
            const authorEl = label.querySelector('.spine-author');
            
            if (bookCache.has(bookInfo.bookId)) {
                const meta = bookCache.get(bookInfo.bookId);
                titleEl.textContent = meta.title.substring(0, 30) + (meta.title.length > 30 ? '...' : '');
                authorEl.textContent = meta.authors.substring(0, 25) + (meta.authors.length > 25 ? '...' : '');
            } else {
                titleEl.textContent = `Book #${bookInfo.bookId}`;
                authorEl.textContent = 'Loading...';
            }
        }

        function hideSpineLabel() {
            const label = document.querySelector('.spine-label');
            if (label) {
                label.classList.remove('visible');
            }
            currentSpineLabel = null;
        }

        // ============================================
        // BOOK READER UI
        // ============================================

        let currentBookId = null;
        let currentBookText = '';
        let currentBookPages = [];
        let currentPageIndex = 0;
        let detectedChapters = [];
        let currentFont = settings.font || 'serif';
        let currentFontSize = settings.fontSize || 'medium';
        let singlePageMode = settings.singlePageMode || false;
        let readerDarkMode = !!settings.readerDarkMode;
        let pageTurnAnimationToken = 0;
        const PAGE_TURN_OUT_MS = 280;
        const PAGE_TURN_IN_MS = 360;
        const PAGE_NUM_RESERVE_PX = 24;
        const PAGE_MEASURE_MIN_WIDTH_PX = 300;
        const PAGE_MEASURE_MIN_HEIGHT_PX = 420;
        const textCache = new Map();

        // In-book search state
        let readerSearchQuery = '';
        let readerSearchMatches = [];
        let readerSearchCurrentIndex = -1;

        let pageCharStarts = [];
        let fontRepaginateTimer = null;

        function applyReaderTheme() {
            const reader = document.getElementById('reader');
            const btn = document.getElementById('reader-theme-btn');
            if (!reader || !btn) return;
            reader.classList.toggle('reader-dark', readerDarkMode);
            btn.classList.toggle('active', readerDarkMode);
            btn.textContent = readerDarkMode ? 'â˜€ï¸Ž' : 'â˜¾';
            btn.title = readerDarkMode ? 'Switch to light pages' : 'Switch to dark pages';
        }

        function clearPageTurnClasses() {
            const leftPage = document.getElementById('book-page-left');
            const rightPage = document.getElementById('book-page-right');
            for (const page of [leftPage, rightPage]) {
                if (!page) continue;
                page.classList.remove('turning-out', 'turning-in', 'turn-next', 'turn-prev', 'settling');
            }
        }

        function readerFontFamilyForSetting(font) {
            if (font === 'mono') return '"IBM Plex Mono"';
            if (font === 'baskerville') return '"Libre Baskerville"';
            return '"Cormorant Garamond"';
        }

        function readerFontPxForSetting(size) {
            if (size === 'small') return 13;
            if (size === 'large') return 17;
            if (size === 'xlarge') return 19;
            return 15; // medium
        }

        async function waitForReaderTypographyReady(font = currentFont, size = currentFontSize, timeoutMs = 1800) {
            if (!document.fonts || typeof document.fonts.load !== 'function') return;
            const family = readerFontFamilyForSetting(font);
            const px = readerFontPxForSetting(size);
            const descriptor = `${px}px ${family}`;
            const timeout = new Promise(resolve => setTimeout(resolve, timeoutMs));
            try {
                await Promise.race([
                    Promise.all([
                        document.fonts.load(descriptor),
                        document.fonts.ready
                    ]),
                    timeout
                ]);
            } catch (_) {
                // Ignore font loading failures and continue with fallback fonts.
            }
        }

        function normalizeBookText(text) {
            const t = (text || '')
                .replace(/\r\n/g, '\n')
                .replace(/\t/g, '    ')
                // collapse huge gaps but keep paragraph breaks
                .replace(/\n{4,}/g, '\n\n\n')
                .trim();

            // Gutenberg texts are often hard-wrapped at ~70 cols.
            // Convert single newlines inside a paragraph to spaces; keep blank lines as paragraph breaks.
            const paras = t.split(/\n\s*\n/);
            const cleaned = paras
                .map(p => p.replace(/\n+/g, ' ').replace(/\s{2,}/g, ' ').trim())
                .filter(Boolean);
            return cleaned.join('\n\n');
        }

        function escapeHtmlLite(str) {
            return (str || '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }

        function pageHtmlFromText(pageText) {
            // Convert into paragraphs for nicer book feel
            const safe = escapeHtmlLite(pageText);
            const paras = safe.split(/\n\s*\n/).map(p => p.trim()).filter(Boolean);
            if (!paras.length) return '<p></p>';
            return paras.map(p => `<p>${p.replace(/\n/g, '<br>')}</p>`).join('');
        }

        function setupMeasureBox() {
            const measure = document.getElementById('paginator-measure');
            const leftPage = document.getElementById('book-page-left');
            const leftContent = document.getElementById('book-content-left');
            const bookSpread = document.getElementById('book-spread');
            if (!measure || !leftPage || !leftContent) return null;

            // Match the *inner* printable area of the page (page size minus padding)
            const pageRect = leftPage.getBoundingClientRect();
            const pageStyle = getComputedStyle(leftPage);
            const padX = (parseFloat(pageStyle.paddingLeft) || 0) + (parseFloat(pageStyle.paddingRight) || 0);
            const padY = (parseFloat(pageStyle.paddingTop) || 0) + (parseFloat(pageStyle.paddingBottom) || 0);

            let w = pageRect.width - padX;
            let h = pageRect.height - padY - PAGE_NUM_RESERVE_PX;

            // If layout hasn't fully settled yet, derive a sane fallback from the spread box.
            if ((w < PAGE_MEASURE_MIN_WIDTH_PX || h < PAGE_MEASURE_MIN_HEIGHT_PX) && bookSpread) {
                const spreadRect = bookSpread.getBoundingClientRect();
                if (spreadRect.width > 0 && spreadRect.height > 0) {
                    w = Math.max(w, ((spreadRect.width - 12) / 2) - padX);
                    h = Math.max(h, spreadRect.height - padY - PAGE_NUM_RESERVE_PX);
                }
            }

            w = Math.max(PAGE_MEASURE_MIN_WIDTH_PX, w);
            h = Math.max(PAGE_MEASURE_MIN_HEIGHT_PX, h);
            measure.style.width = w + 'px';
            measure.style.height = h + 'px';

            // Mirror typography classes
            measure.className = leftContent.className; // includes book-page-content + font/size
            measure.style.overflow = 'hidden';
            measure.style.whiteSpace = 'normal';
            measure.style.lineHeight = getComputedStyle(leftContent).lineHeight;
            measure.style.fontFamily = getComputedStyle(leftContent).fontFamily;
            measure.style.fontSize = getComputedStyle(leftContent).fontSize;
            measure.style.padding = '0';
            measure.style.margin = '0';
            return measure;
        }

        function findPageBreak(text, start, end, measure) {
            // Find a break <= end that fits; prefer breaking at whitespace/newline
            let lo = start + 200; // don't allow tiny pages
            let hi = Math.min(end, text.length);
            let best = lo;

            const fits = (cut) => {
                const slice = text.slice(start, cut);
                measure.innerHTML = pageHtmlFromText(slice);
                return measure.scrollHeight <= measure.clientHeight;
            };

            // Ensure lo fits; if not, force minimal cut
            if (!fits(lo)) {
                return lo;
            }

            while (lo <= hi) {
                const mid = Math.floor((lo + hi) / 2);
                // adjust mid to a whitespace boundary for nicer breaks
                let cut = mid;
                for (let i = 0; i < 80 && cut > start; i++) {
                    const ch = text.charAt(cut);
                    if (ch === ' ' || ch === '\n') break;
                    cut--;
                }
                if (cut <= start + 50) cut = mid;

                if (fits(cut)) {
                    best = cut;
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }

            // Final guard: don't split a word (e.g. "indic" + "ated")
            let safe = best;
            // If we're in the middle of a word, walk back to whitespace/newline
            if (safe > start && text.charAt(safe - 1) !== ' ' && text.charAt(safe - 1) !== '\n') {
                let back = safe;
                for (let i = 0; i < 120 && back > start + 200; i++) {
                    const ch = text.charAt(back - 1);
                    if (ch === ' ' || ch === '\n') break;
                    back--;
                }
                if (back > start + 200) safe = back;
            }

            // Trim trailing whitespace/newlines
            while (safe > start && (text.charAt(safe - 1) === ' ' || text.charAt(safe - 1) === '\n')) safe--;
            return Math.max(safe, start + 1);
        }

        function paginateText(text) {
            const clean = normalizeBookText(text);
            const measure = setupMeasureBox();
            if (!measure) {
                // fallback (shouldn't happen)
                pageCharStarts = [0];
                return clean ? [clean] : [''];
            }

            const pages = [];
            pageCharStarts = [];
            let pos = 0;
            const maxChunk = 12000; // safety window for binary search

            while (pos < clean.length) {
                pageCharStarts.push(pos);
                const end = Math.min(clean.length, pos + maxChunk);
                const cut = findPageBreak(clean, pos, end, measure);
                pages.push(clean.slice(pos, cut));
                pos = cut;
                // skip leading whitespace/newlines on next page
                while (pos < clean.length && (clean.charAt(pos) === ' ' || clean.charAt(pos) === '\n')) pos++;
            }

            return pages.length ? pages : [''];
        }

        function pageIndexFromCharIndex(charIndex) {
            // pageCharStarts is sorted
            let lo = 0, hi = pageCharStarts.length - 1;
            while (lo <= hi) {
                const mid = (lo + hi) >> 1;
                if (pageCharStarts[mid] <= charIndex) lo = mid + 1;
                else hi = mid - 1;
            }
            return Math.max(0, lo - 1);
        }

        function detectChapters(text) {
            const chapters = [];
            const clean = normalizeBookText(text);
            const lines = clean.split('\n');
            const chapterPatterns = [
                /^(CHAPTER|Chapter|PART|Part|BOOK|Book)\s+([IVXLC\d]+)/,
                /^(CHAPTER|Chapter|PART|Part|BOOK|Book)\s+\d+/,
                /^([IVXLC]+)\.\s/,
                /^\d+\.\s+[A-Z]/,
            ];

            let charPos = 0;
            for (let i = 0; i < lines.length; i++) {
                const rawLine = lines[i];
                const line = rawLine.trim();
                for (const pattern of chapterPatterns) {
                    if (pattern.test(line)) {
                        const pageIndex = pageIndexFromCharIndex(charPos);
                        chapters.push({
                            title: line.substring(0, 50),
                            page: pageIndex,
                            char: charPos
                        });
                        break;
                    }
                }
                charPos += rawLine.length + 1; // +\n
            }

            return chapters;
        }

        function updateChapterList() {
            const listEl = document.getElementById('chapter-list');
            if (detectedChapters.length === 0) {
                listEl.innerHTML = '<div class="empty-state">No chapters detected</div>';
                return;
            }
            
            listEl.innerHTML = detectedChapters.map((ch, i) => `
                <div class="chapter-item ${ch.page === currentPageIndex ? 'active' : ''}" 
                     onclick="jumpToChapter(${i})">
                    ${escapeHtml(ch.title)}
                </div>
            `).join('');
        }

        window.jumpToChapter = function(index) {
            if (index >= 0 && index < detectedChapters.length) {
                currentPageIndex = detectedChapters[index].page;
                renderPage();
                updateChapterList();
            }
        };

        window.toggleChapterSidebar = function() {
            const sidebar = document.getElementById('chapter-sidebar');
            sidebar.classList.toggle('visible');
            document.getElementById('toc-btn').classList.toggle('active', sidebar.classList.contains('visible'));
        };

        function applyBookTypography() {
            const contents = document.querySelectorAll('.book-page-content');
            contents.forEach(el => {
                el.classList.remove('font-serif', 'font-baskerville', 'font-mono', 'font-size-small', 'font-size-medium', 'font-size-large', 'font-size-xlarge');
                el.classList.add(`font-${currentFont}`);
                el.classList.add(`font-size-${currentFontSize}`);
            });
        }

        function formatBookPageHtml(pageText) {
            let txt = pageText || '';
            if (readerSearchQuery && readerSearchMatches.length > 0) {
                // highlightSearchInText expects plain text and returns HTML, but we want paragraphs.
                // We'll apply highlights on the raw page text and then wrap into paragraphs.
                const highlighted = highlightSearchInText(txt, readerSearchQuery);
                // highlighted is already HTML-escaped; just paragraphize by splitting on blank lines in original text
                const paras = escapeHtmlLite(txt).split(/\n\s*\n/).map(p => p.trim()).filter(Boolean);
                if (!paras.length) return '<p></p>';
                // For highlighting, fall back to highlighted with <br> if paragraph mapping is complex.
                // Keep it simple: use highlighted + <br> in search mode.
                return highlighted.replace(/\n/g, '<br>');
            }
            return pageHtmlFromText(txt);
        }

        function repaginateCurrentBook() {
            if (!readerOpen || !currentBookText) return;

            // Preserve approximate reading position using character index
            const currentChar = pageCharStarts[currentPageIndex] ?? 0;
            const cleanText = normalizeBookText(currentBookText);
            currentBookPages = paginateText(cleanText);
            detectedChapters = detectChapters(cleanText);
            updateChapterList();
            currentPageIndex = pageIndexFromCharIndex(currentChar);
            renderPage(false);
        }

        let repaginateTimer = null;
        window.addEventListener('resize', () => {
            if (!readerOpen || !currentBookText) return;
            clearTimeout(repaginateTimer);
            repaginateTimer = setTimeout(() => {
                repaginateCurrentBook();
            }, 180);
        });

        if (document.fonts && typeof document.fonts.addEventListener === 'function') {
            const reflowAfterFontLoad = () => {
                if (!readerOpen || !currentBookText) return;
                clearTimeout(fontRepaginateTimer);
                fontRepaginateTimer = setTimeout(() => {
                    repaginateCurrentBook();
                }, 60);
            };
            document.fonts.addEventListener('loadingdone', reflowAfterFontLoad);
            document.fonts.addEventListener('loadingerror', reflowAfterFontLoad);
        }

        function renderPage(animate = false, direction = 1) {
            const leftContent = document.getElementById('book-content-left');
            const rightContent = document.getElementById('book-content-right');
            const leftPage = document.getElementById('book-page-left');
            const rightPage = document.getElementById('book-page-right');
            const leftNum = document.getElementById('book-num-left');
            const rightNum = document.getElementById('book-num-right');
            const pageNumEl = document.getElementById('reader-page-num');
            const prevBtn = document.getElementById('prev-page-btn');
            const nextBtn = document.getElementById('next-page-btn');
            const pageJumpInput = document.getElementById('page-jump-input');
            const bookSpine = document.querySelector('.book-spine');

            const total = currentBookPages.length || 1;

            // In book mode, always work with spreads (even indices)
            let idx = Math.max(0, Math.min(currentPageIndex, total - 1));
            if (!singlePageMode) {
                idx = Math.floor(idx / 2) * 2;
            }
            currentPageIndex = idx;

            const applyRenderedContent = () => {
                applyBookTypography();

                // Toggle modal width class based on mode
                const readerPanel = document.querySelector('#reader .reader-page');
                if (readerPanel) readerPanel.classList.toggle('single-page', singlePageMode);

                if (singlePageMode) {
                    // Single page mode
                    rightPage.style.display = 'none';
                    bookSpine.style.display = 'none';
                    leftContent.innerHTML = formatBookPageHtml(currentBookPages[idx] || '');
                    leftNum.textContent = idx + 1;
                    pageNumEl.textContent = `Page ${idx + 1} of ${total}`;
                    prevBtn.disabled = idx === 0;
                    nextBtn.disabled = idx >= total - 1;
                } else {
                    // Two-page spread mode (default)
                    rightPage.style.display = '';
                    bookSpine.style.display = '';

                    leftContent.innerHTML = formatBookPageHtml(currentBookPages[idx] || '');
                    leftNum.textContent = idx + 1;

                    if (idx + 1 < total) {
                        rightContent.innerHTML = formatBookPageHtml(currentBookPages[idx + 1] || '');
                        rightNum.textContent = idx + 2;
                    } else {
                        rightContent.innerHTML = '';
                        rightNum.textContent = '';
                    }

                    pageNumEl.textContent = `Pages ${idx + 1}â€“${Math.min(idx + 2, total)} of ${total}`;
                    prevBtn.disabled = idx === 0;
                    nextBtn.disabled = idx + 2 >= total;
                }

                // Update page jump input
                pageJumpInput.value = idx + 1;
                pageJumpInput.max = total;

                // Save reading progress
                if (currentBookId) {
                    saveReadingProgress(currentBookId, idx, total);
                }

                // Update chapter highlight
                updateChapterList();
            };

            pageTurnAnimationToken++;
            clearPageTurnClasses();

            if (!animate) {
                applyRenderedContent();
                return;
            }

            const token = pageTurnAnimationToken;
            const forward = direction >= 0;
            const turningPage = singlePageMode ? leftPage : (forward ? rightPage : leftPage);
            const settlingPage = singlePageMode ? null : (forward ? leftPage : rightPage);
            const dirClass = forward ? 'turn-next' : 'turn-prev';

            if (turningPage) turningPage.classList.add('turning-out', dirClass);
            if (settlingPage) settlingPage.classList.add('settling');

            setTimeout(() => {
                if (token !== pageTurnAnimationToken) return;

                applyRenderedContent();
                if (turningPage) {
                    turningPage.classList.remove('turning-out');
                    turningPage.classList.add('turning-in');
                }

                setTimeout(() => {
                    if (token !== pageTurnAnimationToken) return;
                    clearPageTurnClasses();
                }, PAGE_TURN_IN_MS);
            }, PAGE_TURN_OUT_MS);
        }

        function highlightSearchInText(text, query) {
            if (!query) return escapeHtml(text);
            const escaped = escapeHtml(text);
            const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
            return escaped.replace(regex, '<span class="search-highlight">$1</span>');
        }

        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        window.jumpToPage = function() {
            const input = document.getElementById('page-jump-input');
            const page = parseInt(input.value) - 1;
            if (page >= 0 && page < currentBookPages.length) {
                const direction = page >= currentPageIndex ? 1 : -1;
                currentPageIndex = page;
                renderPage(true, direction);
                playPageTurn();
            }
        };

        window.toggleTwoPage = function() {
            singlePageMode = !singlePageMode;
            settings.singlePageMode = singlePageMode;
            saveToStorage(STORAGE_KEYS.SETTINGS, settings);
            
            const btn = document.getElementById('two-page-btn');
            btn.classList.toggle('active', singlePageMode);
            btn.title = singlePageMode ? 'Two-page view' : 'Single page view';
            
            // Re-render with new mode
            renderPage();
        };

        window.toggleReaderTheme = function() {
            readerDarkMode = !readerDarkMode;
            settings.readerDarkMode = readerDarkMode;
            saveToStorage(STORAGE_KEYS.SETTINGS, settings);
            applyReaderTheme();
        };

        // Typography controls
        window.toggleTypographyDropdown = function() {
            const dropdown = document.getElementById('typography-dropdown');
            dropdown.classList.toggle('visible');
        };

        window.changeFont = async function(font) {
            currentFont = font;
            settings.font = font;
            saveToStorage(STORAGE_KEYS.SETTINGS, settings);
            applyBookTypography();
            await waitForReaderTypographyReady(currentFont, currentFontSize, 1400);
            repaginateCurrentBook();
        };

        window.changeFontSize = function(size) {
            currentFontSize = size;
            settings.fontSize = size;
            saveToStorage(STORAGE_KEYS.SETTINGS, settings);
            applyBookTypography();
            repaginateCurrentBook();
        };

        // In-book search
        window.openReaderSearch = function() {
            const searchBar = document.getElementById('reader-search-bar');
            searchBar.classList.add('visible');
            document.getElementById('reader-search-input').focus();
        };

        window.closeReaderSearch = function() {
            const searchBar = document.getElementById('reader-search-bar');
            searchBar.classList.remove('visible');
            readerSearchQuery = '';
            readerSearchMatches = [];
            readerSearchCurrentIndex = -1;
            document.getElementById('reader-search-info').textContent = '';
            renderPage(); // Remove highlights
        };

        window.readerSearchPrev = function() {
            if (readerSearchMatches.length === 0) return;
            readerSearchCurrentIndex = (readerSearchCurrentIndex - 1 + readerSearchMatches.length) % readerSearchMatches.length;
            goToSearchMatch();
        };

        window.readerSearchNext = function() {
            if (readerSearchMatches.length === 0) return;
            readerSearchCurrentIndex = (readerSearchCurrentIndex + 1) % readerSearchMatches.length;
            goToSearchMatch();
        };

        function goToSearchMatch() {
            if (readerSearchCurrentIndex < 0 || readerSearchCurrentIndex >= readerSearchMatches.length) return;
            const match = readerSearchMatches[readerSearchCurrentIndex];
            currentPageIndex = match.page;
            renderPage();
            document.getElementById('reader-search-info').textContent = 
                `${readerSearchCurrentIndex + 1} of ${readerSearchMatches.length}`;
        }

        document.getElementById('reader-search-input').addEventListener('input', (e) => {
            readerSearchQuery = e.target.value.trim();
            if (readerSearchQuery.length < 2) {
                readerSearchMatches = [];
                readerSearchCurrentIndex = -1;
                document.getElementById('reader-search-info').textContent = '';
                renderPage();
                return;
            }
            
            // Find all matches across pages
            readerSearchMatches = [];
            const regex = new RegExp(escapeRegex(readerSearchQuery), 'gi');
            for (let i = 0; i < currentBookPages.length; i++) {
                const matches = currentBookPages[i].match(regex);
                if (matches) {
                    for (const m of matches) {
                        readerSearchMatches.push({ page: i, text: m });
                    }
                }
            }
            
            readerSearchCurrentIndex = readerSearchMatches.length > 0 ? 0 : -1;
            document.getElementById('reader-search-info').textContent = 
                readerSearchMatches.length > 0 ? `1 of ${readerSearchMatches.length}` : 'No matches';
            
            if (readerSearchCurrentIndex >= 0) {
                goToSearchMatch();
            } else {
                renderPage();
            }
        });

        document.getElementById('reader-search-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (e.shiftKey) {
                    readerSearchPrev();
                } else {
                    readerSearchNext();
                }
            } else if (e.key === 'Escape') {
                closeReaderSearch();
            }
        });

        window.nextPage = function() {
            if (!readerOpen) return;
            const step = singlePageMode ? 1 : 2;
            if (currentPageIndex < (currentBookPages.length - step)) {
                currentPageIndex += step;
                renderPage(true, 1);
                playPageTurn();
            }
        };

        window.prevPage = function() {
            if (!readerOpen) return;
            const step = singlePageMode ? 1 : 2;
            if (currentPageIndex >= step) {
                currentPageIndex -= step;
                renderPage(true, -1);
                playPageTurn();
            }
        };

        window.openBook = async function(bookId, resumePage = null) {
            try {
                currentBookId = bookId;
                readerOpen = true;

                const legacyLoc = bookIdToLocation_legacy(bookId);
                const slotsLoc = bookIdToLocationCanonical(bookId);
                let apiLoc = null;
                try {
                    apiLoc = await getBookPrimaryLocation(bookId);
                } catch (e) {
                    // ignore
                }
                const location = apiLoc || slotsLoc || legacyLoc;

                document.getElementById('reader-title').textContent = 'Loading...';
                document.getElementById('reader-author').textContent = '';
                document.getElementById('reader-coords').textContent = `Room ${location.room + 1} Â· Wall ${location.wall + 1} (${WALL_NAMES[location.wall]}) Â· Shelf ${location.shelf + 1} Â· Volume ${location.volume + 1}`;
            
            // Reset book pages to loading state
            document.getElementById('book-content-left').innerHTML = '<div style="text-align:center;color:#8b7355;font-style:italic;padding-top:60px;">Loading book text...</div>';
            document.getElementById('book-content-right').innerHTML = '';
            document.getElementById('book-num-left').textContent = '';
            document.getElementById('book-num-right').textContent = '';

            document.getElementById('reader-content').textContent = 'Loading book text...';
            document.getElementById('reader-content').classList.add('loading');
            document.getElementById('reader-gutenberg-link').href = `https://www.gutenberg.org/ebooks/${bookId}`;
            document.getElementById('reader').classList.add('visible');
            applyReaderTheme();
            
            // Reset search
            readerSearchQuery = '';
            readerSearchMatches = [];
            readerSearchCurrentIndex = -1;
            document.getElementById('reader-search-bar').classList.remove('visible');
            
            // Reset chapter sidebar
            document.getElementById('chapter-sidebar').classList.remove('visible');
            document.getElementById('toc-btn').classList.remove('active');
            
            // Update bookmark button state
            document.getElementById('bookmark-btn').classList.toggle('bookmarked', isBookmarked(bookId));
            
            // Update single-page toggle button state
            document.getElementById('two-page-btn').classList.toggle('active', singlePageMode);
            
            // Apply saved typography settings
            document.getElementById('font-select').value = currentFont;
            document.getElementById('font-size-select').value = currentFontSize;
            changeFont(currentFont);
            changeFontSize(currentFontSize);

            // Fetch metadata
            const meta = await fetchBookMetadata(bookId);
            if (meta) {
                document.getElementById('reader-title').textContent = meta.title;
                document.getElementById('reader-author').textContent = meta.authors;
                // Add to recents
                addToRecents(bookId, meta.title, meta.authors);
            } else {
                document.getElementById('reader-title').textContent = `Book #${bookId}`;
                document.getElementById('reader-author').textContent = '';
                addToRecents(bookId, `Book #${bookId}`, '');
            }

            // Fetch text (with cache)
            let text = textCache.get(bookId);
            if (!text) {
                text = await fetchBookText(bookId);
                if (text) textCache.set(bookId, text);
            }

            if (text) {
                currentBookText = text;
                const cleanText = text.replace(/\r\n/g, '\n').replace(/\n{4,}/g, '\n\n\n');
                // Wait for reader layout to settle so paginator measures the real page size.
                await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));
                await waitForReaderTypographyReady(currentFont, currentFontSize, 2200);
                currentBookPages = paginateText(cleanText);
                detectedChapters = detectChapters(cleanText);
                updateChapterList();
                
                // Resume from saved progress or specified page
                if (resumePage !== null) {
                    currentPageIndex = resumePage;
                } else {
                    const progress = getReadingProgress(bookId);
                    currentPageIndex = progress ? progress.page : 0;
                }

                renderPage();
            } else {
                currentBookText = '';
                currentBookPages = ['Unable to load book text. The book may not be available in plain text format.'];
                detectedChapters = [];
                currentPageIndex = 0;
                renderPage();
            }
            } catch (err) {
                console.error('openBook failed', err);
                showToast('Reader error â€” please try again.');
            }
        };

        window.closeBook = function() {
            document.getElementById('reader').classList.remove('visible');
            document.getElementById('chapter-sidebar').classList.remove('visible');
            document.getElementById('typography-dropdown').classList.remove('visible');
            pageTurnAnimationToken++;
            clearPageTurnClasses();
            readerOpen = false;
            currentBookId = null;
            currentBookText = '';
            currentBookPages = [];
            currentPageIndex = 0;
            detectedChapters = [];
        };

        // Close typography dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('typography-dropdown');
            const btn = document.getElementById('typography-btn');
            if (!dropdown.contains(e.target) && e.target !== btn) {
                dropdown.classList.remove('visible');
            }
        });

        // ============================================
        // SEARCH UI
        // ============================================

        function closeAllPanels(except) {
            const keep = except || '';
            if (keep !== 'search' && searchOpen) closeSearch();
            if (keep !== 'nav' && navOpen) closeNav();
            if (keep !== 'elevator' && elevatorOpen) closeElevator();
            if (keep !== 'library' && libraryOpen) closeLibrary();
            if (keep !== 'about' && aboutOpen) closeAbout();
        }

        let searchResults = [];
        let selectedSearchIndex = -1;

        window.openSearch = function() {
            closeAllPanels('search');
            document.getElementById('search-panel').classList.add('visible');
            searchOpen = true;
            controls.unlock();
            setTimeout(() => {
                document.getElementById('search-input').focus();
            }, 300);
        };

        window.closeSearch = function() {
            document.getElementById('search-panel').classList.remove('visible');
            searchOpen = false;
            searchResults = [];
            selectedSearchIndex = -1;
        };

        window.performSearch = async function() {
            const query = document.getElementById('search-input').value.trim();
            if (!query) return;

            const language = document.getElementById('search-language').value;
            const topic = document.getElementById('search-topic').value;

            const resultsDiv = document.getElementById('search-results');
            resultsDiv.innerHTML = '<div class="loading-spinner"></div> Searching...';

            const results = await searchBooks(query, language, topic);
            searchResults = results.slice(0, 15);
            selectedSearchIndex = -1;

            if (searchResults.length === 0) {
                resultsDiv.innerHTML = '<p style="color:#8b7355;">No books found. Try different keywords or filters.</p>';
                document.getElementById('search-keyboard-hint').style.display = 'none';
                return;
            }

            renderSearchResults();
            document.getElementById('search-keyboard-hint').style.display = 'block';
        };

        function renderSearchResults() {
            const resultsDiv = document.getElementById('search-results');
            resultsDiv.innerHTML = searchResults.map((book, i) => {
                const location = bookIdToLocation(book.id);
                const authors = book.authors?.map(a => a.name).join(', ') || 'Unknown Author';
                const languages = book.languages?.join(', ') || '';
                const subjects = book.subjects?.slice(0, 2).join('; ') || '';
                const progress = getReadingProgress(book.id);
                const progressText = progress ? `Progress: Page ${progress.page + 1} of ${progress.total}` : '';
                return `
                    <div class="search-result-item ${i === selectedSearchIndex ? 'selected' : ''}" 
                         data-index="${i}"
                         onclick="goToBook(${book.id})">
                        <div class="search-result-title">${escapeHtml(book.title)}</div>
                        <div class="search-result-author">${escapeHtml(authors)}</div>
                        ${languages || subjects ? `<div class="search-result-meta">${languages ? `ðŸ“– ${languages}` : ''} ${subjects ? `Â· ${subjects}` : ''}</div>` : ''}
                        <div class="search-result-location">Room ${location.room + 1} Â· Wall ${location.wall + 1} Â· Shelf ${location.shelf + 1}</div>
                        ${progressText ? `<div class="search-result-progress">${progressText}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        window.jumpToGutenbergId = async function() {
            const bookId = parseInt(document.getElementById('search-gutenberg-id').value);
            if (!bookId || bookId < 1 || bookId > TOTAL_BOOKS) {
                showToast('Please enter a valid Gutenberg ID (1-70000)');
                return;
            }
            closeSearch();
            try {
                const loc = await getBookPrimaryLocation(bookId);
                teleportTo(loc.room, () => { openBook(bookId); }, bookId);
            } catch (e) {
                console.error(e);
                showToast('Failed to locate book');
            }
        };

        window.goToBook = async function(bookId) {
            closeSearch();
            try {
                const loc = await getBookPrimaryLocation(bookId);
                teleportTo(loc.room, () => { openBook(bookId); }, bookId);
            } catch (e) {
                console.error(e);
                showToast('Failed to locate book');
            }
        };

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============================================
        // NAVIGATION UI
        // ============================================

        let navCatalog = {
            floors: [],
            sectionsByFloorId: new Map(),
            byFloorId: new Map(),
        };

        function currentFloorForRoom(room) {
            const floors = (LAYOUT && Array.isArray(LAYOUT.floors)) ? LAYOUT.floors : [];
            for (const floor of floors) {
                if (room >= floor.roomStart && room < (floor.roomStart + floor.roomCount)) return floor;
            }
            return floors[0] || null;
        }

        function syncRoomInputBoundsForFloor(floor) {
            const roomInput = document.getElementById('nav-room');
            if (!roomInput) return;
            roomInput.min = '1';
            roomInput.max = String(TOTAL_ROOMS);

            if (!floor) return;
            const floorMin = floor.roomStart + 1;
            const floorMax = floor.roomStart + floor.roomCount;
            const current = parseInt(roomInput.value || '1', 10);
            if (!Number.isInteger(current) || current < floorMin || current > floorMax) {
                roomInput.value = String(floorMin);
            }
        }

        function updateNavFloorMeta(floor, section) {
            const meta = document.getElementById('nav-floor-meta');
            if (!meta) return;
            if (!floor) {
                meta.textContent = 'Floor catalog unavailable.';
                return;
            }
            const start = floor.roomStart + 1;
            const end = floor.roomStart + floor.roomCount;
            const sectionText = section ? ` Â· Section: ${section.label}` : '';
            meta.textContent = `Rooms ${start}-${end}${sectionText}`;
        }

        function populateNavSectionOptions(floorId, selectedSectionId) {
            const sectionSelect = document.getElementById('nav-section');
            if (!sectionSelect) return;

            const sections = navCatalog.sectionsByFloorId.get(floorId) || [];
            sectionSelect.innerHTML = '';

            const allOption = document.createElement('option');
            allOption.value = '';
            allOption.textContent = 'All sections (floor start)';
            sectionSelect.appendChild(allOption);

            for (const section of sections) {
                const opt = document.createElement('option');
                opt.value = section.id;
                const countText = Number.isInteger(section.count) ? ` (${section.count.toLocaleString()})` : '';
                opt.textContent = `${section.label}${countText}`;
                sectionSelect.appendChild(opt);
            }

            if (selectedSectionId && sections.some(s => s.id === selectedSectionId)) {
                sectionSelect.value = selectedSectionId;
            } else {
                sectionSelect.value = '';
            }
            const active = sections.find(s => s.id === sectionSelect.value) || null;
            updateNavFloorMeta(navCatalog.byFloorId.get(floorId), active);
        }

        function buildSectionsForFloor(floor, floorSlots) {
            const sections = [];
            const byId = new Map();
            const bookIdBySlot = Array.isArray(floorSlots?.bookIdBySlot) ? floorSlots.bookIdBySlot : [];
            const subIdBySlot = Array.isArray(floorSlots?.subIdBySlot) ? floorSlots.subIdBySlot : [];

            const counts = new Map();
            const firstLocBySub = new Map();
            const limit = Math.min(bookIdBySlot.length, subIdBySlot.length);
            for (let i = 0; i < limit; i++) {
                const subId = subIdBySlot[i];
                if (!subId) continue;
                const bookId = bookIdBySlot[i];
                const validBook = Number.isInteger(bookId) && bookId >= 1 && bookId <= TOTAL_BOOKS;
                if (!validBook) continue;

                counts.set(subId, (counts.get(subId) || 0) + 1);
                if (!firstLocBySub.has(subId)) {
                    const roomOff = Math.floor(i / BOOKS_PER_ROOM);
                    const inRoom = i % BOOKS_PER_ROOM;
                    const room = floor.roomStart + roomOff;
                    const { wall, shelf, volume } = slotOffsetToWallShelfVolume(inRoom);
                    firstLocBySub.set(subId, { room, wall, shelf, volume, bookId });
                }
            }

            const orderedSubs = Array.isArray(floor?.subcategories) ? floor.subcategories : [];
            for (const sub of orderedSubs) {
                const id = sub?.id;
                if (!id) continue;
                const entry = {
                    id,
                    label: sub.label || id,
                    count: Number.isInteger(sub.count) ? sub.count : (counts.get(id) || 0),
                    firstLoc: firstLocBySub.get(id) || null,
                };
                byId.set(id, entry);
                sections.push(entry);
            }

            for (const [id, loc] of firstLocBySub.entries()) {
                if (byId.has(id)) continue;
                sections.push({
                    id,
                    label: id,
                    count: counts.get(id) || 0,
                    firstLoc: loc,
                });
            }

            return sections;
        }

        async function ensureNavCatalog() {
            await loadFloorsLayout();
            await loadSlotsLayout();

            const floors = Array.isArray(LAYOUT.floors) ? LAYOUT.floors : [];
            navCatalog = {
                floors,
                sectionsByFloorId: new Map(),
                byFloorId: new Map(floors.map(f => [f.id, f])),
            };

            for (const floor of floors) {
                const floorSlots = LAYOUT.slotsByFloor?.[floor.id];
                navCatalog.sectionsByFloorId.set(floor.id, buildSectionsForFloor(floor, floorSlots));
            }
        }

        async function initializeNavPanelOptions() {
            const floorSelect = document.getElementById('nav-floor');
            const sectionSelect = document.getElementById('nav-section');
            if (!floorSelect || !sectionSelect) return;

            await ensureNavCatalog();
            floorSelect.innerHTML = '';

            for (const floor of navCatalog.floors) {
                const start = floor.roomStart + 1;
                const end = floor.roomStart + floor.roomCount;
                const option = document.createElement('option');
                option.value = floor.id;
                option.textContent = `${floor.label} (Rooms ${start}-${end})`;
                floorSelect.appendChild(option);
            }

            const activeFloor = currentFloorForRoom(currentRoomIndex);
            if (activeFloor) floorSelect.value = activeFloor.id;
            populateNavSectionOptions(floorSelect.value, '');
            syncRoomInputBoundsForFloor(activeFloor);
        }

        document.getElementById('nav-floor').addEventListener('change', (e) => {
            const floor = navCatalog.byFloorId.get(e.target.value) || null;
            populateNavSectionOptions(e.target.value, '');
            syncRoomInputBoundsForFloor(floor);
        });

        document.getElementById('nav-section').addEventListener('change', (e) => {
            const floorId = document.getElementById('nav-floor').value;
            const section = (navCatalog.sectionsByFloorId.get(floorId) || []).find(s => s.id === e.target.value) || null;
            updateNavFloorMeta(navCatalog.byFloorId.get(floorId), section);
        });

        window.openNav = async function() {
            closeAllPanels('nav');
            try {
                await initializeNavPanelOptions();
            } catch (e) {
                console.warn('failed to initialize nav panel', e);
                document.getElementById('nav-floor-meta').textContent = 'Could not load latest floor catalog.';
            }
            document.getElementById('nav-panel').classList.add('visible');
            navOpen = true;
            controls.unlock();
        };

        window.closeNav = function() {
            document.getElementById('nav-panel').classList.remove('visible');
            navOpen = false;
        };

        // ============================================
        // ELEVATOR (teleport between theme sections)
        // ============================================

        window.openElevator = function() {
            closeAllPanels('elevator');
            ensureElevatorButtons();
            updateElevatorPanelState();
            document.getElementById('elevator-panel').classList.add('visible');
            elevatorOpen = true;
            controls.unlock();
        };

        window.closeElevator = function() {
            document.getElementById('elevator-panel').classList.remove('visible');
            elevatorOpen = false;
        };

        function themeBaseRoom(themeIndex) {
            return THEME_ROOM_BASE_V2[themeIndex] ?? 0;
        }

        window.teleportToTheme = function(themeIndex) {
            setThemeFloor(themeIndex, 0);
            closeElevator();
            teleportTo(currentRoomIndex, null, null);
            const floors = (LAYOUT && Array.isArray(LAYOUT.floors) && LAYOUT.floors.length) ? LAYOUT.floors : null;
            const label = floors ? (floors[themeIndex]?.label) : (THEMES_V2[themeIndex]?.label);
            showToast(`Teleporting to ${label || 'floor'}`);
        };

        function updateElevatorPanelState() {
            const floors = (LAYOUT && Array.isArray(LAYOUT.floors) && LAYOUT.floors.length)
                ? LAYOUT.floors
                : THEMES_V2.map((t, i) => ({ id: t.id, label: t.label, roomStart: THEME_ROOM_BASE_V2[i], roomCount: ROOMS_PER_THEME_V2[i] }));

            const currentFloorIndex = themeIndexForRoom(currentRoomIndex);
            const currentFloor = floors[currentFloorIndex];
            const status = document.getElementById('elevator-current-floor');
            if (status && currentFloor) {
                const start = currentFloor.roomStart + 1;
                const end = currentFloor.roomStart + currentFloor.roomCount;
                status.textContent = `Current Floor: ${currentFloor.label || currentFloor.id} (Rooms ${start}-${end})`;
            }

            document.querySelectorAll('#elevator-buttons .floor-btn').forEach((btn) => {
                const idx = parseInt(btn.dataset.floorIndex || '', 10);
                btn.classList.toggle('active', idx === currentFloorIndex);
            });
        }

        function ensureElevatorButtons() {
            const host = document.getElementById('elevator-buttons');
            if (!host) return;

            const floors = (LAYOUT && Array.isArray(LAYOUT.floors) && LAYOUT.floors.length)
                ? LAYOUT.floors
                : THEMES_V2.map((t, i) => ({ id: t.id, label: t.label, roomStart: THEME_ROOM_BASE_V2[i], roomCount: ROOMS_PER_THEME_V2[i] }));
            const signature = floors.map(f => `${f.id}:${f.roomStart}:${f.roomCount}`).join('|');
            if (host.dataset.signature === signature) {
                updateElevatorPanelState();
                return;
            }
            host.dataset.signature = signature;
            host.innerHTML = '';

            for (let i = 0; i < floors.length; i++) {
                const f = floors[i];
                const btn = document.createElement('button');
                btn.className = 'floor-btn';
                btn.dataset.floorIndex = String(i);
                btn.onclick = () => teleportToTheme(i);

                const title = document.createElement('span');
                title.className = 'floor-name';
                title.textContent = f.label || f.id || `Floor ${i + 1}`;
                btn.appendChild(title);

                const meta = document.createElement('span');
                meta.className = 'floor-meta';
                const start = (f.roomStart ?? 0) + 1;
                const end = (f.roomStart ?? 0) + (f.roomCount ?? 0);
                meta.textContent = `Rooms ${start}-${end}`;
                btn.appendChild(meta);

                host.appendChild(btn);
            }
            updateElevatorPanelState();
        }


        window.navigateToCoords = function() {
            const room = parseInt(document.getElementById('nav-room').value) - 1 || 0;
            const wall = parseInt(document.getElementById('nav-wall').value) - 1 || 0;
            const shelf = parseInt(document.getElementById('nav-shelf').value) - 1 || 0;
            const vol = parseInt(document.getElementById('nav-vol').value) - 1 || 0;

            if (room < 0 || room >= TOTAL_ROOMS || wall < 0 || wall >= 4 ||
                shelf < 0 || shelf >= 5 || vol < 0 || vol >= 32) {
                return;
            }

            const bookId = locationToBookId(room, wall, shelf, vol);
            closeNav();
            teleportTo(room, () => {
                openBook(bookId);
            }, bookId);
        };

        window.navigateToSection = function() {
            const floorId = document.getElementById('nav-floor').value;
            if (!floorId) return;

            const floor = navCatalog.byFloorId.get(floorId);
            if (!floor) return;

            const sectionId = document.getElementById('nav-section').value;
            const section = (navCatalog.sectionsByFloorId.get(floorId) || []).find(s => s.id === sectionId) || null;

            const fallback = { room: floor.roomStart, wall: 0, shelf: 0, volume: 0, bookId: null };
            const target = section?.firstLoc || fallback;

            document.getElementById('nav-room').value = String(target.room + 1);
            document.getElementById('nav-wall').value = String(target.wall + 1);
            document.getElementById('nav-shelf').value = String(target.shelf + 1);
            document.getElementById('nav-vol').value = String(target.volume + 1);

            closeNav();
            teleportTo(target.room, null, target.bookId || null);
        };

        window.navigateToGutenbergId = async function() {
            const bookId = parseInt(document.getElementById('nav-gutenberg-id').value);
            if (!bookId || bookId < 1 || bookId > TOTAL_BOOKS) return;
            closeNav();
            try {
                const loc = await getBookPrimaryLocation(bookId);
                teleportTo(loc.room, () => { openBook(bookId); }, bookId);
            } catch (e) {
                console.error(e);
                showToast('Failed to locate book');
            }
        };

        // ============================================
        // MY LIBRARY PANEL
        // ============================================

        window.openLibrary = function() {
            closeAllPanels('library');
            document.getElementById('library-panel').classList.add('visible');
            libraryOpen = true;
            controls.unlock();
            updateLibraryUI();
        };

        window.closeLibrary = function() {
            document.getElementById('library-panel').classList.remove('visible');
            libraryOpen = false;
        };

        function updateLibraryUI() {
            // Continue reading banner
            const continueSection = document.getElementById('continue-reading-section');
            const lastBook = getLastReadBook();
            if (lastBook && lastBook.page > 0) {
                const meta = bookCache.get(lastBook.bookId);
                const title = meta?.title || `Book #${lastBook.bookId}`;
                const percent = Math.round((lastBook.page / lastBook.total) * 100);
                continueSection.innerHTML = `
                    <div class="continue-reading-banner" onclick="continueReading(${lastBook.bookId}, ${lastBook.page})">
                        <div class="continue-reading-label">Continue Reading</div>
                        <div class="continue-reading-title">${escapeHtml(title)}</div>
                        <div class="continue-reading-progress">Page ${lastBook.page + 1} of ${lastBook.total} (${percent}%)</div>
                    </div>
                `;
            } else {
                continueSection.innerHTML = '';
            }
            
            // Update indicator
            const hasContent = bookmarks.length > 0 || recents.length > 0 || lastBook;
            const indicator = document.querySelector('#library-btn .indicator');
            if (indicator) {
                indicator.style.display = hasContent ? 'block' : 'none';
            }

            // Bookmarks
            const bookmarksList = document.getElementById('bookmarks-list');
            if (bookmarks.length === 0) {
                bookmarksList.innerHTML = '<div class="empty-state">No bookmarks yet. Open a book and click ðŸ”– to add one.</div>';
            } else {
                bookmarksList.innerHTML = bookmarks.map(b => {
                    const location = bookIdToLocation(b.bookId);
                    const progress = getReadingProgress(b.bookId);
                    const progressText = progress ? `Page ${progress.page + 1} of ${progress.total}` : '';
                    return `
                        <div class="bookmark-item" onclick="goToBookFromLibrary(${b.bookId})">
                            <button class="bookmark-remove" onclick="event.stopPropagation(); removeBookmarkFromUI(${b.bookId})">&times;</button>
                            <div class="search-result-title">${escapeHtml(b.title)}</div>
                            <div class="search-result-author">${escapeHtml(b.authors)}</div>
                            <div class="search-result-location">Room ${location.room + 1} Â· Wall ${location.wall + 1} Â· Shelf ${location.shelf + 1}</div>
                            ${progressText ? `<div class="search-result-progress">${progressText}</div>` : ''}
                        </div>
                    `;
                }).join('');
            }

            // Recents
            const recentsList = document.getElementById('recents-list');
            if (recents.length === 0) {
                recentsList.innerHTML = '<div class="empty-state">No recent books. Start exploring!</div>';
            } else {
                recentsList.innerHTML = recents.map(r => {
                    const location = bookIdToLocation(r.bookId);
                    const progress = getReadingProgress(r.bookId);
                    const progressText = progress ? `Page ${progress.page + 1} of ${progress.total}` : '';
                    return `
                        <div class="recent-item" onclick="goToBookFromLibrary(${r.bookId})">
                            <div class="search-result-title">${escapeHtml(r.title)}</div>
                            <div class="search-result-author">${escapeHtml(r.authors)}</div>
                            <div class="search-result-location">Room ${location.room + 1} Â· Wall ${location.wall + 1} Â· Shelf ${location.shelf + 1}</div>
                            ${progressText ? `<div class="search-result-progress">${progressText}</div>` : ''}
                        </div>
                    `;
                }).join('');
            }
        }

        window.goToBookFromLibrary = function(bookId) {
            closeLibrary();
            const location = bookIdToLocation(bookId);
            teleportTo(location.room, () => {
                openBook(bookId);
            }, bookId);
        };

        window.continueReading = function(bookId, page) {
            closeLibrary();
            const location = bookIdToLocation(bookId);
            teleportTo(location.room, () => {
                openBook(bookId, page);
            }, bookId);
        };

        window.removeBookmarkFromUI = function(bookId) {
            removeBookmark(bookId);
        };

        // Panel tabs
        document.querySelectorAll('.panel-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(`${tabName}-tab`).classList.add('active');
            });
        });

        // ============================================
        // RANDOM ROOM
        // ============================================

        window.randomRoom = function() {
            const randomRoomIdx = Math.floor(Math.random() * TOTAL_ROOMS);
            teleportTo(randomRoomIdx);
        };

        // ============================================
        // ABOUT MODAL
        // ============================================

        window.openAbout = function() {
            closeAllPanels('about');
            document.getElementById('about-overlay').classList.add('visible');
            document.getElementById('about-modal').classList.add('visible');
            aboutOpen = true;
            controls.unlock();

            // Layout is server-driven now; no client-side reshelving toggle
        };

        window.closeAbout = function() {
            document.getElementById('about-overlay').classList.remove('visible');
            document.getElementById('about-modal').classList.remove('visible');
            aboutOpen = false;
        };

        // ============================================
        // HUD UPDATE
        // ============================================

        function updateHUD() {
            const startBook = currentRoomIndex * BOOKS_PER_ROOM + 1;
            const endBook = Math.min((currentRoomIndex + 1) * BOOKS_PER_ROOM, TOTAL_BOOKS);
            document.getElementById('hud-coords').textContent = `Room ${currentRoomIndex + 1} of ${TOTAL_ROOMS}`;
            document.getElementById('hud-info').textContent = `Books #${startBook.toLocaleString()} â€“ #${endBook.toLocaleString()} Â· ${BOOKS_PER_ROOM} books per room`;
            if (elevatorOpen) updateElevatorPanelState();
        }

        // ============================================
        // BRIGHTNESS CONTROL
        // ============================================

        const brightnessSlider = document.getElementById('brightness-slider');
        brightnessSlider.addEventListener('input', (e) => {
            renderer.toneMappingExposure = e.target.value / 100;
        });

        // ============================================
        // INTRO SEQUENCE
        // ============================================

        const intro = document.getElementById('intro');
        intro.addEventListener('click', () => {
            if (intro.classList.contains('hidden')) return;
            intro.classList.add('hidden');
            introHidden = true;
            setTimeout(() => {
                intro.style.display = 'none';
            }, 1500);
        });

        // ============================================
        // ANIMATION LOOP
        // ============================================

        const clock = new THREE.Clock();
        let hoveredBook = null;
        const tempColor = new THREE.Color();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            const now = performance.now();

            if (controls.isLocked) {
                const direction = new THREE.Vector3();
                if (keys.forward) direction.z -= 1;
                if (keys.backward) direction.z += 1;
                if (keys.left) direction.x -= 1;
                if (keys.right) direction.x += 1;

                if (direction.length() > 0) {
                    direction.normalize();

                    const moveDir = direction.clone();
                    moveDir.applyQuaternion(camera.quaternion);
                    moveDir.y = 0;
                    moveDir.normalize();

                    camera.position.add(moveDir.multiplyScalar(moveSpeed * delta));

                    applyCollision();
                    checkRoomTransition();
                }

                // Update elevator hint even when standing still
                updateElevatorHint();

                // Book hover highlight
                if (hoveredBook) {
                    hoveredBook.mesh.setColorAt(hoveredBook.instanceId, hoveredBook.originalColor);
                    hoveredBook.mesh.instanceColor.needsUpdate = true;
                    hoveredBook = null;
                    document.getElementById('crosshair').style.borderColor = 'rgba(212, 197, 160, 0.5)';
                    document.getElementById('book-tooltip').classList.remove('visible');
                    hideSpineLabel();
                }

                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                for (const [idx, room] of rooms) {
                    const intersects = raycaster.intersectObject(room.bookMesh);
                    if (intersects.length > 0) {
                        const instanceId = intersects[0].instanceId;
                        const bookInfo = room.bookMap[instanceId];
                        room.bookMesh.getColorAt(instanceId, tempColor);

                        hoveredBook = {
                            mesh: room.bookMesh,
                            instanceId: instanceId,
                            originalColor: tempColor.clone()
                        };

                        // Brighten the book
                        tempColor.multiplyScalar(1.5);
                        room.bookMesh.setColorAt(instanceId, tempColor);
                        room.bookMesh.instanceColor.needsUpdate = true;
                        document.getElementById('crosshair').style.borderColor = 'rgba(196, 148, 58, 0.9)';

                        // Show tooltip with book info (debounced fetch)
                        if (hoveredBookId !== bookInfo.bookId) {
                            hoveredBookId = bookInfo.bookId;
                            const tooltip = document.getElementById('book-tooltip');
                            tooltip.querySelector('.title').textContent = `Book #${bookInfo.bookId}`;
                            tooltip.querySelector('.author').textContent = 'Click to read';
                            tooltip.querySelector('.location-hint').textContent = 
                                `Wall ${bookInfo.wall + 1} Â· Shelf ${bookInfo.shelf + 1} Â· Vol ${bookInfo.vol + 1}`;
                            tooltip.classList.add('visible');

                            // Fetch actual metadata with debouncing
                            fetchBookMetadataDebounced(bookInfo.bookId, (meta) => {
                                if (meta && hoveredBookId === bookInfo.bookId) {
                                    tooltip.querySelector('.title').textContent = meta.title;
                                    tooltip.querySelector('.author').textContent = meta.authors;
                                }
                            });
                        }

                        // Show spine label at book position (screen-space)
                        const worldPos = bookInfo.worldPos.clone();
                        worldPos.y += 0.15; // Above the book
                        worldPos.add(room.group.position);
                        const screenPos = worldPos.clone().project(camera);
                        const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                        
                        if (screenPos.z < 1) { // In front of camera
                            updateSpineLabel(bookInfo, { x, y });
                        } else {
                            hideSpineLabel();
                        }

                        break;
                    }
                }

                if (!hoveredBook) {
                    hoveredBookId = null;
                }
            }

            // Update book highlighting (search/teleport target glow)
            if (highlightedBookInfo) {
                const elapsed = now - highlightStartTime;
                if (elapsed > HIGHLIGHT_DURATION) {
                    // Restore original color and clear highlight
                    const room = rooms.get(highlightedBookInfo.room);
                    if (room) {
                        const bookEntry = room.bookMap.find(b => b.bookId === highlightedBookInfo.bookId);
                        if (bookEntry) {
                            const origR = room.originalColors[bookEntry.instanceId * 3];
                            const origG = room.originalColors[bookEntry.instanceId * 3 + 1];
                            const origB = room.originalColors[bookEntry.instanceId * 3 + 2];
                            tempColor.setRGB(origR, origG, origB);
                            room.bookMesh.setColorAt(bookEntry.instanceId, tempColor);
                            room.bookMesh.instanceColor.needsUpdate = true;
                        }
                    }
                    clearHighlight();
                } else {
                    // Pulsing glow effect
                    const room = rooms.get(highlightedBookInfo.room);
                    if (room) {
                        const bookEntry = room.bookMap.find(b => b.bookId === highlightedBookInfo.bookId);
                        if (bookEntry) {
                            const pulse = Math.sin(elapsed * 0.008) * 0.5 + 0.5; // 0-1 pulsing
                            const origR = room.originalColors[bookEntry.instanceId * 3];
                            const origG = room.originalColors[bookEntry.instanceId * 3 + 1];
                            const origB = room.originalColors[bookEntry.instanceId * 3 + 2];
                            
                            // Blend between original color and gold highlight
                            tempColor.setRGB(
                                origR + (HIGHLIGHT_COLOR.r - origR) * pulse * 0.7,
                                origG + (HIGHLIGHT_COLOR.g - origG) * pulse * 0.7,
                                origB + (HIGHLIGHT_COLOR.b - origB) * pulse * 0.7
                            );
                            room.bookMesh.setColorAt(bookEntry.instanceId, tempColor);
                            room.bookMesh.instanceColor.needsUpdate = true;
                        }
                    }
                }
            }

            // Enhanced light flicker effect with occasional stronger flickers
            for (const [idx, room] of rooms) {
                if (room.lights && room.lamps) {
                    const seed1 = room.roomIndex * 7;
                    const seed2 = room.roomIndex * 11;

                    // Base flicker
                    let flicker1 = Math.sin(elapsedTime * 2.3 + seed1) * 0.08
                                   + Math.sin(elapsedTime * 4.7 + seed1 * 2) * 0.05;
                    let flicker2 = Math.sin(elapsedTime * 2.1 + seed2) * 0.08
                                   + Math.sin(elapsedTime * 5.1 + seed2 * 2) * 0.05;

                    // Occasional stronger flicker (every ~5 seconds, random)
                    const flickerChance = Math.sin(elapsedTime * 0.2 + seed1) * Math.sin(elapsedTime * 0.13 + seed2);
                    if (flickerChance > 0.95) {
                        flicker1 += (Math.random() - 0.5) * 0.3;
                    }
                    if (Math.sin(elapsedTime * 0.17 + seed2) * Math.sin(elapsedTime * 0.23 + seed1) > 0.95) {
                        flicker2 += (Math.random() - 0.5) * 0.3;
                    }

                    room.lights[0].intensity = 2.0 + flicker1;
                    room.lights[1].intensity = 2.0 + flicker2;
                    
                    // Lamp glow color variation
                    const warmth1 = 0.95 + flicker1 * 0.3;
                    const warmth2 = 0.95 + flicker2 * 0.3;
                    room.lamps[0].material.color.setRGB(1, warmth1 * 0.88, warmth1 * 0.63);
                    room.lamps[1].material.color.setRGB(1, warmth2 * 0.88, warmth2 * 0.63);

                    if (room.inlayGroup) {
                        room.inlayGroup.rotation.y = elapsedTime * 0.08 + (room.decoMotionSeed || 0);
                    }

                    if (room.chandelierPivot) {
                        room.chandelierPivot.rotation.x = Math.sin(elapsedTime * 0.55 + room.roomIndex * 0.3) * 0.016;
                        room.chandelierPivot.rotation.z = Math.cos(elapsedTime * 0.62 + room.roomIndex * 0.19) * 0.013;
                    }

                    if (room.chandelierLight) {
                        room.chandelierLight.intensity = 1.35 + Math.sin(elapsedTime * 1.7 + room.roomIndex) * 0.09;
                    }

                    if (room.lightShafts) {
                        const shaftPulse = 0.12 + (Math.max(flicker1, flicker2) + 0.15) * 0.2;
                        for (let i = 0; i < room.lightShafts.length; i++) {
                            const shaft = room.lightShafts[i];
                            shaft.material.opacity = Math.max(0.06, shaftPulse + Math.sin(elapsedTime * 0.9 + i + room.roomIndex) * 0.02);
                            shaft.rotation.y = elapsedTime * 0.1 + i * 0.6;
                        }
                    }
                }
            }

            updateParticles(delta, elapsedTime);
            renderer.render(scene, camera);
        }

        // ============================================
        // ATMOSPHERIC DUST PARTICLES (Enhanced)
        // ============================================

        const PARTICLE_COUNT = 400;
        const particlePositions = new Float32Array(PARTICLE_COUNT * 3);
        const particleSizes = new Float32Array(PARTICLE_COUNT);
        const particleVelocities = [];
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            particlePositions[i * 3] = (Math.random() - 0.5) * 24;
            particlePositions[i * 3 + 1] = Math.random() * ROOM_HEIGHT;
            particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 24;
            particleSizes[i] = 0.008 + Math.random() * 0.012;
            particleVelocities.push(
                (Math.random() - 0.5) * 0.012,
                (Math.random() - 0.5) * 0.006,
                (Math.random() - 0.5) * 0.012,
                Math.random() * Math.PI * 2 // phase for floating motion
            );
        }
        
        const particleGeom = new THREE.BufferGeometry();
        particleGeom.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeom.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
        
        const particleMat = new THREE.PointsMaterial({
            color: 0xFFD280,
            size: 0.015,
            transparent: true,
            opacity: 0.3,
            sizeAttenuation: true,
        });
        const dustParticles = new THREE.Points(particleGeom, particleMat);
        scene.add(dustParticles);

        function updateParticles(delta, elapsedTime) {
            const positions = dustParticles.geometry.attributes.position.array;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const phase = particleVelocities[i * 4 + 3];
                
                // Add gentle floating motion
                const floatX = Math.sin(elapsedTime * 0.5 + phase) * 0.002;
                const floatY = Math.sin(elapsedTime * 0.3 + phase * 1.5) * 0.001;
                const floatZ = Math.cos(elapsedTime * 0.4 + phase * 0.7) * 0.002;
                
                positions[i * 3] += (particleVelocities[i * 4] + floatX) * delta * 60;
                positions[i * 3 + 1] += (particleVelocities[i * 4 + 1] + floatY) * delta * 60;
                positions[i * 3 + 2] += (particleVelocities[i * 4 + 2] + floatZ) * delta * 60;

                const dx = positions[i * 3] - camera.position.x;
                const dz = positions[i * 3 + 2] - camera.position.z;
                if (Math.abs(dx) > 12) positions[i * 3] = camera.position.x + (Math.random() - 0.5) * 20;
                if (Math.abs(dz) > 12) positions[i * 3 + 2] = camera.position.z + (Math.random() - 0.5) * 20;
                if (positions[i * 3 + 1] > ROOM_HEIGHT) positions[i * 3 + 1] = 0;
                if (positions[i * 3 + 1] < 0) positions[i * 3 + 1] = ROOM_HEIGHT;
            }
            dustParticles.geometry.attributes.position.needsUpdate = true;
            
            // Subtle opacity variation based on camera position
            const brightness = 0.25 + Math.sin(elapsedTime * 0.1) * 0.05;
            particleMat.opacity = brightness;
        }

        // ============================================
        // KEYBOARD SHORTCUTS
        // ============================================

        window.addEventListener('keydown', (e) => {
            if (readerOpen) {
                if (e.code === 'Escape') { 
                    if (document.getElementById('reader-search-bar').classList.contains('visible')) {
                        closeReaderSearch();
                    } else {
                        closeBook(); 
                    }
                }
                if (e.code === 'ArrowRight' || e.code === 'ArrowDown') { e.preventDefault(); nextPage(); }
                if (e.code === 'ArrowLeft' || e.code === 'ArrowUp') { e.preventDefault(); prevPage(); }
                if (e.code === 'KeyB') { toggleBookmark(); }
                if (e.code === 'KeyD' && !e.ctrlKey && !e.metaKey && !e.altKey) { toggleReaderTheme(); }
                if ((e.ctrlKey || e.metaKey) && e.code === 'KeyF') {
                    e.preventDefault();
                    openReaderSearch();
                }
            } else if (searchOpen) {
                if (e.code === 'Escape') { closeSearch(); }
                if (e.code === 'Enter') {
                    e.preventDefault();
                    if (e.target.id === 'search-gutenberg-id') {
                        jumpToGutenbergId();
                    } else if (selectedSearchIndex >= 0 && searchResults[selectedSearchIndex]) {
                        goToBook(searchResults[selectedSearchIndex].id);
                    } else {
                        performSearch();
                    }
                }
                // Arrow key navigation in search results
                if (e.code === 'ArrowDown' && searchResults.length > 0) {
                    e.preventDefault();
                    selectedSearchIndex = Math.min(selectedSearchIndex + 1, searchResults.length - 1);
                    renderSearchResults();
                    // Scroll into view
                    const selected = document.querySelector('.search-result-item.selected');
                    if (selected) selected.scrollIntoView({ block: 'nearest' });
                }
                if (e.code === 'ArrowUp' && searchResults.length > 0) {
                    e.preventDefault();
                    selectedSearchIndex = Math.max(selectedSearchIndex - 1, 0);
                    renderSearchResults();
                    const selected = document.querySelector('.search-result-item.selected');
                    if (selected) selected.scrollIntoView({ block: 'nearest' });
                }
            } else if (navOpen) {
                if (e.code === 'Escape') { closeNav(); }
            } else if (libraryOpen) {
                if (e.code === 'Escape') { closeLibrary(); }
            } else if (aboutOpen) {
                if (e.code === 'Escape') { closeAbout(); }
            }
        });

        // ============================================
        // WINDOW RESIZE
        // ============================================

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ============================================
        // INITIALIZATION
        // ============================================

        updateRooms();
        updateHUD();
        updateLibraryUI();
        applyReaderTheme();
        animate();
    </script>
</body>
</html>
