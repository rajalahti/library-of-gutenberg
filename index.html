<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A digital library filled with real books from Project Gutenberg. Walk through hexagonal rooms and read classic literature.">
    <title>The Library of Gutenberg</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ“š</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Cormorant Garamond', serif;
            background: #0a0806;
            color: #d4c5a0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #scene {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.7) 100%);
            pointer-events: none;
            z-index: 2;
        }

        #transition-fade {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0806;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        #transition-fade.active {
            opacity: 1;
        }

        #title-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 12px 20px;
            font-size: 13px;
            letter-spacing: 4px;
            color: rgba(139, 115, 85, 0.5);
            z-index: 3;
            background: linear-gradient(to bottom, rgba(10,8,6,0.5) 0%, transparent 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #title-bar > * {
            pointer-events: auto;
        }

        #brightness-slider {
            width: 80px;
            height: 3px;
            -webkit-appearance: none;
            appearance: none;
            background: #4a3520;
            outline: none;
            opacity: 0.7;
            vertical-align: middle;
            cursor: pointer;
            border-radius: 2px;
        }

        #brightness-slider:hover {
            opacity: 1;
        }

        #brightness-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #c4943a;
            cursor: pointer;
        }

        #intro {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000 url('images/hero.png') center center / cover no-repeat;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 1;
            transition: opacity 1.5s ease-out;
            cursor: pointer;
        }

        #intro::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.55);
        }

        #intro.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #intro-text {
            max-width: 700px;
            padding: 40px;
            text-align: center;
            position: relative;
            z-index: 1;
        }

        .intro-quote {
            font-size: 26px;
            font-style: italic;
            line-height: 1.8;
            color: #d4c5a0;
            opacity: 0;
            animation: fadeInText 2.5s ease-in forwards;
            letter-spacing: 0.3px;
        }

        .intro-attribution {
            margin-top: 24px;
            font-size: 16px;
            color: #8b7355;
            opacity: 0;
            animation: fadeInText 1.5s ease-in 1.5s forwards;
        }

        .intro-prompt {
            margin-top: 48px;
            font-size: 14px;
            color: #5a4a32;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0;
            animation: fadeInText 1s ease-in 3s forwards, pulse 2s ease-in-out 4s infinite;
        }

        @keyframes fadeInText {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            z-index: 10;
            display: none;
            pointer-events: none;
            transform: translate(-50%, -50%) rotate(45deg);
            border: 1px solid rgba(212, 197, 160, 0.5);
            transition: border-color 0.15s ease;
        }

        #crosshair.visible {
            display: block;
        }

        #instructions {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 18, 8, 0.85);
            padding: 12px 24px;
            border-radius: 6px;
            border: 1px solid #4a3520;
            color: #d4c5a0;
            font-size: 15px;
            z-index: 5;
            transition: opacity 0.3s;
        }

        #instructions.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #book-tooltip {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 18, 8, 0.95);
            padding: 10px 20px;
            border-radius: 4px;
            border: 1px solid #4a3520;
            color: #c4943a;
            font-size: 14px;
            z-index: 5;
            display: none;
            max-width: 400px;
            text-align: center;
            transition: opacity 0.2s ease;
        }

        #book-tooltip.visible {
            display: block;
            animation: tooltipFadeIn 0.2s ease;
        }

        @keyframes tooltipFadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(4px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        #book-tooltip .author {
            color: #8b7355;
            font-size: 12px;
            margin-top: 4px;
        }

        #hud {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(10, 8, 6, 0.85);
            padding: 8px 16px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            color: #5a4a32;
            z-index: 5;
            border-top: 1px solid rgba(74, 53, 32, 0.4);
            display: flex;
            justify-content: space-between;
        }

        #hud-info {
            font-size: 11px;
            color: #3a2e1f;
        }

        #toolbar {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 5;
        }

        .toolbar-btn {
            background: rgba(74, 37, 16, 0.85);
            border: 1px solid #8b7355;
            color: #d4c5a0;
            font-family: 'Cormorant Garamond', serif;
            font-size: 16px;
            padding: 10px 20px;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 4px;
        }

        .toolbar-btn:hover {
            background: rgba(94, 47, 20, 0.95);
            border-color: #c4943a;
            color: #fff;
            transform: translateY(-1px);
        }

        .toolbar-btn.has-indicator {
            position: relative;
        }

        .toolbar-btn .indicator {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 8px;
            height: 8px;
            background: #c4943a;
            border-radius: 50%;
            animation: indicatorPulse 2s infinite;
        }

        @keyframes indicatorPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.2); }
        }

        #reader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        #reader.visible {
            display: flex;
            animation: readerFadeIn 0.3s ease;
        }

        @keyframes readerFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .reader-container {
            display: flex;
            gap: 4px;
            max-width: 95%;
            max-height: 92vh;
        }

        .reader-page {
            max-width: 780px;
            width: 92%;
            max-height: 92vh;
            background: linear-gradient(170deg, #2a2015 0%, #1f1810 40%, #1a150e 100%);
            border: 1px solid #4a3520;
            border-radius: 3px;
            padding: 36px 40px;
            overflow-y: auto;
            box-shadow: 0 0 60px rgba(0,0,0,0.8), inset 0 1px 0 rgba(196,148,58,0.06);
        }

        .reader-page.two-page-mode {
            max-width: 520px;
        }

        .reader-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 24px;
            padding-bottom: 12px;
            border-bottom: 1px solid #4a3520;
        }

        .reader-title {
            font-size: 22px;
            font-weight: 600;
            color: #c4943a;
        }

        .reader-author {
            font-size: 14px;
            color: #8b7355;
            margin-top: 4px;
        }

        .reader-coords {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            color: #5a4a32;
            margin-top: 8px;
        }

        .reader-close {
            background: none;
            border: none;
            color: #8b7355;
            font-size: 28px;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            width: 32px;
            height: 32px;
            transition: color 0.2s;
        }

        .reader-close:hover {
            color: #d4c5a0;
        }

        .reader-content {
            font-family: 'Cormorant Garamond', serif;
            font-size: 16px;
            line-height: 1.8;
            color: #c4b590;
            white-space: pre-wrap;
            margin-bottom: 24px;
            overflow-x: auto;
            overflow-y: auto;
            max-height: 60vh;
            padding: 16px;
            background: rgba(10, 8, 6, 0.4);
            border-radius: 2px;
        }

        .reader-content.loading {
            color: #8b7355;
            font-style: italic;
            text-align: center;
            padding: 40px;
        }

        .reader-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            padding-top: 12px;
            border-top: 1px solid #4a3520;
            flex-wrap: wrap;
        }

        .reader-page-num {
            color: #8b7355;
            font-size: 14px;
            white-space: nowrap;
        }

        .reader-nav {
            display: flex;
            gap: 12px;
        }

        .reader-nav button {
            background: rgba(74, 37, 16, 0.7);
            border: 1px solid #8b7355;
            color: #d4c5a0;
            font-family: 'Cormorant Garamond', serif;
            font-size: 15px;
            padding: 8px 14px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .reader-nav button:hover:not(:disabled) {
            background: rgba(94, 47, 20, 0.9);
            border-color: #c4943a;
        }

        .reader-nav button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .reader-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .reader-action-btn {
            background: none;
            border: 1px solid transparent;
            color: #8b7355;
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .reader-action-btn:hover {
            color: #c4943a;
            border-color: #4a3520;
        }

        .reader-action-btn.active {
            color: #c4943a;
        }

        .reader-action-btn.bookmarked {
            color: #c4943a;
        }

        .page-flip {
            animation: pageFlip 160ms ease-in-out;
        }

        @keyframes pageFlip {
            0% { opacity: 0.35; transform: translateX(8px); }
            100% { opacity: 1; transform: translateX(0); }
        }

        .panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 420px;
            height: 100vh;
            background: #12100a;
            border-left: 1px solid #4a3520;
            z-index: 90;
            transform: translateX(100%);
            transition: transform 0.3s ease-out;
            overflow-y: auto;
            padding: 32px;
        }

        .panel.visible {
            transform: translateX(0);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .panel-title {
            font-size: 24px;
            font-weight: 600;
            color: #c4943a;
        }

        .panel-close {
            background: none;
            border: none;
            color: #8b7355;
            font-size: 28px;
            cursor: pointer;
            line-height: 1;
            transition: color 0.2s;
        }

        .panel-close:hover {
            color: #d4c5a0;
        }

        .panel label {
            display: block;
            margin-bottom: 8px;
            color: #8b7355;
            font-size: 14px;
        }

        .panel input {
            width: 100%;
            background: #1a1208;
            border: 1px solid #4a3520;
            color: #d4c5a0;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 13px;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 12px;
            transition: border-color 0.2s;
        }

        .panel input:focus {
            outline: none;
            border-color: #c4943a;
        }

        .panel button {
            width: 100%;
            background: rgba(74, 37, 16, 0.85);
            border: 1px solid #8b7355;
            color: #d4c5a0;
            font-family: 'Cormorant Garamond', serif;
            font-size: 16px;
            padding: 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            margin-bottom: 12px;
        }

        .panel button:hover {
            background: rgba(94, 47, 20, 0.95);
            border-color: #c4943a;
        }

        .search-philosophy {
            font-style: italic;
            font-size: 15px;
            line-height: 1.6;
            color: #8b7355;
            margin-bottom: 20px;
        }

        .panel-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 20px;
            border-bottom: 1px solid #4a3520;
            padding-bottom: 12px;
        }

        .panel-tab {
            background: none;
            border: 1px solid transparent;
            color: #8b7355;
            font-family: 'Cormorant Garamond', serif;
            font-size: 15px;
            padding: 8px 14px;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            transition: all 0.2s;
            width: auto;
            margin-bottom: 0;
        }

        .panel-tab:hover {
            color: #d4c5a0;
            border-color: #4a3520;
        }

        .panel-tab.active {
            background: rgba(74, 37, 16, 0.5);
            color: #c4943a;
            border-color: #4a3520;
            border-bottom-color: #12100a;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: tabFadeIn 0.3s ease;
        }

        @keyframes tabFadeIn {
            from { opacity: 0; transform: translateY(4px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #search-results {
            margin-top: 16px;
        }

        .search-result-item {
            background: rgba(26, 18, 8, 0.6);
            border: 1px solid #4a3520;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .search-result-item:hover {
            background: rgba(46, 28, 12, 0.8);
            border-color: #c4943a;
            transform: translateX(2px);
        }

        .search-result-title {
            color: #c4943a;
            font-size: 15px;
            font-weight: 600;
        }

        .search-result-author {
            color: #8b7355;
            font-size: 13px;
            margin-top: 4px;
        }

        .search-result-location {
            color: #5a4a32;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            margin-top: 8px;
        }

        .search-result-progress {
            color: #6a5a42;
            font-size: 11px;
            margin-top: 4px;
        }

        .nav-field {
            margin-bottom: 20px;
        }

        .section-divider {
            margin: 24px 0;
            padding-top: 16px;
            border-top: 1px solid #4a3520;
        }

        .section-title {
            font-size: 14px;
            color: #8b7355;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 16px;
        }

        .empty-state {
            text-align: center;
            padding: 24px;
            color: #5a4a32;
            font-style: italic;
        }

        .bookmark-item, .recent-item {
            background: rgba(26, 18, 8, 0.6);
            border: 1px solid #4a3520;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .bookmark-item:hover, .recent-item:hover {
            background: rgba(46, 28, 12, 0.8);
            border-color: #c4943a;
            transform: translateX(2px);
        }

        .bookmark-remove {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: #5a4a32;
            font-size: 16px;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
            width: auto;
            margin: 0;
            transition: color 0.2s;
        }

        .bookmark-remove:hover {
            color: #c4943a;
            background: none;
        }

        .continue-reading-banner {
            background: linear-gradient(135deg, rgba(74, 37, 16, 0.9), rgba(46, 28, 12, 0.9));
            border: 1px solid #c4943a;
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .continue-reading-banner:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(196, 148, 58, 0.2);
        }

        .continue-reading-label {
            font-size: 11px;
            color: #c4943a;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .continue-reading-title {
            font-size: 17px;
            color: #d4c5a0;
            font-weight: 600;
        }

        .continue-reading-progress {
            font-size: 12px;
            color: #8b7355;
            margin-top: 4px;
        }

        #about-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 700px;
            width: 90%;
            max-height: 90vh;
            background: #12100a;
            border: 1px solid #4a3520;
            border-radius: 4px;
            padding: 40px;
            z-index: 110;
            display: none;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.9);
        }

        #about-modal.visible {
            display: block;
            animation: modalFadeIn 0.3s ease;
        }

        @keyframes modalFadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        #about-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 105;
            display: none;
        }

        #about-overlay.visible {
            display: block;
        }

        .about-header {
            text-align: center;
            margin-bottom: 32px;
        }

        .about-title {
            font-size: 32px;
            font-weight: 600;
            color: #c4943a;
            margin-bottom: 16px;
            letter-spacing: 2px;
        }

        .about-quote {
            font-style: italic;
            font-size: 18px;
            line-height: 1.6;
            color: #d4c5a0;
            margin-bottom: 8px;
        }

        .about-content {
            font-size: 16px;
            line-height: 1.8;
            color: #d4c5a0;
            margin-bottom: 24px;
        }

        .about-content p {
            margin-bottom: 16px;
        }

        .about-section-title {
            font-size: 18px;
            font-weight: 600;
            color: #c4943a;
            margin-top: 32px;
            margin-bottom: 12px;
        }

        .about-close {
            width: 100%;
            background: rgba(74, 37, 16, 0.85);
            border: 1px solid #8b7355;
            color: #d4c5a0;
            font-family: 'Cormorant Garamond', serif;
            font-size: 16px;
            padding: 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            margin-top: 24px;
        }

        .about-close:hover {
            background: rgba(94, 47, 20, 0.95);
            border-color: #c4943a;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #4a3520;
            border-radius: 50%;
            border-top-color: #c4943a;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Toast notifications */
        #toast-container {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }

        .toast {
            background: rgba(26, 18, 8, 0.95);
            border: 1px solid #c4943a;
            border-radius: 6px;
            padding: 12px 24px;
            color: #d4c5a0;
            font-size: 14px;
            animation: toastIn 0.3s ease, toastOut 0.3s ease 2.7s forwards;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        @keyframes toastIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes toastOut {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-10px); }
        }

        /* Two-page layout */
        .reader-page-right {
            display: none;
        }

        .reader-page-right.visible {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="scene"></canvas>
    <div id="transition-fade"></div>
    <div id="vignette"></div>
    <div id="title-bar">
        <span>THE LIBRARY OF GUTENBERG</span>
        <div style="display: flex; align-items: center; gap: 12px;">
            <input type="range" id="brightness-slider" min="30" max="150" value="80" title="Brightness">
        </div>
    </div>

    <div id="intro">
        <div id="intro-text">
            <div class="intro-quote">"A library is not a luxury but one of the necessities of life."</div>
            <div class="intro-attribution">â€” Henry Ward Beecher</div>
            <div class="intro-prompt">Click anywhere to enter the Library</div>
        </div>
    </div>

    <div id="crosshair"></div>

    <div id="instructions">
        Click to look around. WASD to walk. Click any book to read it.
    </div>

    <div id="book-tooltip">
        <div class="title"></div>
        <div class="author"></div>
    </div>

    <div id="hud">
        <span id="hud-coords">Room 1</span>
        <span id="hud-info">Loading library catalog...</span>
    </div>

    <div id="toolbar">
        <button class="toolbar-btn" onclick="openSearch()">Search</button>
        <button class="toolbar-btn" onclick="openNav()">Navigate</button>
        <button class="toolbar-btn has-indicator" id="library-btn" onclick="openLibrary()">My Library</button>
        <button class="toolbar-btn" onclick="randomRoom()">Random</button>
        <button class="toolbar-btn" onclick="openAbout()">About</button>
    </div>

    <div id="toast-container"></div>

    <div id="reader">
        <div class="reader-container">
            <div class="reader-page" id="reader-page-left">
                <div class="reader-header">
                    <div>
                        <div class="reader-title" id="reader-title">Loading...</div>
                        <div class="reader-author" id="reader-author"></div>
                        <div class="reader-coords" id="reader-coords"></div>
                    </div>
                    <button class="reader-close" onclick="closeBook()">&times;</button>
                </div>
                <div class="reader-content loading" id="reader-content">Loading book text...</div>
                <div class="reader-footer">
                    <div class="reader-page-num" id="reader-page-num">Page 1</div>
                    <div class="reader-actions">
                        <button class="reader-action-btn" id="bookmark-btn" onclick="toggleBookmark()" title="Bookmark">ðŸ”–</button>
                        <button class="reader-action-btn" id="two-page-btn" onclick="toggleTwoPage()" title="Two-page view">ðŸ“–</button>
                    </div>
                    <div class="reader-nav">
                        <button onclick="prevPage()" id="prev-page-btn">&larr; Previous</button>
                        <button onclick="nextPage()" id="next-page-btn">Next &rarr;</button>
                    </div>
                    <a id="reader-gutenberg-link" href="#" target="_blank" style="color:#c4943a;font-size:14px;">View on Gutenberg</a>
                </div>
            </div>
            <div class="reader-page reader-page-right two-page-mode" id="reader-page-right">
                <div class="reader-content" id="reader-content-right"></div>
                <div class="reader-footer">
                    <div class="reader-page-num" id="reader-page-num-right"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="search-panel" class="panel">
        <div class="panel-header">
            <div class="panel-title">Search</div>
            <button class="panel-close" onclick="closeSearch()">&times;</button>
        </div>
        <p class="search-philosophy">Search Project Gutenberg's catalog of over 70,000 free eBooks. Find a book and teleport directly to its shelf.</p>
        
        <div class="section-divider" style="margin-top:0; padding-top:0; border-top:none;">
            <div class="section-title">Search by Title/Author</div>
        </div>
        <input type="text" id="search-input" placeholder="e.g., Pride and Prejudice, Shakespeare...">
        <button onclick="performSearch()">Search</button>
        
        <div class="section-divider">
            <div class="section-title">Jump by Gutenberg ID</div>
        </div>
        <input type="number" id="search-gutenberg-id" min="1" placeholder="e.g., 1342 (Pride and Prejudice)">
        <button onclick="jumpToGutenbergId()">Go to Book</button>
        
        <div id="search-results"></div>
    </div>

    <div id="nav-panel" class="panel">
        <div class="panel-header">
            <div class="panel-title">Navigate</div>
            <button class="panel-close" onclick="closeNav()">&times;</button>
        </div>
        <div class="nav-field">
            <label>Room Number:</label>
            <input type="number" id="nav-room" min="1" max="110" value="1">
        </div>
        <div class="nav-field">
            <label>Wall (1-4):</label>
            <input type="number" id="nav-wall" min="1" max="4" value="1">
        </div>
        <div class="nav-field">
            <label>Shelf (1-5):</label>
            <input type="number" id="nav-shelf" min="1" max="5" value="1">
        </div>
        <div class="nav-field">
            <label>Volume (1-32):</label>
            <input type="number" id="nav-vol" min="1" max="32" value="1">
        </div>
        <button onclick="navigateToCoords()">Go There</button>
        <div class="section-divider">
            <div class="section-title">Jump by Gutenberg ID</div>
        </div>
        <input type="number" id="nav-gutenberg-id" min="1" placeholder="e.g., 1342">
        <button onclick="navigateToGutenbergId()">Go to Book</button>
    </div>

    <div id="library-panel" class="panel">
        <div class="panel-header">
            <div class="panel-title">My Library</div>
            <button class="panel-close" onclick="closeLibrary()">&times;</button>
        </div>
        
        <div id="continue-reading-section"></div>
        
        <div class="panel-tabs">
            <button class="panel-tab active" data-tab="bookmarks">Bookmarks</button>
            <button class="panel-tab" data-tab="recents">Recent</button>
        </div>
        
        <div class="tab-content active" id="bookmarks-tab">
            <div id="bookmarks-list">
                <div class="empty-state">No bookmarks yet. Open a book and click ðŸ”– to add one.</div>
            </div>
        </div>
        
        <div class="tab-content" id="recents-tab">
            <div id="recents-list">
                <div class="empty-state">No recent books. Start exploring!</div>
            </div>
        </div>
    </div>

    <div id="about-overlay" onclick="closeAbout()"></div>
    <div id="about-modal">
        <div class="about-header">
            <div class="about-title">THE LIBRARY OF GUTENBERG</div>
            <div class="about-quote">
                "A room without books is like a body without a soul."
            </div>
        </div>
        <div class="about-content">
            <p>
                This virtual library contains real books from <a href="https://www.gutenberg.org" target="_blank" style="color:#c4943a;">Project Gutenberg</a>, the oldest digital library of free eBooks. Walk through hexagonal rooms filled with classic literature.
            </p>
            <p>
                Each hexagonal room contains <strong>640 books</strong> arranged across 4 walls, 5 shelves per wall, and 32 volumes per shelf. The library holds the first 70,000 books from Project Gutenberg.
            </p>
            <p>
                Click on any book to read its full text. Use the Search feature to find specific titles or authors and teleport directly to their location.
            </p>
        </div>
        <div class="about-section-title">NAVIGATION</div>
        <div class="about-content">
            <p><strong>WASD</strong> â€” Move around<br>
            <strong>Mouse</strong> â€” Look around (click to engage)<br>
            <strong>Click a book</strong> â€” Read it<br>
            <strong>ESC</strong> â€” Release mouse / Close panels</p>
        </div>
        <div class="about-section-title">CREDITS</div>
        <div class="about-content">
            <p>
                Built with Three.js. Visual design inspired by Jorge Luis Borges's "Library of Babel" and Ethan Mollick's digital recreation. Book data from <a href="https://gutendex.com" target="_blank" style="color:#c4943a;">Gutendex API</a>.
            </p>
        </div>
        <button class="about-close" onclick="closeAbout()">Close</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // ============================================
        // LIBRARY CONFIGURATION
        // ============================================

        const BOOKS_PER_SHELF = 32;
        const SHELVES_PER_WALL = 5;
        const WALLS_PER_ROOM = 4;
        const BOOKS_PER_ROOM = BOOKS_PER_SHELF * SHELVES_PER_WALL * WALLS_PER_ROOM; // 640
        const TOTAL_BOOKS = 70000;
        const TOTAL_ROOMS = Math.ceil(TOTAL_BOOKS / BOOKS_PER_ROOM); // ~110 rooms

        // ============================================
        // PERSISTENCE (localStorage)
        // ============================================

        const STORAGE_KEYS = {
            BOOKMARKS: 'gutenberg-library-bookmarks',
            RECENTS: 'gutenberg-library-recents',
            READING_PROGRESS: 'gutenberg-library-progress',
            METADATA_CACHE: 'gutenberg-library-meta-cache',
            SETTINGS: 'gutenberg-library-settings'
        };

        function loadFromStorage(key, defaultValue = null) {
            try {
                const stored = localStorage.getItem(key);
                return stored ? JSON.parse(stored) : defaultValue;
            } catch (e) {
                console.warn('Failed to load from storage:', key, e);
                return defaultValue;
            }
        }

        function saveToStorage(key, value) {
            try {
                localStorage.setItem(key, JSON.stringify(value));
            } catch (e) {
                console.warn('Failed to save to storage:', key, e);
            }
        }

        // Load persisted data
        let bookmarks = loadFromStorage(STORAGE_KEYS.BOOKMARKS, []);
        let recents = loadFromStorage(STORAGE_KEYS.RECENTS, []);
        let readingProgress = loadFromStorage(STORAGE_KEYS.READING_PROGRESS, {});
        let metadataCache = loadFromStorage(STORAGE_KEYS.METADATA_CACHE, {});
        let settings = loadFromStorage(STORAGE_KEYS.SETTINGS, { twoPageMode: false });

        // Book catalog cache (in-memory + persisted)
        const bookCache = new Map(Object.entries(metadataCache));

        function persistMetadataCache() {
            // Only keep last 500 entries to avoid storage bloat
            const entries = Array.from(bookCache.entries()).slice(-500);
            saveToStorage(STORAGE_KEYS.METADATA_CACHE, Object.fromEntries(entries));
        }

        // ============================================
        // BOOKMARKS & RECENTS MANAGEMENT
        // ============================================

        function addToRecents(bookId, title, authors) {
            const existing = recents.findIndex(r => r.bookId === bookId);
            if (existing !== -1) {
                recents.splice(existing, 1);
            }
            recents.unshift({
                bookId,
                title,
                authors,
                timestamp: Date.now()
            });
            recents = recents.slice(0, 20); // Keep last 20
            saveToStorage(STORAGE_KEYS.RECENTS, recents);
            updateLibraryUI();
        }

        function isBookmarked(bookId) {
            return bookmarks.some(b => b.bookId === bookId);
        }

        function addBookmark(bookId, title, authors) {
            if (isBookmarked(bookId)) return;
            bookmarks.unshift({
                bookId,
                title,
                authors,
                timestamp: Date.now()
            });
            saveToStorage(STORAGE_KEYS.BOOKMARKS, bookmarks);
            updateLibraryUI();
            showToast('Bookmark added');
        }

        function removeBookmark(bookId) {
            bookmarks = bookmarks.filter(b => b.bookId !== bookId);
            saveToStorage(STORAGE_KEYS.BOOKMARKS, bookmarks);
            updateLibraryUI();
            showToast('Bookmark removed');
        }

        window.toggleBookmark = function() {
            if (!currentBookId) return;
            const titleEl = document.getElementById('reader-title');
            const authorEl = document.getElementById('reader-author');
            
            if (isBookmarked(currentBookId)) {
                removeBookmark(currentBookId);
                document.getElementById('bookmark-btn').classList.remove('bookmarked');
            } else {
                addBookmark(currentBookId, titleEl.textContent, authorEl.textContent);
                document.getElementById('bookmark-btn').classList.add('bookmarked');
            }
        };

        function saveReadingProgress(bookId, pageIndex, totalPages) {
            readingProgress[bookId] = {
                page: pageIndex,
                total: totalPages,
                timestamp: Date.now()
            };
            saveToStorage(STORAGE_KEYS.READING_PROGRESS, readingProgress);
        }

        function getReadingProgress(bookId) {
            return readingProgress[bookId] || null;
        }

        function getLastReadBook() {
            let lastBook = null;
            let lastTime = 0;
            for (const [bookId, progress] of Object.entries(readingProgress)) {
                if (progress.timestamp > lastTime && progress.page > 0) {
                    lastTime = progress.timestamp;
                    lastBook = { bookId: parseInt(bookId), ...progress };
                }
            }
            return lastBook;
        }

        // ============================================
        // TOAST NOTIFICATIONS
        // ============================================

        function showToast(message) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            container.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // ============================================
        // GUTENBERG API FUNCTIONS (with caching & debounce)
        // ============================================

        let hoverDebounceTimer = null;
        const HOVER_DEBOUNCE_MS = 150;

        async function fetchBookMetadata(bookId) {
            if (bookCache.has(bookId)) {
                return bookCache.get(bookId);
            }
            try {
                const response = await fetch(`/.netlify/functions/gutenberg?meta=${bookId}`);
                if (!response.ok) return null;
                const data = await response.json();
                const book = {
                    id: data.id,
                    title: data.title || 'Unknown Title',
                    authors: data.authors?.map(a => a.name).join(', ') || 'Unknown Author',
                    subjects: data.subjects || [],
                };
                bookCache.set(bookId, book);
                // Persist cache occasionally
                if (bookCache.size % 10 === 0) {
                    persistMetadataCache();
                }
                return book;
            } catch (e) {
                console.error('Failed to fetch book metadata:', e);
                return null;
            }
        }

        function fetchBookMetadataDebounced(bookId, callback) {
            if (hoverDebounceTimer) {
                clearTimeout(hoverDebounceTimer);
            }
            // Return cached immediately if available
            if (bookCache.has(bookId)) {
                callback(bookCache.get(bookId));
                return;
            }
            hoverDebounceTimer = setTimeout(async () => {
                const meta = await fetchBookMetadata(bookId);
                callback(meta);
            }, HOVER_DEBOUNCE_MS);
        }

        async function fetchBookText(bookId) {
            try {
                const response = await fetch(`/.netlify/functions/gutenberg?id=${bookId}`);
                if (!response.ok) return null;
                return await response.text();
            } catch (e) {
                console.error('Failed to fetch book text:', e);
                return null;
            }
        }

        async function searchBooks(query) {
            try {
                const response = await fetch(`/.netlify/functions/gutenberg?search=${encodeURIComponent(query)}`);
                if (!response.ok) return [];
                const data = await response.json();
                // Cache the results
                if (data.results) {
                    for (const book of data.results) {
                        const cached = {
                            id: book.id,
                            title: book.title || 'Unknown Title',
                            authors: book.authors?.map(a => a.name).join(', ') || 'Unknown Author',
                            subjects: book.subjects || [],
                        };
                        bookCache.set(book.id, cached);
                    }
                    persistMetadataCache();
                }
                return data.results || [];
            } catch (e) {
                console.error('Failed to search books:', e);
                return [];
            }
        }

        // ============================================
        // DETERMINISTIC BOOK LOCATION MAPPING
        // ============================================

        function bookIdToLocation(bookId) {
            const index = bookId - 1;
            const room = Math.floor(index / BOOKS_PER_ROOM);
            const inRoom = index % BOOKS_PER_ROOM;
            const wall = Math.floor(inRoom / (BOOKS_PER_SHELF * SHELVES_PER_WALL));
            const inWall = inRoom % (BOOKS_PER_SHELF * SHELVES_PER_WALL);
            const shelf = Math.floor(inWall / BOOKS_PER_SHELF);
            const volume = inWall % BOOKS_PER_SHELF;
            return { room, wall, shelf, volume, bookId };
        }

        function locationToBookId(room, wall, shelf, volume) {
            const index = room * BOOKS_PER_ROOM +
                          wall * BOOKS_PER_SHELF * SHELVES_PER_WALL +
                          shelf * BOOKS_PER_SHELF +
                          volume;
            return index + 1;
        }

        // ============================================
        // THREE.JS SCENE SETUP
        // ============================================

        const canvas = document.getElementById('scene');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.8;

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 50);
        camera.position.set(0, 1.6, 0);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0806);
        scene.fog = new THREE.FogExp2(0x0a0806, 0.08);

        const ambientLight = new THREE.AmbientLight(0x201510, 0.4);
        scene.add(ambientLight);

        // Materials
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x2a1f15, roughness: 0.9, metalness: 0.0 });
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1208, roughness: 0.95 });
        const ceilingMaterial = new THREE.MeshStandardMaterial({ color: 0x1f1a12, roughness: 0.9 });
        const shelfMaterial = new THREE.MeshStandardMaterial({ color: 0x4a2510, roughness: 0.7 });

        const BOOK_COLORS = [
            0x8B1A1A, 0x1A3C5A, 0x2B5329, 0x4A3728, 0x3A2E4D,
            0x5C4033, 0x2D4A2D, 0x4A1A2A, 0x1A4A4A, 0x5A4A32,
            0x3D2B1F, 0x2B3D5A, 0x6B3A2A, 0x2A4A3D, 0x4D3A5A,
            0x5A3A28, 0x283A5A, 0x3A5A28, 0x5A2838, 0x38285A,
        ];

        const columnMaterial = new THREE.MeshStandardMaterial({ color: 0x2a1f15, roughness: 0.85 });
        const sharedMaterials = new Set([wallMaterial, floorMaterial, ceilingMaterial, shelfMaterial, columnMaterial]);

        // ============================================
        // BOOK HIGHLIGHTING SYSTEM
        // ============================================

        let highlightedBookInfo = null;
        let highlightStartTime = 0;
        const HIGHLIGHT_DURATION = 4000; // 4 seconds
        const HIGHLIGHT_COLOR = new THREE.Color(0xFFD700); // Gold

        function highlightBook(bookId) {
            const location = bookIdToLocation(bookId);
            highlightedBookInfo = {
                bookId,
                room: location.room,
                wall: location.wall,
                shelf: location.shelf,
                volume: location.volume
            };
            highlightStartTime = performance.now();
        }

        function clearHighlight() {
            highlightedBookInfo = null;
        }

        // ============================================
        // HEXAGONAL ROOM GEOMETRY
        // ============================================

        const R = 3;
        const ROOM_HEIGHT = 3.2;
        const CORRIDOR_LENGTH = 2.5;
        const ROOM_DEPTH = R * Math.sqrt(3) + CORRIDOR_LENGTH;

        const HEX_VERTICES = [];
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i;
            HEX_VERTICES.push(new THREE.Vector3(R * Math.cos(angle), 0, R * Math.sin(angle)));
        }

        const BOOKSHELF_WALLS = [0, 2, 3, 5];
        const SHELF_HEIGHTS = [0.3, 0.85, 1.4, 1.95, 2.5];

        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        function createFullRoom(roomIndex, offsetZ) {
            const group = new THREE.Group();
            group.position.z = offsetZ;

            // Floor
            const floorShape = new THREE.Shape();
            for (let i = 0; i <= 6; i++) {
                const angle = (Math.PI / 3) * (i % 6);
                const x = R * Math.cos(angle);
                const z = R * Math.sin(angle);
                if (i === 0) floorShape.moveTo(x, z);
                else floorShape.lineTo(x, z);
            }
            const floorGeom = new THREE.ShapeGeometry(floorShape);
            floorGeom.rotateX(-Math.PI / 2);
            const floorMesh = new THREE.Mesh(floorGeom, floorMaterial);
            group.add(floorMesh);

            // Ceiling
            const ceilGeom = floorGeom.clone();
            const ceilMesh = new THREE.Mesh(ceilGeom, ceilingMaterial);
            ceilMesh.position.y = ROOM_HEIGHT;
            ceilMesh.rotation.x = Math.PI;
            group.add(ceilMesh);

            // Bookshelf walls
            for (const wallIdx of BOOKSHELF_WALLS) {
                const va = HEX_VERTICES[wallIdx];
                const vb = HEX_VERTICES[(wallIdx + 1) % 6];
                const wallLen = va.distanceTo(vb);
                const wallGeom = new THREE.PlaneGeometry(wallLen, ROOM_HEIGHT);
                const wallMesh = new THREE.Mesh(wallGeom, wallMaterial);

                const midpoint = new THREE.Vector3((va.x + vb.x) / 2, ROOM_HEIGHT / 2, (va.z + vb.z) / 2);
                wallMesh.position.copy(midpoint);

                const center = new THREE.Vector3((va.x + vb.x) / 2, 0, (va.z + vb.z) / 2);
                const inwardAngle = Math.atan2(-center.x, -center.z);
                wallMesh.rotation.y = inwardAngle;

                group.add(wallMesh);
            }

            // Passage archways
            const PASSAGE_WALLS = [1, 4];
            for (const passIdx of PASSAGE_WALLS) {
                const va = HEX_VERTICES[passIdx];
                const vb = HEX_VERTICES[(passIdx + 1) % 6];
                const center = new THREE.Vector3((va.x + vb.x) / 2, 0, (va.z + vb.z) / 2);
                const passAngle = Math.atan2(-center.x, -center.z);

                // Top beam
                const beamGeom = new THREE.BoxGeometry(R, 0.15, 0.2);
                const beamMesh = new THREE.Mesh(beamGeom, shelfMaterial);
                beamMesh.position.set(center.x, ROOM_HEIGHT - 0.075, center.z);
                beamMesh.rotation.y = passAngle;
                group.add(beamMesh);

                // Side columns
                const colGeom = new THREE.BoxGeometry(0.15, ROOM_HEIGHT, 0.2);
                const col1 = new THREE.Mesh(colGeom, columnMaterial);
                col1.position.set(va.x, ROOM_HEIGHT / 2, va.z);
                col1.rotation.y = passAngle;
                group.add(col1);
                const col2 = new THREE.Mesh(colGeom, columnMaterial);
                col2.position.set(vb.x, ROOM_HEIGHT / 2, vb.z);
                col2.rotation.y = passAngle;
                group.add(col2);

                // Corridor
                const corridorWidth = 1.8;
                const corridorDepth = CORRIDOR_LENGTH / 2;
                const outwardDir = new THREE.Vector3(center.x, 0, center.z).normalize();
                const rightDir = new THREE.Vector3(-outwardDir.z, 0, outwardDir.x);

                const passageEdgeZ = R * Math.sqrt(3) / 2;
                const corridorCenter = center.clone().normalize().multiplyScalar(passageEdgeZ + corridorDepth / 2);

                // Corridor floor
                const corridorFloorGeom = new THREE.PlaneGeometry(corridorWidth, corridorDepth);
                const corridorFloor = new THREE.Mesh(corridorFloorGeom, floorMaterial);
                corridorFloor.rotation.x = -Math.PI / 2;
                corridorFloor.position.copy(corridorCenter);
                corridorFloor.position.y = 0;
                group.add(corridorFloor);

                // Corridor ceiling
                const corridorCeiling = new THREE.Mesh(corridorFloorGeom, ceilingMaterial);
                corridorCeiling.rotation.x = Math.PI / 2;
                corridorCeiling.position.copy(corridorCenter);
                corridorCeiling.position.y = ROOM_HEIGHT;
                group.add(corridorCeiling);

                // Corridor walls
                const corridorWallGeom = new THREE.PlaneGeometry(corridorDepth, ROOM_HEIGHT);

                const leftWallPos = corridorCenter.clone().add(rightDir.clone().multiplyScalar(-corridorWidth / 2));
                const leftWall = new THREE.Mesh(corridorWallGeom, wallMaterial);
                leftWall.position.copy(leftWallPos);
                leftWall.position.y = ROOM_HEIGHT / 2;
                leftWall.rotation.y = passAngle + Math.PI / 2;
                group.add(leftWall);

                const rightWallPos = corridorCenter.clone().add(rightDir.clone().multiplyScalar(corridorWidth / 2));
                const rightWall = new THREE.Mesh(corridorWallGeom, wallMaterial);
                rightWall.position.copy(rightWallPos);
                rightWall.position.y = ROOM_HEIGHT / 2;
                rightWall.rotation.y = passAngle - Math.PI / 2;
                group.add(rightWall);

                // Infill walls
                const gapPerSide = (R - corridorWidth) / 2;
                if (gapPerSide > 0.01) {
                    const infillGeom = new THREE.PlaneGeometry(gapPerSide, ROOM_HEIGHT);

                    const leftInfill = new THREE.Mesh(infillGeom, wallMaterial);
                    const leftInfillPos = center.clone()
                        .add(rightDir.clone().multiplyScalar(-(corridorWidth / 2 + gapPerSide / 2)));
                    leftInfill.position.copy(leftInfillPos);
                    leftInfill.position.y = ROOM_HEIGHT / 2;
                    leftInfill.rotation.y = passAngle;
                    group.add(leftInfill);

                    const rightInfill = new THREE.Mesh(infillGeom, wallMaterial);
                    const rightInfillPos = center.clone()
                        .add(rightDir.clone().multiplyScalar(corridorWidth / 2 + gapPerSide / 2));
                    rightInfill.position.copy(rightInfillPos);
                    rightInfill.position.y = ROOM_HEIGHT / 2;
                    rightInfill.rotation.y = passAngle;
                    group.add(rightInfill);
                }
            }

            // Lamps
            const lampGeom = new THREE.SphereGeometry(0.12, 16, 16);
            const lampMat = new THREE.MeshBasicMaterial({ color: 0xFFE0A0 });
            const lamp1 = new THREE.Mesh(lampGeom, lampMat);
            lamp1.position.set(0.8, ROOM_HEIGHT - 0.2, 0);
            group.add(lamp1);
            const lamp2 = new THREE.Mesh(lampGeom, lampMat);
            lamp2.position.set(-0.8, ROOM_HEIGHT - 0.2, 0);
            group.add(lamp2);

            const light1 = new THREE.PointLight(0xFFD280, 2.0, 10, 1.2);
            light1.position.copy(lamp1.position);
            group.add(light1);
            const light2 = new THREE.PointLight(0xFFD280, 2.0, 10, 1.2);
            light2.position.copy(lamp2.position);
            group.add(light2);

            // Add bookshelves with books
            const { bookMesh, bookMap, originalColors } = addBookshelves(group, roomIndex);

            return { group, bookMesh, bookMap, originalColors, lights: [light1, light2], roomIndex };
        }

        function addBookshelves(group, roomIndex) {
            const SHELF_DEPTH = 0.25;
            const SHELF_THICKNESS = 0.02;

            // Shelf planks
            for (const wallIdx of BOOKSHELF_WALLS) {
                const va = HEX_VERTICES[wallIdx];
                const vb = HEX_VERTICES[(wallIdx + 1) % 6];
                const wallCenter = new THREE.Vector3((va.x + vb.x) / 2, 0, (va.z + vb.z) / 2);
                const inwardDir = new THREE.Vector3(-wallCenter.x, 0, -wallCenter.z).normalize();

                for (let s = 0; s < SHELF_HEIGHTS.length; s++) {
                    const shelfGeom = new THREE.BoxGeometry(R - 0.1, SHELF_THICKNESS, SHELF_DEPTH);
                    const shelfMesh = new THREE.Mesh(shelfGeom, shelfMaterial);

                    const shelfPos = wallCenter.clone().add(inwardDir.clone().multiplyScalar(SHELF_DEPTH / 2 + 0.02));
                    shelfPos.y = SHELF_HEIGHTS[s];
                    shelfMesh.position.copy(shelfPos);
                    shelfMesh.rotation.y = Math.atan2(-wallCenter.x, -wallCenter.z);
                    group.add(shelfMesh);
                }
            }

            // Books as instanced mesh
            const totalBooks = BOOKSHELF_WALLS.length * SHELF_HEIGHTS.length * BOOKS_PER_SHELF;
            const bookGeom = new THREE.BoxGeometry(0.07, 0.20, 0.18);
            const bookMat = new THREE.MeshStandardMaterial({ roughness: 0.6, metalness: 0.05 });
            const bookMesh = new THREE.InstancedMesh(bookGeom, bookMat, totalBooks);

            const bookMap = [];
            const originalColors = new Float32Array(totalBooks * 3);
            let instanceId = 0;
            const matrix = new THREE.Matrix4();
            const color = new THREE.Color();

            for (let w = 0; w < BOOKSHELF_WALLS.length; w++) {
                const wallIdx = BOOKSHELF_WALLS[w];
                const va = HEX_VERTICES[wallIdx];
                const vb = HEX_VERTICES[(wallIdx + 1) % 6];
                const wallCenter = new THREE.Vector3((va.x + vb.x) / 2, 0, (va.z + vb.z) / 2);
                const wallDir = new THREE.Vector3().subVectors(vb, va).normalize();
                const inwardDir = new THREE.Vector3(-wallCenter.x, 0, -wallCenter.z).normalize();
                const wallAngle = Math.atan2(-wallCenter.x, -wallCenter.z);

                for (let s = 0; s < SHELF_HEIGHTS.length; s++) {
                    for (let v = 0; v < BOOKS_PER_SHELF; v++) {
                        const slot = v - BOOKS_PER_SHELF / 2;
                        const slotWidth = (R - 0.2) / BOOKS_PER_SHELF;

                        const bookPos = wallCenter.clone()
                            .add(wallDir.clone().multiplyScalar(slot * slotWidth))
                            .add(inwardDir.clone().multiplyScalar(0.18));

                        const bookId = locationToBookId(roomIndex, w, s, v);
                        const seed = bookId;
                        const bookHeight = 0.18 + seededRandom(seed) * 0.06;
                        bookPos.y = SHELF_HEIGHTS[s] + SHELF_THICKNESS / 2 + bookHeight / 2;

                        matrix.identity();
                        matrix.makeRotationY(wallAngle);
                        matrix.setPosition(bookPos);
                        matrix.scale(new THREE.Vector3(1, bookHeight / 0.20, 1));
                        bookMesh.setMatrixAt(instanceId, matrix);

                        const colorIndex = bookId % BOOK_COLORS.length;
                        color.setHex(BOOK_COLORS[colorIndex]);
                        bookMesh.setColorAt(instanceId, color);
                        
                        // Store original color
                        originalColors[instanceId * 3] = color.r;
                        originalColors[instanceId * 3 + 1] = color.g;
                        originalColors[instanceId * 3 + 2] = color.b;

                        bookMap.push({ wall: w, shelf: s, vol: v, bookId, instanceId });
                        instanceId++;
                    }
                }
            }

            bookMesh.instanceMatrix.needsUpdate = true;
            bookMesh.instanceColor.needsUpdate = true;
            group.add(bookMesh);

            return { bookMesh, bookMap, originalColors };
        }

        // ============================================
        // ROOM MANAGEMENT
        // ============================================

        let currentRoomIndex = 0;
        const rooms = new Map();

        function disposeRoom(room) {
            scene.remove(room.group);
            room.group.traverse((obj) => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material && !sharedMaterials.has(obj.material)) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => { if (!sharedMaterials.has(mat)) mat.dispose(); });
                    } else {
                        obj.material.dispose();
                    }
                }
            });
        }

        function clearAllRooms() {
            for (const [idx, room] of rooms) {
                disposeRoom(room);
            }
            rooms.clear();
        }

        function teleportTo(roomIndex, callback, highlightBookId = null) {
            roomIndex = Math.max(0, Math.min(TOTAL_ROOMS - 1, roomIndex));
            const fade = document.getElementById('transition-fade');
            fade.classList.add('active');
            setTimeout(() => {
                currentRoomIndex = roomIndex;
                camera.position.set(0, 1.6, 0);
                clearAllRooms();
                updateRooms();
                updateHUD();
                
                // Start highlight if requested
                if (highlightBookId) {
                    highlightBook(highlightBookId);
                }
                
                setTimeout(() => {
                    fade.classList.remove('active');
                    if (callback) callback();
                }, 100);
            }, 300);
        }

        function updateRooms() {
            const needed = new Set();
            for (let offset = -2; offset <= 2; offset++) {
                const idx = currentRoomIndex + offset;
                if (idx >= 0 && idx < TOTAL_ROOMS) {
                    needed.add(idx);
                }
            }

            // Remove unneeded rooms
            for (const [idx, room] of rooms) {
                if (!needed.has(idx)) {
                    disposeRoom(room);
                    rooms.delete(idx);
                }
            }

            // Add needed rooms
            for (const idx of needed) {
                if (!rooms.has(idx)) {
                    const offsetZ = (idx - currentRoomIndex) * ROOM_DEPTH;
                    const roomData = createFullRoom(idx, offsetZ);
                    scene.add(roomData.group);
                    rooms.set(idx, roomData);
                }
            }
        }

        function checkRoomTransition() {
            const localZ = camera.position.z;
            const halfDepth = ROOM_DEPTH / 2;

            if (localZ > halfDepth && currentRoomIndex < TOTAL_ROOMS - 1) {
                currentRoomIndex++;
                camera.position.z -= ROOM_DEPTH;
                for (const [idx, room] of rooms) {
                    room.group.position.z -= ROOM_DEPTH;
                }
                updateRooms();
                updateHUD();
            } else if (localZ < -halfDepth && currentRoomIndex > 0) {
                currentRoomIndex--;
                camera.position.z += ROOM_DEPTH;
                for (const [idx, room] of rooms) {
                    room.group.position.z += ROOM_DEPTH;
                }
                updateRooms();
                updateHUD();
            }
        }

        // ============================================
        // POINTER LOCK CONTROLS
        // ============================================

        const controls = new PointerLockControls(camera, document.body);

        let readerOpen = false;
        let searchOpen = false;
        let navOpen = false;
        let aboutOpen = false;
        let libraryOpen = false;
        let introHidden = false;

        canvas.addEventListener('click', (e) => {
            if (!readerOpen && !searchOpen && !navOpen && !aboutOpen && !libraryOpen && introHidden) {
                controls.lock();
            }
        });

        controls.addEventListener('lock', () => {
            document.getElementById('crosshair').classList.add('visible');
            document.getElementById('instructions').classList.add('hidden');
        });

        controls.addEventListener('unlock', () => {
            document.getElementById('crosshair').classList.remove('visible');
            if (introHidden && !readerOpen && !searchOpen && !navOpen && !aboutOpen && !libraryOpen) {
                document.getElementById('instructions').classList.remove('hidden');
            }
        });

        // ============================================
        // MOVEMENT
        // ============================================

        const moveSpeed = 3.0;
        const keys = { forward: false, backward: false, left: false, right: false };

        window.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': keys.forward = true; break;
                case 'KeyS': if (controls.isLocked) keys.backward = true; break;
                case 'KeyA': keys.left = true; break;
                case 'KeyD': keys.right = true; break;
            }
        });

        window.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': keys.forward = false; break;
                case 'KeyS': keys.backward = false; break;
                case 'KeyA': keys.left = false; break;
                case 'KeyD': keys.right = false; break;
            }
        });

        // Collision detection
        const passageEdgeZ = R * Math.sqrt(3) / 2;
        const corridorHalfW = 0.9;
        const corridorEnd = passageEdgeZ + CORRIDOR_LENGTH / 2;

        const CORRIDOR_WALLS = [
            [corridorHalfW, passageEdgeZ, corridorHalfW, corridorEnd],
            [-corridorHalfW, passageEdgeZ, -corridorHalfW, corridorEnd],
            [-corridorHalfW, -passageEdgeZ, -corridorHalfW, -corridorEnd],
            [corridorHalfW, -passageEdgeZ, corridorHalfW, -corridorEnd],
            [corridorHalfW, passageEdgeZ, R / 2, passageEdgeZ],
            [-corridorHalfW, passageEdgeZ, -R / 2, passageEdgeZ],
            [corridorHalfW, -passageEdgeZ, R / 2, -passageEdgeZ],
            [-corridorHalfW, -passageEdgeZ, -R / 2, -passageEdgeZ],
        ];

        function checkSegmentCollision(pos, ax, az, bx, bz, minDist) {
            const dx = bx - ax, dz = bz - az;
            const len = Math.sqrt(dx * dx + dz * dz);
            if (len < 0.001) return;
            const nx = dx / len, nz = dz / len;
            const toCamX = pos.x - ax, toCamZ = pos.z - az;
            const proj = Math.max(0, Math.min(len, toCamX * nx + toCamZ * nz));
            const closeX = ax + nx * proj, closeZ = az + nz * proj;
            const dist = Math.sqrt((pos.x - closeX) ** 2 + (pos.z - closeZ) ** 2);
            if (dist < minDist && dist > 0.001) {
                const px = (pos.x - closeX) / dist, pz = (pos.z - closeZ) / dist;
                pos.x = closeX + px * minDist;
                pos.z = closeZ + pz * minDist;
            }
        }

        function applyCollision() {
            const pos = camera.position;
            const minDist = 0.35;

            for (const wallIdx of BOOKSHELF_WALLS) {
                const va = HEX_VERTICES[wallIdx];
                const vb = HEX_VERTICES[(wallIdx + 1) % 6];
                checkSegmentCollision(pos, va.x, va.z, vb.x, vb.z, minDist);
            }

            for (const seg of CORRIDOR_WALLS) {
                checkSegmentCollision(pos, seg[0], seg[1], seg[2], seg[3], minDist);
            }
        }

        // ============================================
        // RAYCASTING FOR BOOK SELECTION
        // ============================================

        const raycaster = new THREE.Raycaster();
        raycaster.far = 3;

        let hoveredBookId = null;

        document.addEventListener('click', async (event) => {
            if (!controls.isLocked) return;

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            for (const [idx, room] of rooms) {
                const intersects = raycaster.intersectObject(room.bookMesh);
                if (intersects.length > 0) {
                    const instanceId = intersects[0].instanceId;
                    const bookInfo = room.bookMap[instanceId];
                    openBook(bookInfo.bookId);
                    controls.unlock();
                    return;
                }
            }
        });

        // ============================================
        // BOOK READER UI
        // ============================================

        let currentBookId = null;
        let currentBookPages = [];
        let currentPageIndex = 0;
        let twoPageMode = settings.twoPageMode || false;
        const textCache = new Map();

        function paginateText(text) {
            const lines = text.split('\n');
            const perPage = twoPageMode ? 35 : 40;
            const pages = [];
            for (let i = 0; i < lines.length; i += perPage) {
                pages.push(lines.slice(i, i + perPage).join('\n'));
            }
            return pages.length ? pages : [''];
        }

        function renderPage() {
            const contentEl = document.getElementById('reader-content');
            const pageNumEl = document.getElementById('reader-page-num');
            const prevBtn = document.getElementById('prev-page-btn');
            const nextBtn = document.getElementById('next-page-btn');

            const total = currentBookPages.length || 1;
            const idx = Math.max(0, Math.min(currentPageIndex, total - 1));
            currentPageIndex = idx;

            contentEl.classList.remove('loading');
            contentEl.classList.add('page-flip');
            requestAnimationFrame(() => contentEl.classList.remove('page-flip'));

            contentEl.textContent = currentBookPages[idx] || '';
            
            if (twoPageMode) {
                pageNumEl.textContent = `Page ${idx + 1}`;
                const rightContent = document.getElementById('reader-content-right');
                const rightPageNum = document.getElementById('reader-page-num-right');
                if (idx + 1 < total) {
                    rightContent.textContent = currentBookPages[idx + 1] || '';
                    rightPageNum.textContent = `Page ${idx + 2}`;
                    document.getElementById('reader-page-right').classList.add('visible');
                } else {
                    rightContent.textContent = '';
                    rightPageNum.textContent = '';
                    document.getElementById('reader-page-right').classList.remove('visible');
                }
                prevBtn.disabled = idx === 0;
                nextBtn.disabled = idx >= total - 2;
            } else {
                pageNumEl.textContent = `Page ${idx + 1} of ${total}`;
                document.getElementById('reader-page-right').classList.remove('visible');
                prevBtn.disabled = idx === 0;
                nextBtn.disabled = idx >= total - 1;
            }

            // Save reading progress
            if (currentBookId) {
                saveReadingProgress(currentBookId, idx, total);
            }
        }

        window.toggleTwoPage = function() {
            twoPageMode = !twoPageMode;
            settings.twoPageMode = twoPageMode;
            saveToStorage(STORAGE_KEYS.SETTINGS, settings);
            
            const btn = document.getElementById('two-page-btn');
            btn.classList.toggle('active', twoPageMode);
            
            const leftPage = document.getElementById('reader-page-left');
            leftPage.classList.toggle('two-page-mode', twoPageMode);
            
            // Re-paginate current book
            if (textCache.has(currentBookId)) {
                const text = textCache.get(currentBookId);
                const cleanText = text.replace(/\r\n/g, '\n').replace(/\n{4,}/g, '\n\n\n');
                currentBookPages = paginateText(cleanText);
                // Adjust page index for two-page mode
                if (twoPageMode) {
                    currentPageIndex = Math.floor(currentPageIndex / 2) * 2;
                }
                renderPage();
            }
        };

        window.nextPage = function() {
            if (!readerOpen) return;
            const step = twoPageMode ? 2 : 1;
            if (currentPageIndex < (currentBookPages.length - step)) {
                currentPageIndex += step;
                renderPage();
            }
        };

        window.prevPage = function() {
            if (!readerOpen) return;
            const step = twoPageMode ? 2 : 1;
            if (currentPageIndex >= step) {
                currentPageIndex -= step;
                renderPage();
            }
        };

        window.openBook = async function(bookId, resumePage = null) {
            currentBookId = bookId;
            readerOpen = true;

            const location = bookIdToLocation(bookId);

            document.getElementById('reader-title').textContent = 'Loading...';
            document.getElementById('reader-author').textContent = '';
            document.getElementById('reader-coords').textContent = `Room ${location.room + 1} Â· Wall ${location.wall + 1} Â· Shelf ${location.shelf + 1} Â· Volume ${location.volume + 1}`;
            document.getElementById('reader-content').textContent = 'Loading book text...';
            document.getElementById('reader-content').classList.add('loading');
            document.getElementById('reader-gutenberg-link').href = `https://www.gutenberg.org/ebooks/${bookId}`;
            document.getElementById('reader').classList.add('visible');
            
            // Update bookmark button state
            document.getElementById('bookmark-btn').classList.toggle('bookmarked', isBookmarked(bookId));
            
            // Update two-page button state
            document.getElementById('two-page-btn').classList.toggle('active', twoPageMode);
            document.getElementById('reader-page-left').classList.toggle('two-page-mode', twoPageMode);

            // Fetch metadata
            const meta = await fetchBookMetadata(bookId);
            if (meta) {
                document.getElementById('reader-title').textContent = meta.title;
                document.getElementById('reader-author').textContent = meta.authors;
                // Add to recents
                addToRecents(bookId, meta.title, meta.authors);
            } else {
                document.getElementById('reader-title').textContent = `Book #${bookId}`;
                document.getElementById('reader-author').textContent = '';
                addToRecents(bookId, `Book #${bookId}`, '');
            }

            // Fetch text (with cache)
            let text = textCache.get(bookId);
            if (!text) {
                text = await fetchBookText(bookId);
                if (text) textCache.set(bookId, text);
            }

            if (text) {
                const cleanText = text.replace(/\r\n/g, '\n').replace(/\n{4,}/g, '\n\n\n');
                currentBookPages = paginateText(cleanText);
                
                // Resume from saved progress or specified page
                if (resumePage !== null) {
                    currentPageIndex = resumePage;
                } else {
                    const progress = getReadingProgress(bookId);
                    currentPageIndex = progress ? progress.page : 0;
                }
                
                renderPage();
            } else {
                currentBookPages = ['Unable to load book text. The book may not be available in plain text format.'];
                currentPageIndex = 0;
                renderPage();
            }
        };

        window.closeBook = function() {
            document.getElementById('reader').classList.remove('visible');
            document.getElementById('reader-page-right').classList.remove('visible');
            readerOpen = false;
            currentBookId = null;
            currentBookPages = [];
            currentPageIndex = 0;
        };

        // ============================================
        // SEARCH UI
        // ============================================

        window.openSearch = function() {
            document.getElementById('search-panel').classList.add('visible');
            searchOpen = true;
            controls.unlock();
            setTimeout(() => {
                document.getElementById('search-input').focus();
            }, 300);
        };

        window.closeSearch = function() {
            document.getElementById('search-panel').classList.remove('visible');
            searchOpen = false;
        };

        window.performSearch = async function() {
            const query = document.getElementById('search-input').value.trim();
            if (!query) return;

            const resultsDiv = document.getElementById('search-results');
            resultsDiv.innerHTML = '<div class="loading-spinner"></div> Searching...';

            const results = await searchBooks(query);

            if (results.length === 0) {
                resultsDiv.innerHTML = '<p style="color:#8b7355;">No books found.</p>';
                return;
            }

            resultsDiv.innerHTML = results.slice(0, 10).map(book => {
                const location = bookIdToLocation(book.id);
                const authors = book.authors?.map(a => a.name).join(', ') || 'Unknown Author';
                const progress = getReadingProgress(book.id);
                const progressText = progress ? `Progress: Page ${progress.page + 1} of ${progress.total}` : '';
                return `
                    <div class="search-result-item" onclick="goToBook(${book.id})">
                        <div class="search-result-title">${escapeHtml(book.title)}</div>
                        <div class="search-result-author">${escapeHtml(authors)}</div>
                        <div class="search-result-location">Room ${location.room + 1} Â· Wall ${location.wall + 1} Â· Shelf ${location.shelf + 1}</div>
                        ${progressText ? `<div class="search-result-progress">${progressText}</div>` : ''}
                    </div>
                `;
            }).join('');
        };

        window.jumpToGutenbergId = function() {
            const bookId = parseInt(document.getElementById('search-gutenberg-id').value);
            if (!bookId || bookId < 1 || bookId > TOTAL_BOOKS) {
                showToast('Please enter a valid Gutenberg ID (1-70000)');
                return;
            }
            closeSearch();
            const location = bookIdToLocation(bookId);
            teleportTo(location.room, () => {
                openBook(bookId);
            }, bookId);
        };

        window.goToBook = function(bookId) {
            const location = bookIdToLocation(bookId);
            closeSearch();
            teleportTo(location.room, () => {
                openBook(bookId);
            }, bookId);
        };

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============================================
        // NAVIGATION UI
        // ============================================

        window.openNav = function() {
            document.getElementById('nav-panel').classList.add('visible');
            navOpen = true;
            controls.unlock();
        };

        window.closeNav = function() {
            document.getElementById('nav-panel').classList.remove('visible');
            navOpen = false;
        };

        window.navigateToCoords = function() {
            const room = parseInt(document.getElementById('nav-room').value) - 1 || 0;
            const wall = parseInt(document.getElementById('nav-wall').value) - 1 || 0;
            const shelf = parseInt(document.getElementById('nav-shelf').value) - 1 || 0;
            const vol = parseInt(document.getElementById('nav-vol').value) - 1 || 0;

            if (room < 0 || room >= TOTAL_ROOMS || wall < 0 || wall >= 4 ||
                shelf < 0 || shelf >= 5 || vol < 0 || vol >= 32) {
                return;
            }

            const bookId = locationToBookId(room, wall, shelf, vol);
            closeNav();
            teleportTo(room, () => {
                openBook(bookId);
            }, bookId);
        };

        window.navigateToGutenbergId = function() {
            const bookId = parseInt(document.getElementById('nav-gutenberg-id').value);
            if (!bookId || bookId < 1 || bookId > TOTAL_BOOKS) return;

            const location = bookIdToLocation(bookId);
            closeNav();
            teleportTo(location.room, () => {
                openBook(bookId);
            }, bookId);
        };

        // ============================================
        // MY LIBRARY PANEL
        // ============================================

        window.openLibrary = function() {
            document.getElementById('library-panel').classList.add('visible');
            libraryOpen = true;
            controls.unlock();
            updateLibraryUI();
        };

        window.closeLibrary = function() {
            document.getElementById('library-panel').classList.remove('visible');
            libraryOpen = false;
        };

        function updateLibraryUI() {
            // Continue reading banner
            const continueSection = document.getElementById('continue-reading-section');
            const lastBook = getLastReadBook();
            if (lastBook && lastBook.page > 0) {
                const meta = bookCache.get(lastBook.bookId);
                const title = meta?.title || `Book #${lastBook.bookId}`;
                const percent = Math.round((lastBook.page / lastBook.total) * 100);
                continueSection.innerHTML = `
                    <div class="continue-reading-banner" onclick="continueReading(${lastBook.bookId}, ${lastBook.page})">
                        <div class="continue-reading-label">Continue Reading</div>
                        <div class="continue-reading-title">${escapeHtml(title)}</div>
                        <div class="continue-reading-progress">Page ${lastBook.page + 1} of ${lastBook.total} (${percent}%)</div>
                    </div>
                `;
            } else {
                continueSection.innerHTML = '';
            }
            
            // Update indicator
            const hasContent = bookmarks.length > 0 || recents.length > 0 || lastBook;
            const indicator = document.querySelector('#library-btn .indicator');
            if (indicator) {
                indicator.style.display = hasContent ? 'block' : 'none';
            }

            // Bookmarks
            const bookmarksList = document.getElementById('bookmarks-list');
            if (bookmarks.length === 0) {
                bookmarksList.innerHTML = '<div class="empty-state">No bookmarks yet. Open a book and click ðŸ”– to add one.</div>';
            } else {
                bookmarksList.innerHTML = bookmarks.map(b => {
                    const location = bookIdToLocation(b.bookId);
                    const progress = getReadingProgress(b.bookId);
                    const progressText = progress ? `Page ${progress.page + 1} of ${progress.total}` : '';
                    return `
                        <div class="bookmark-item" onclick="goToBookFromLibrary(${b.bookId})">
                            <button class="bookmark-remove" onclick="event.stopPropagation(); removeBookmarkFromUI(${b.bookId})">&times;</button>
                            <div class="search-result-title">${escapeHtml(b.title)}</div>
                            <div class="search-result-author">${escapeHtml(b.authors)}</div>
                            <div class="search-result-location">Room ${location.room + 1} Â· Wall ${location.wall + 1} Â· Shelf ${location.shelf + 1}</div>
                            ${progressText ? `<div class="search-result-progress">${progressText}</div>` : ''}
                        </div>
                    `;
                }).join('');
            }

            // Recents
            const recentsList = document.getElementById('recents-list');
            if (recents.length === 0) {
                recentsList.innerHTML = '<div class="empty-state">No recent books. Start exploring!</div>';
            } else {
                recentsList.innerHTML = recents.map(r => {
                    const location = bookIdToLocation(r.bookId);
                    const progress = getReadingProgress(r.bookId);
                    const progressText = progress ? `Page ${progress.page + 1} of ${progress.total}` : '';
                    return `
                        <div class="recent-item" onclick="goToBookFromLibrary(${r.bookId})">
                            <div class="search-result-title">${escapeHtml(r.title)}</div>
                            <div class="search-result-author">${escapeHtml(r.authors)}</div>
                            <div class="search-result-location">Room ${location.room + 1} Â· Wall ${location.wall + 1} Â· Shelf ${location.shelf + 1}</div>
                            ${progressText ? `<div class="search-result-progress">${progressText}</div>` : ''}
                        </div>
                    `;
                }).join('');
            }
        }

        window.goToBookFromLibrary = function(bookId) {
            closeLibrary();
            const location = bookIdToLocation(bookId);
            teleportTo(location.room, () => {
                openBook(bookId);
            }, bookId);
        };

        window.continueReading = function(bookId, page) {
            closeLibrary();
            const location = bookIdToLocation(bookId);
            teleportTo(location.room, () => {
                openBook(bookId, page);
            }, bookId);
        };

        window.removeBookmarkFromUI = function(bookId) {
            removeBookmark(bookId);
        };

        // Panel tabs
        document.querySelectorAll('.panel-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(`${tabName}-tab`).classList.add('active');
            });
        });

        // ============================================
        // RANDOM ROOM
        // ============================================

        window.randomRoom = function() {
            const randomRoomIdx = Math.floor(Math.random() * TOTAL_ROOMS);
            teleportTo(randomRoomIdx);
        };

        // ============================================
        // ABOUT MODAL
        // ============================================

        window.openAbout = function() {
            document.getElementById('about-overlay').classList.add('visible');
            document.getElementById('about-modal').classList.add('visible');
            aboutOpen = true;
            controls.unlock();
        };

        window.closeAbout = function() {
            document.getElementById('about-overlay').classList.remove('visible');
            document.getElementById('about-modal').classList.remove('visible');
            aboutOpen = false;
        };

        // ============================================
        // HUD UPDATE
        // ============================================

        function updateHUD() {
            const startBook = currentRoomIndex * BOOKS_PER_ROOM + 1;
            const endBook = Math.min((currentRoomIndex + 1) * BOOKS_PER_ROOM, TOTAL_BOOKS);
            document.getElementById('hud-coords').textContent = `Room ${currentRoomIndex + 1} of ${TOTAL_ROOMS}`;
            document.getElementById('hud-info').textContent = `Books #${startBook.toLocaleString()} â€“ #${endBook.toLocaleString()} Â· ${BOOKS_PER_ROOM} books per room`;
        }

        // ============================================
        // BRIGHTNESS CONTROL
        // ============================================

        const brightnessSlider = document.getElementById('brightness-slider');
        brightnessSlider.addEventListener('input', (e) => {
            renderer.toneMappingExposure = e.target.value / 100;
        });

        // ============================================
        // INTRO SEQUENCE
        // ============================================

        const intro = document.getElementById('intro');
        intro.addEventListener('click', () => {
            if (intro.classList.contains('hidden')) return;
            intro.classList.add('hidden');
            introHidden = true;
            setTimeout(() => {
                intro.style.display = 'none';
            }, 1500);
        });

        // ============================================
        // ANIMATION LOOP
        // ============================================

        const clock = new THREE.Clock();
        let hoveredBook = null;
        const tempColor = new THREE.Color();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            const now = performance.now();

            if (controls.isLocked) {
                const direction = new THREE.Vector3();
                if (keys.forward) direction.z -= 1;
                if (keys.backward) direction.z += 1;
                if (keys.left) direction.x -= 1;
                if (keys.right) direction.x += 1;

                if (direction.length() > 0) {
                    direction.normalize();

                    const moveDir = direction.clone();
                    moveDir.applyQuaternion(camera.quaternion);
                    moveDir.y = 0;
                    moveDir.normalize();

                    camera.position.add(moveDir.multiplyScalar(moveSpeed * delta));

                    applyCollision();
                    checkRoomTransition();
                }

                // Book hover highlight
                if (hoveredBook) {
                    hoveredBook.mesh.setColorAt(hoveredBook.instanceId, hoveredBook.originalColor);
                    hoveredBook.mesh.instanceColor.needsUpdate = true;
                    hoveredBook = null;
                    document.getElementById('crosshair').style.borderColor = 'rgba(212, 197, 160, 0.5)';
                    document.getElementById('book-tooltip').classList.remove('visible');
                }

                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                for (const [idx, room] of rooms) {
                    const intersects = raycaster.intersectObject(room.bookMesh);
                    if (intersects.length > 0) {
                        const instanceId = intersects[0].instanceId;
                        const bookInfo = room.bookMap[instanceId];
                        room.bookMesh.getColorAt(instanceId, tempColor);

                        hoveredBook = {
                            mesh: room.bookMesh,
                            instanceId: instanceId,
                            originalColor: tempColor.clone()
                        };

                        // Brighten the book
                        tempColor.multiplyScalar(1.5);
                        room.bookMesh.setColorAt(instanceId, tempColor);
                        room.bookMesh.instanceColor.needsUpdate = true;
                        document.getElementById('crosshair').style.borderColor = 'rgba(196, 148, 58, 0.9)';

                        // Show tooltip with book info (debounced fetch)
                        if (hoveredBookId !== bookInfo.bookId) {
                            hoveredBookId = bookInfo.bookId;
                            const tooltip = document.getElementById('book-tooltip');
                            tooltip.querySelector('.title').textContent = `Book #${bookInfo.bookId}`;
                            tooltip.querySelector('.author').textContent = 'Click to read';
                            tooltip.classList.add('visible');

                            // Fetch actual metadata with debouncing
                            fetchBookMetadataDebounced(bookInfo.bookId, (meta) => {
                                if (meta && hoveredBookId === bookInfo.bookId) {
                                    tooltip.querySelector('.title').textContent = meta.title;
                                    tooltip.querySelector('.author').textContent = meta.authors;
                                }
                            });
                        }
                        break;
                    }
                }

                if (!hoveredBook) {
                    hoveredBookId = null;
                }
            }

            // Update book highlighting (search/teleport target glow)
            if (highlightedBookInfo) {
                const elapsed = now - highlightStartTime;
                if (elapsed > HIGHLIGHT_DURATION) {
                    // Restore original color and clear highlight
                    const room = rooms.get(highlightedBookInfo.room);
                    if (room) {
                        const bookEntry = room.bookMap.find(b => b.bookId === highlightedBookInfo.bookId);
                        if (bookEntry) {
                            const origR = room.originalColors[bookEntry.instanceId * 3];
                            const origG = room.originalColors[bookEntry.instanceId * 3 + 1];
                            const origB = room.originalColors[bookEntry.instanceId * 3 + 2];
                            tempColor.setRGB(origR, origG, origB);
                            room.bookMesh.setColorAt(bookEntry.instanceId, tempColor);
                            room.bookMesh.instanceColor.needsUpdate = true;
                        }
                    }
                    clearHighlight();
                } else {
                    // Pulsing glow effect
                    const room = rooms.get(highlightedBookInfo.room);
                    if (room) {
                        const bookEntry = room.bookMap.find(b => b.bookId === highlightedBookInfo.bookId);
                        if (bookEntry) {
                            const pulse = Math.sin(elapsed * 0.008) * 0.5 + 0.5; // 0-1 pulsing
                            const origR = room.originalColors[bookEntry.instanceId * 3];
                            const origG = room.originalColors[bookEntry.instanceId * 3 + 1];
                            const origB = room.originalColors[bookEntry.instanceId * 3 + 2];
                            
                            // Blend between original color and gold highlight
                            tempColor.setRGB(
                                origR + (HIGHLIGHT_COLOR.r - origR) * pulse * 0.7,
                                origG + (HIGHLIGHT_COLOR.g - origG) * pulse * 0.7,
                                origB + (HIGHLIGHT_COLOR.b - origB) * pulse * 0.7
                            );
                            room.bookMesh.setColorAt(bookEntry.instanceId, tempColor);
                            room.bookMesh.instanceColor.needsUpdate = true;
                        }
                    }
                }
            }

            // Light flicker effect
            for (const [idx, room] of rooms) {
                if (room.lights) {
                    const seed1 = room.roomIndex * 7;
                    const seed2 = room.roomIndex * 11;

                    const flicker1 = Math.sin(elapsedTime * 2.3 + seed1) * 0.08
                                   + Math.sin(elapsedTime * 4.7 + seed1 * 2) * 0.05;
                    const flicker2 = Math.sin(elapsedTime * 2.1 + seed2) * 0.08
                                   + Math.sin(elapsedTime * 5.1 + seed2 * 2) * 0.05;

                    room.lights[0].intensity = 2.0 + flicker1;
                    room.lights[1].intensity = 2.0 + flicker2;
                }
            }

            updateParticles(delta);
            renderer.render(scene, camera);
        }

        // ============================================
        // ATMOSPHERIC DUST PARTICLES
        // ============================================

        const PARTICLE_COUNT = 300;
        const particlePositions = new Float32Array(PARTICLE_COUNT * 3);
        const particleVelocities = [];
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            particlePositions[i * 3] = (Math.random() - 0.5) * 24;
            particlePositions[i * 3 + 1] = Math.random() * ROOM_HEIGHT;
            particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 24;
            particleVelocities.push(
                (Math.random() - 0.5) * 0.015,
                (Math.random() - 0.5) * 0.008,
                (Math.random() - 0.5) * 0.015
            );
        }
        const particleGeom = new THREE.BufferGeometry();
        particleGeom.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        const particleMat = new THREE.PointsMaterial({
            color: 0xFFD280,
            size: 0.015,
            transparent: true,
            opacity: 0.25,
            sizeAttenuation: true,
        });
        const dustParticles = new THREE.Points(particleGeom, particleMat);
        scene.add(dustParticles);

        function updateParticles(delta) {
            const positions = dustParticles.geometry.attributes.position.array;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                positions[i * 3] += particleVelocities[i * 3] * delta * 60;
                positions[i * 3 + 1] += particleVelocities[i * 3 + 1] * delta * 60;
                positions[i * 3 + 2] += particleVelocities[i * 3 + 2] * delta * 60;

                const dx = positions[i * 3] - camera.position.x;
                const dz = positions[i * 3 + 2] - camera.position.z;
                if (Math.abs(dx) > 12) positions[i * 3] = camera.position.x + (Math.random() - 0.5) * 20;
                if (Math.abs(dz) > 12) positions[i * 3 + 2] = camera.position.z + (Math.random() - 0.5) * 20;
                if (positions[i * 3 + 1] > ROOM_HEIGHT) positions[i * 3 + 1] = 0;
                if (positions[i * 3 + 1] < 0) positions[i * 3 + 1] = ROOM_HEIGHT;
            }
            dustParticles.geometry.attributes.position.needsUpdate = true;
        }

        // ============================================
        // KEYBOARD SHORTCUTS
        // ============================================

        window.addEventListener('keydown', (e) => {
            if (readerOpen) {
                if (e.code === 'Escape') { closeBook(); }
                if (e.code === 'ArrowRight' || e.code === 'ArrowDown') { e.preventDefault(); nextPage(); }
                if (e.code === 'ArrowLeft' || e.code === 'ArrowUp') { e.preventDefault(); prevPage(); }
                if (e.code === 'KeyB') { toggleBookmark(); }
            } else if (searchOpen) {
                if (e.code === 'Escape') { closeSearch(); }
                if (e.code === 'Enter' && (e.target.id === 'search-input' || e.target.id === 'search-gutenberg-id')) {
                    e.preventDefault();
                    if (e.target.id === 'search-gutenberg-id') {
                        jumpToGutenbergId();
                    } else {
                        performSearch();
                    }
                }
            } else if (navOpen) {
                if (e.code === 'Escape') { closeNav(); }
            } else if (libraryOpen) {
                if (e.code === 'Escape') { closeLibrary(); }
            } else if (aboutOpen) {
                if (e.code === 'Escape') { closeAbout(); }
            }
        });

        // ============================================
        // WINDOW RESIZE
        // ============================================

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ============================================
        // INITIALIZATION
        // ============================================

        updateRooms();
        updateHUD();
        updateLibraryUI();
        animate();
    </script>
</body>
</html>
