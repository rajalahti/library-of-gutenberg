<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A digital library filled with real books from Project Gutenberg. Walk through hexagonal rooms and read classic literature.">
    <title>The Library of Gutenberg</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìö</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=IBM+Plex+Mono:wght@400;500&family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Cormorant Garamond', serif;
            background: #0a0806;
            color: #d4c5a0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #scene {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.7) 100%);
            pointer-events: none;
            z-index: 2;
        }

        #transition-fade {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0806;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        #transition-fade.active {
            opacity: 1;
        }

        #title-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 12px 20px;
            font-size: 13px;
            letter-spacing: 4px;
            color: rgba(139, 115, 85, 0.5);
            z-index: 3;
            background: linear-gradient(to bottom, rgba(10,8,6,0.5) 0%, transparent 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #title-bar > * {
            pointer-events: auto;
        }

        .title-bar-controls {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        #brightness-slider, #volume-slider {
            width: 60px;
            height: 3px;
            -webkit-appearance: none;
            appearance: none;
            background: #4a3520;
            outline: none;
            opacity: 0.7;
            vertical-align: middle;
            cursor: pointer;
            border-radius: 2px;
        }

        #brightness-slider:hover, #volume-slider:hover {
            opacity: 1;
        }

        #brightness-slider::-webkit-slider-thumb, #volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #c4943a;
            cursor: pointer;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: #5a4a32;
        }

        .control-icon {
            font-size: 14px;
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .control-icon:hover {
            opacity: 1;
        }

        .control-icon.active {
            opacity: 1;
            color: #c4943a;
        }

        #intro {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000 url('images/hero.png') center center / cover no-repeat;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 1;
            transition: opacity 1.5s ease-out;
            cursor: pointer;
        }

        #intro::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.55);
        }

        #intro.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #intro-text {
            max-width: 700px;
            padding: 40px;
            text-align: center;
            position: relative;
            z-index: 1;
        }

        .intro-quote {
            font-size: 26px;
            font-style: italic;
            line-height: 1.8;
            color: #d4c5a0;
            opacity: 0;
            animation: fadeInText 2.5s ease-in forwards;
            letter-spacing: 0.3px;
        }

        .intro-attribution {
            margin-top: 24px;
            font-size: 16px;
            color: #8b7355;
            opacity: 0;
            animation: fadeInText 1.5s ease-in 1.5s forwards;
        }

        .intro-prompt {
            margin-top: 48px;
            font-size: 14px;
            color: #5a4a32;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0;
            animation: fadeInText 1s ease-in 3s forwards, pulse 2s ease-in-out 4s infinite;
        }

        @keyframes fadeInText {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            z-index: 10;
            display: none;
            pointer-events: none;
            transform: translate(-50%, -50%) rotate(45deg);
            border: 1px solid rgba(212, 197, 160, 0.5);
            transition: border-color 0.15s ease;
        }

        #crosshair.visible {
            display: block;
        }

        #instructions {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 18, 8, 0.85);
            padding: 12px 24px;
            border-radius: 6px;
            border: 1px solid #4a3520;
            color: #d4c5a0;
            font-size: 15px;
            z-index: 5;
            transition: opacity 0.3s;
        }

        #instructions.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #book-tooltip {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 18, 8, 0.95);
            padding: 10px 20px;
            border-radius: 4px;
            border: 1px solid #4a3520;
            color: #c4943a;
            font-size: 14px;
            z-index: 5;
            display: none;
            max-width: 400px;
            text-align: center;
            transition: opacity 0.2s ease;
        }

        #book-tooltip.visible {
            display: block;
            animation: tooltipFadeIn 0.2s ease;
        }

        @keyframes tooltipFadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(4px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        #book-tooltip .title {
            color: #c4943a;
            font-weight: 600;
        }

        #book-tooltip .author {
            color: #8b7355;
            font-size: 12px;
            margin-top: 4px;
        }

        #book-tooltip .location-hint {
            color: #5a4a32;
            font-size: 11px;
            margin-top: 6px;
            font-family: 'IBM Plex Mono', monospace;
        }

        #hud {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(10, 8, 6, 0.85);
            padding: 8px 16px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            color: #5a4a32;
            z-index: 5;
            border-top: 1px solid rgba(74, 53, 32, 0.4);
            display: flex;
            justify-content: space-between;
        }

        #hud-info {
            font-size: 11px;
            color: #3a2e1f;
        }

        #toolbar {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 5;
        }

        .toolbar-btn {
            background: rgba(74, 37, 16, 0.85);
            border: 1px solid #8b7355;
            color: #d4c5a0;
            font-family: 'Cormorant Garamond', serif;
            font-size: 16px;
            padding: 10px 20px;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 4px;
        }

        .toolbar-btn:hover {
            background: rgba(94, 47, 20, 0.95);
            border-color: #c4943a;
            color: #fff;
            transform: translateY(-1px);
        }

        .toolbar-btn.has-indicator {
            position: relative;
        }

        .toolbar-btn .indicator {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 8px;
            height: 8px;
            background: #c4943a;
            border-radius: 50%;
            animation: indicatorPulse 2s infinite;
        }

        @keyframes indicatorPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.2); }
        }

        #reader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        #reader.visible {
            display: flex;
            animation: readerFadeIn 0.3s ease;
        }

        @keyframes readerFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .reader-container {
            display: flex;
            gap: 4px;
            max-width: 95%;
            max-height: 92vh;
        }

        .reader-page {
            max-width: 780px;
            width: 92%;
            max-height: 92vh;
            background: linear-gradient(170deg, #2a2015 0%, #1f1810 40%, #1a150e 100%);
            border: 1px solid #4a3520;
            border-radius: 3px;
            padding: 36px 40px;
            overflow-y: auto;
            box-shadow: 0 0 60px rgba(0,0,0,0.8), inset 0 1px 0 rgba(196,148,58,0.06);
        }

        .reader-page.two-page-mode {
            max-width: 520px;
        }

        .reader-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 24px;
            padding-bottom: 12px;
            border-bottom: 1px solid #4a3520;
        }

        .reader-title {
            font-size: 22px;
            font-weight: 600;
            color: #c4943a;
        }

        .reader-author {
            font-size: 14px;
            color: #8b7355;
            margin-top: 4px;
        }

        .reader-coords {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            color: #5a4a32;
            margin-top: 8px;
        }

        .reader-close {
            background: none;
            border: none;
            color: #8b7355;
            font-size: 28px;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            width: 32px;
            height: 32px;
            transition: color 0.2s;
        }

        .reader-close:hover {
            color: #d4c5a0;
        }

        .reader-content {
            font-size: 16px;
            line-height: 1.8;
            color: #c4b590;
            white-space: pre-wrap;
            margin-bottom: 24px;
            overflow-x: auto;
            overflow-y: auto;
            max-height: 60vh;
            padding: 16px;
            background: rgba(10, 8, 6, 0.4);
            border-radius: 2px;
        }

        .reader-content.font-serif {
            font-family: 'Cormorant Garamond', serif;
        }

        .reader-content.font-baskerville {
            font-family: 'Libre Baskerville', serif;
        }

        .reader-content.font-mono {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            line-height: 1.6;
        }

        .reader-content.font-size-small {
            font-size: 14px;
        }

        .reader-content.font-size-medium {
            font-size: 16px;
        }

        .reader-content.font-size-large {
            font-size: 18px;
        }

        .reader-content.font-size-xlarge {
            font-size: 20px;
        }

        .reader-content.loading {
            color: #8b7355;
            font-style: italic;
            text-align: center;
            padding: 40px;
        }

        .reader-content .search-highlight {
            background: rgba(196, 148, 58, 0.4);
            border-radius: 2px;
            padding: 0 2px;
        }

        .reader-content .search-highlight.current {
            background: rgba(196, 148, 58, 0.8);
        }

        .reader-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            padding-top: 12px;
            border-top: 1px solid #4a3520;
            flex-wrap: wrap;
        }

        .reader-page-num {
            color: #8b7355;
            font-size: 14px;
            white-space: nowrap;
        }

        .reader-nav {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .reader-nav button {
            background: rgba(74, 37, 16, 0.7);
            border: 1px solid #8b7355;
            color: #d4c5a0;
            font-family: 'Cormorant Garamond', serif;
            font-size: 15px;
            padding: 8px 14px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .reader-nav button:hover:not(:disabled) {
            background: rgba(94, 47, 20, 0.9);
            border-color: #c4943a;
        }

        .reader-nav button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .reader-page-jump {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .reader-page-jump input {
            width: 50px;
            background: #1a1208;
            border: 1px solid #4a3520;
            color: #d4c5a0;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            padding: 6px;
            border-radius: 4px;
            text-align: center;
        }

        .reader-page-jump input:focus {
            outline: none;
            border-color: #c4943a;
        }

        .reader-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .reader-action-btn {
            background: none;
            border: 1px solid transparent;
            color: #8b7355;
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .reader-action-btn:hover {
            color: #c4943a;
            border-color: #4a3520;
        }

        .reader-action-btn.active {
            color: #c4943a;
        }

        .reader-action-btn.bookmarked {
            color: #c4943a;
        }

        .page-flip {
            animation: pageFlip 160ms ease-in-out;
        }

        @keyframes pageFlip {
            0% { opacity: 0.35; transform: translateX(8px); }
            100% { opacity: 1; transform: translateX(0); }
        }

        /* In-book search bar */
        .reader-search-bar {
            display: none;
            position: absolute;
            top: 10px;
            right: 80px;
            background: rgba(26, 18, 8, 0.95);
            border: 1px solid #4a3520;
            border-radius: 4px;
            padding: 8px 12px;
            gap: 8px;
            align-items: center;
            z-index: 10;
        }

        .reader-search-bar.visible {
            display: flex;
        }

        .reader-search-bar input {
            width: 200px;
            background: #1a1208;
            border: 1px solid #4a3520;
            color: #d4c5a0;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 13px;
            padding: 6px 10px;
            border-radius: 4px;
        }

        .reader-search-bar input:focus {
            outline: none;
            border-color: #c4943a;
        }

        .reader-search-bar .search-info {
            color: #8b7355;
            font-size: 12px;
            white-space: nowrap;
        }

        .reader-search-bar button {
            background: none;
            border: none;
            color: #8b7355;
            font-size: 16px;
            cursor: pointer;
            padding: 4px;
        }

        .reader-search-bar button:hover {
            color: #c4943a;
        }

        /* Chapter sidebar */
        .chapter-sidebar {
            position: absolute;
            left: 0;
            top: 0;
            width: 280px;
            height: 100%;
            background: #12100a;
            border-right: 1px solid #4a3520;
            padding: 20px;
            overflow-y: auto;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 5;
        }

        .chapter-sidebar.visible {
            transform: translateX(0);
        }

        .chapter-sidebar-title {
            font-size: 16px;
            color: #c4943a;
            margin-bottom: 16px;
            letter-spacing: 1px;
        }

        .chapter-item {
            padding: 10px 12px;
            color: #d4c5a0;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            margin-bottom: 4px;
        }

        .chapter-item:hover {
            background: rgba(74, 37, 16, 0.5);
        }

        .chapter-item.active {
            background: rgba(74, 37, 16, 0.7);
            border-left: 2px solid #c4943a;
        }

        /* Typography settings dropdown */
        .typography-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: rgba(26, 18, 8, 0.98);
            border: 1px solid #4a3520;
            border-radius: 4px;
            padding: 16px;
            display: none;
            min-width: 200px;
            z-index: 20;
        }

        .typography-dropdown.visible {
            display: block;
        }

        .typography-dropdown label {
            display: block;
            color: #8b7355;
            font-size: 12px;
            margin-bottom: 6px;
            margin-top: 12px;
        }

        .typography-dropdown label:first-child {
            margin-top: 0;
        }

        .typography-dropdown select {
            width: 100%;
            background: #1a1208;
            border: 1px solid #4a3520;
            color: #d4c5a0;
            font-family: 'Cormorant Garamond', serif;
            font-size: 14px;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
        }

        .typography-dropdown select:focus {
            outline: none;
            border-color: #c4943a;
        }

        .panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 420px;
            height: 100vh;
            background: #12100a;
            border-left: 1px solid #4a3520;
            z-index: 90;
            transform: translateX(100%);
            transition: transform 0.3s ease-out;
            overflow-y: auto;
            padding: 32px;
        }

        .panel.visible {
            transform: translateX(0);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .panel-title {
            font-size: 24px;
            font-weight: 600;
            color: #c4943a;
        }

        .panel-close {
            background: none;
            border: none;
            color: #8b7355;
            font-size: 28px;
            cursor: pointer;
            line-height: 1;
            transition: color 0.2s;
        }

        .panel-close:hover {
            color: #d4c5a0;
        }

        .panel label {
            display: block;
            margin-bottom: 8px;
            color: #8b7355;
            font-size: 14px;
        }

        .panel input, .panel select {
            width: 100%;
            background: #1a1208;
            border: 1px solid #4a3520;
            color: #d4c5a0;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 13px;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 12px;
            transition: border-color 0.2s;
        }

        .panel input:focus, .panel select:focus {
            outline: none;
            border-color: #c4943a;
        }

        .panel select {
            cursor: pointer;
        }

        .panel button {
            width: 100%;
            background: rgba(74, 37, 16, 0.85);
            border: 1px solid #8b7355;
            color: #d4c5a0;
            font-family: 'Cormorant Garamond', serif;
            font-size: 16px;
            padding: 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            margin-bottom: 12px;
        }

        .panel button:hover {
            background: rgba(94, 47, 20, 0.95);
            border-color: #c4943a;
        }

        .search-philosophy {
            font-style: italic;
            font-size: 15px;
            line-height: 1.6;
            color: #8b7355;
            margin-bottom: 20px;
        }

        .panel-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 20px;
            border-bottom: 1px solid #4a3520;
            padding-bottom: 12px;
        }

        .panel-tab {
            background: none;
            border: 1px solid transparent;
            color: #8b7355;
            font-family: 'Cormorant Garamond', serif;
            font-size: 15px;
            padding: 8px 14px;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            transition: all 0.2s;
            width: auto;
            margin-bottom: 0;
        }

        .panel-tab:hover {
            color: #d4c5a0;
            border-color: #4a3520;
        }

        .panel-tab.active {
            background: rgba(74, 37, 16, 0.5);
            color: #c4943a;
            border-color: #4a3520;
            border-bottom-color: #12100a;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: tabFadeIn 0.3s ease;
        }

        @keyframes tabFadeIn {
            from { opacity: 0; transform: translateY(4px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .filter-row {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .filter-row select {
            flex: 1;
            margin-bottom: 0;
        }

        #search-results {
            margin-top: 16px;
        }

        .search-result-item {
            background: rgba(26, 18, 8, 0.6);
            border: 1px solid #4a3520;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .search-result-item:hover, .search-result-item.selected {
            background: rgba(46, 28, 12, 0.8);
            border-color: #c4943a;
            transform: translateX(2px);
        }

        .search-result-item.selected {
            box-shadow: 0 0 0 1px #c4943a inset;
        }

        .search-result-title {
            color: #c4943a;
            font-size: 15px;
            font-weight: 600;
        }

        .search-result-author {
            color: #8b7355;
            font-size: 13px;
            margin-top: 4px;
        }

        .search-result-meta {
            color: #6a5a42;
            font-size: 11px;
            margin-top: 6px;
        }

        .search-result-location {
            color: #5a4a32;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            margin-top: 8px;
        }

        .search-result-progress {
            color: #6a5a42;
            font-size: 11px;
            margin-top: 4px;
        }

        .search-keyboard-hint {
            font-size: 11px;
            color: #5a4a32;
            margin-top: 12px;
            text-align: center;
        }

        .nav-field {
            margin-bottom: 20px;
        }

        .section-divider {
            margin: 24px 0;
            padding-top: 16px;
            border-top: 1px solid #4a3520;
        }

        .section-title {
            font-size: 14px;
            color: #8b7355;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 16px;
        }

        .empty-state {
            text-align: center;
            padding: 24px;
            color: #5a4a32;
            font-style: italic;
        }

        .bookmark-item, .recent-item {
            background: rgba(26, 18, 8, 0.6);
            border: 1px solid #4a3520;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .bookmark-item:hover, .recent-item:hover {
            background: rgba(46, 28, 12, 0.8);
            border-color: #c4943a;
            transform: translateX(2px);
        }

        .bookmark-remove {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: #5a4a32;
            font-size: 16px;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
            width: auto;
            margin: 0;
            transition: color 0.2s;
        }

        .bookmark-remove:hover {
            color: #c4943a;
            background: none;
        }

        .continue-reading-banner {
            background: linear-gradient(135deg, rgba(74, 37, 16, 0.9), rgba(46, 28, 12, 0.9));
            border: 1px solid #c4943a;
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .continue-reading-banner:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(196, 148, 58, 0.2);
        }

        .continue-reading-label {
            font-size: 11px;
            color: #c4943a;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .continue-reading-title {
            font-size: 17px;
            color: #d4c5a0;
            font-weight: 600;
        }

        .continue-reading-progress {
            font-size: 12px;
            color: #8b7355;
            margin-top: 4px;
        }

        #about-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 700px;
            width: 90%;
            max-height: 90vh;
            background: #12100a;
            border: 1px solid #4a3520;
            border-radius: 4px;
            padding: 40px;
            z-index: 110;
            display: none;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.9);
        }

        #about-modal.visible {
            display: block;
            animation: modalFadeIn 0.3s ease;
        }

        @keyframes modalFadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        #about-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 105;
            display: none;
        }

        #about-overlay.visible {
            display: block;
        }

        .about-header {
            text-align: center;
            margin-bottom: 32px;
        }

        .about-title {
            font-size: 32px;
            font-weight: 600;
            color: #c4943a;
            margin-bottom: 16px;
            letter-spacing: 2px;
        }

        .about-quote {
            font-style: italic;
            font-size: 18px;
            line-height: 1.6;
            color: #d4c5a0;
            margin-bottom: 8px;
        }

        .about-content {
            font-size: 16px;
            line-height: 1.8;
            color: #d4c5a0;
            margin-bottom: 24px;
        }

        .about-content p {
            margin-bottom: 16px;
        }

        .about-section-title {
            font-size: 18px;
            font-weight: 600;
            color: #c4943a;
            margin-top: 32px;
            margin-bottom: 12px;
        }

        .about-close {
            width: 100%;
            background: rgba(74, 37, 16, 0.85);
            border: 1px solid #8b7355;
            color: #d4c5a0;
            font-family: 'Cormorant Garamond', serif;
            font-size: 16px;
            padding: 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            margin-top: 24px;
        }

        .about-close:hover {
            background: rgba(94, 47, 20, 0.95);
            border-color: #c4943a;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #4a3520;
            border-radius: 50%;
            border-top-color: #c4943a;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Toast notifications */
        #toast-container {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }

        .toast {
            background: rgba(26, 18, 8, 0.95);
            border: 1px solid #c4943a;
            border-radius: 6px;
            padding: 12px 24px;
            color: #d4c5a0;
            font-size: 14px;
            animation: toastIn 0.3s ease, toastOut 0.3s ease 2.7s forwards;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        @keyframes toastIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes toastOut {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-10px); }
        }

        /* Two-page layout */
        .reader-page-right {
            display: none;
        }

        .reader-page-right.visible {
            display: block;
        }

        /* Spine label overlay (CSS2D-style) */
        #spine-label-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 4;
        }

        .spine-label {
            position: absolute;
            background: rgba(26, 18, 8, 0.9);
            border: 1px solid rgba(196, 148, 58, 0.6);
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 11px;
            color: #d4c5a0;
            white-space: nowrap;
            transform: translate(-50%, -100%);
            opacity: 0;
            transition: opacity 0.2s ease;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .spine-label.visible {
            opacity: 1;
        }

        .spine-label .spine-title {
            font-weight: 600;
            color: #c4943a;
        }

        .spine-label .spine-author {
            font-size: 10px;
            color: #8b7355;
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <canvas id="scene"></canvas>
    <div id="transition-fade"></div>
    <div id="vignette"></div>
    <div id="spine-label-container"></div>
    <div id="title-bar">
        <span>THE LIBRARY OF GUTENBERG</span>
        <div class="title-bar-controls">
            <div class="control-group">
                <span class="control-icon" id="audio-toggle" title="Toggle ambient audio">üîá</span>
                <input type="range" id="volume-slider" min="0" max="100" value="30" title="Volume">
            </div>
            <div class="control-group">
                <span>‚òÄ</span>
                <input type="range" id="brightness-slider" min="30" max="150" value="80" title="Brightness">
            </div>
        </div>
    </div>

    <div id="intro">
        <div id="intro-text">
            <div class="intro-quote">"A library is not a luxury but one of the necessities of life."</div>
            <div class="intro-attribution">‚Äî Henry Ward Beecher</div>
            <div class="intro-prompt">Click anywhere to enter the Library</div>
        </div>
    </div>

    <div id="crosshair"></div>

    <div id="instructions">
        Click to look around. WASD to walk. Click any book to read it.
    </div>

    <div id="book-tooltip">
        <div class="title"></div>
        <div class="author"></div>
        <div class="location-hint"></div>
    </div>

    <div id="hud">
        <span id="hud-coords">Room 1</span>
        <span id="hud-info">Loading library catalog...</span>
    </div>

    <div id="toolbar">
        <button class="toolbar-btn" onclick="openSearch()">Search</button>
        <button class="toolbar-btn" onclick="openNav()">Navigate</button>
        <button class="toolbar-btn has-indicator" id="library-btn" onclick="openLibrary()">My Library</button>
        <button class="toolbar-btn" onclick="randomRoom()">Random</button>
        <button class="toolbar-btn" onclick="openAbout()">About</button>
    </div>

    <div id="toast-container"></div>

    <div id="reader">
        <div class="chapter-sidebar" id="chapter-sidebar">
            <div class="chapter-sidebar-title">TABLE OF CONTENTS</div>
            <div id="chapter-list"></div>
        </div>
        <div class="reader-container">
            <div class="reader-page" id="reader-page-left">
                <div class="reader-search-bar" id="reader-search-bar">
                    <input type="text" id="reader-search-input" placeholder="Search in book...">
                    <span class="search-info" id="reader-search-info"></span>
                    <button onclick="readerSearchPrev()" title="Previous">‚Üë</button>
                    <button onclick="readerSearchNext()" title="Next">‚Üì</button>
                    <button onclick="closeReaderSearch()" title="Close">√ó</button>
                </div>
                <div class="reader-header">
                    <div>
                        <div class="reader-title" id="reader-title">Loading...</div>
                        <div class="reader-author" id="reader-author"></div>
                        <div class="reader-coords" id="reader-coords"></div>
                    </div>
                    <button class="reader-close" onclick="closeBook()">&times;</button>
                </div>
                <div class="reader-content font-serif font-size-medium" id="reader-content">Loading book text...</div>
                <div class="reader-footer">
                    <div class="reader-page-num" id="reader-page-num">Page 1</div>
                    <div class="reader-actions">
                        <button class="reader-action-btn" id="toc-btn" onclick="toggleChapterSidebar()" title="Table of Contents">üìë</button>
                        <button class="reader-action-btn" id="search-book-btn" onclick="openReaderSearch()" title="Search in book (Ctrl+F)">üîç</button>
                        <button class="reader-action-btn" id="bookmark-btn" onclick="toggleBookmark()" title="Bookmark">üîñ</button>
                        <div style="position:relative;">
                            <button class="reader-action-btn" id="typography-btn" onclick="toggleTypographyDropdown()" title="Typography">Aa</button>
                            <div class="typography-dropdown" id="typography-dropdown">
                                <label>Font</label>
                                <select id="font-select" onchange="changeFont(this.value)">
                                    <option value="serif">Cormorant Garamond</option>
                                    <option value="baskerville">Libre Baskerville</option>
                                    <option value="mono">IBM Plex Mono</option>
                                </select>
                                <label>Size</label>
                                <select id="font-size-select" onchange="changeFontSize(this.value)">
                                    <option value="small">Small</option>
                                    <option value="medium" selected>Medium</option>
                                    <option value="large">Large</option>
                                    <option value="xlarge">Extra Large</option>
                                </select>
                            </div>
                        </div>
                        <button class="reader-action-btn" id="two-page-btn" onclick="toggleTwoPage()" title="Two-page view">üìñ</button>
                    </div>
                    <div class="reader-nav">
                        <button onclick="prevPage()" id="prev-page-btn">&larr; Prev</button>
                        <div class="reader-page-jump">
                            <input type="number" id="page-jump-input" min="1" title="Jump to page">
                            <button onclick="jumpToPage()" style="padding:6px 10px;font-size:12px;">Go</button>
                        </div>
                        <button onclick="nextPage()" id="next-page-btn">Next &rarr;</button>
                    </div>
                    <a id="reader-gutenberg-link" href="#" target="_blank" style="color:#c4943a;font-size:14px;">View on Gutenberg</a>
                </div>
            </div>
            <div class="reader-page reader-page-right two-page-mode" id="reader-page-right">
                <div class="reader-content font-serif font-size-medium" id="reader-content-right"></div>
                <div class="reader-footer">
                    <div class="reader-page-num" id="reader-page-num-right"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="search-panel" class="panel">
        <div class="panel-header">
            <div class="panel-title">Search</div>
            <button class="panel-close" onclick="closeSearch()">&times;</button>
        </div>
        <p class="search-philosophy">Search Project Gutenberg's catalog of over 70,000 free eBooks. Find a book and teleport directly to its shelf.</p>
        
        <div class="section-divider" style="margin-top:0; padding-top:0; border-top:none;">
            <div class="section-title">Search by Title/Author</div>
        </div>
        <input type="text" id="search-input" placeholder="e.g., Pride and Prejudice, Shakespeare...">
        <div class="filter-row">
            <select id="search-language">
                <option value="">Any Language</option>
                <option value="en">English</option>
                <option value="fr">French</option>
                <option value="de">German</option>
                <option value="es">Spanish</option>
                <option value="it">Italian</option>
                <option value="pt">Portuguese</option>
                <option value="nl">Dutch</option>
                <option value="fi">Finnish</option>
                <option value="zh">Chinese</option>
                <option value="ja">Japanese</option>
            </select>
            <select id="search-topic">
                <option value="">Any Subject</option>
                <option value="Fiction">Fiction</option>
                <option value="Science Fiction">Science Fiction</option>
                <option value="Adventure">Adventure</option>
                <option value="Mystery">Mystery</option>
                <option value="Romance">Romance</option>
                <option value="Horror">Horror</option>
                <option value="Poetry">Poetry</option>
                <option value="Drama">Drama</option>
                <option value="History">History</option>
                <option value="Philosophy">Philosophy</option>
                <option value="Science">Science</option>
                <option value="Biography">Biography</option>
                <option value="Children">Children</option>
            </select>
        </div>
        <button onclick="performSearch()">Search</button>
        
        <div class="section-divider">
            <div class="section-title">Jump by Gutenberg ID</div>
        </div>
        <input type="number" id="search-gutenberg-id" min="1" placeholder="e.g., 1342 (Pride and Prejudice)">
        <button onclick="jumpToGutenbergId()">Go to Book</button>
        
        <div id="search-results"></div>
        <div class="search-keyboard-hint" id="search-keyboard-hint" style="display:none;">
            ‚Üë‚Üì Navigate ¬∑ Enter to open ¬∑ Esc to close
        </div>
    </div>

    <div id="nav-panel" class="panel">
        <div class="panel-header">
            <div class="panel-title">Navigate</div>
            <button class="panel-close" onclick="closeNav()">&times;</button>
        </div>
        <div class="nav-field">
            <label>Room Number:</label>
            <input type="number" id="nav-room" min="1" max="110" value="1">
        </div>
        <div class="nav-field">
            <label>Wall (1-4):</label>
            <input type="number" id="nav-wall" min="1" max="4" value="1">
        </div>
        <div class="nav-field">
            <label>Shelf (1-5):</label>
            <input type="number" id="nav-shelf" min="1" max="5" value="1">
        </div>
        <div class="nav-field">
            <label>Volume (1-32):</label>
            <input type="number" id="nav-vol" min="1" max="32" value="1">
        </div>
        <button onclick="navigateToCoords()">Go There</button>
        <div class="section-divider">
            <div class="section-title">Jump by Gutenberg ID</div>
        </div>
        <input type="number" id="nav-gutenberg-id" min="1" placeholder="e.g., 1342">
        <button onclick="navigateToGutenbergId()">Go to Book</button>
    </div>

    <div id="library-panel" class="panel">
        <div class="panel-header">
            <div class="panel-title">My Library</div>
            <button class="panel-close" onclick="closeLibrary()">&times;</button>
        </div>
        
        <div id="continue-reading-section"></div>
        
        <div class="panel-tabs">
            <button class="panel-tab active" data-tab="bookmarks">Bookmarks</button>
            <button class="panel-tab" data-tab="recents">Recent</button>
        </div>
        
        <div class="tab-content active" id="bookmarks-tab">
            <div id="bookmarks-list">
                <div class="empty-state">No bookmarks yet. Open a book and click üîñ to add one.</div>
            </div>
        </div>
        
        <div class="tab-content" id="recents-tab">
            <div id="recents-list">
                <div class="empty-state">No recent books. Start exploring!</div>
            </div>
        </div>
    </div>

    <div id="about-overlay" onclick="closeAbout()"></div>
    <div id="about-modal">
        <div class="about-header">
            <div class="about-title">THE LIBRARY OF GUTENBERG</div>
            <div class="about-quote">
                "A room without books is like a body without a soul."
            </div>
        </div>
        <div class="about-content">
            <p>
                This virtual library contains real books from <a href="https://www.gutenberg.org" target="_blank" style="color:#c4943a;">Project Gutenberg</a>, the oldest digital library of free eBooks. Walk through hexagonal rooms filled with classic literature.
            </p>
            <p>
                Each hexagonal room contains <strong>640 books</strong> arranged across 4 walls, 5 shelves per wall, and 32 volumes per shelf. The library holds the first 70,000 books from Project Gutenberg.
            </p>
            <p>
                Click on any book to read its full text. Use the Search feature to find specific titles or authors and teleport directly to their location.
            </p>
        </div>
        <div class="about-section-title">NAVIGATION</div>
        <div class="about-content">
            <p><strong>WASD</strong> ‚Äî Move around<br>
            <strong>Mouse</strong> ‚Äî Look around (click to engage)<br>
            <strong>Click a book</strong> ‚Äî Read it<br>
            <strong>ESC</strong> ‚Äî Release mouse / Close panels<br>
            <strong>Ctrl+F</strong> ‚Äî Search within book</p>
        </div>
        <div class="about-section-title">CREDITS</div>
        <div class="about-content">
            <p>
                Built with Three.js. Visual design inspired by Jorge Luis Borges's "Library of Babel" and Ethan Mollick's digital recreation. Book data from <a href="https://gutendex.com" target="_blank" style="color:#c4943a;">Gutendex API</a>.
            </p>
        </div>
        <button class="about-close" onclick="closeAbout()">Close</button>
    </div>

    <!-- Audio elements for ambient sound -->
    <audio id="ambient-audio" loop preload="none">
        <source src="https://freesound.org/data/previews/463/463903_4397472-lq.mp3" type="audio/mpeg">
    </audio>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // ============================================
        // LIBRARY CONFIGURATION
        // ============================================

        const BOOKS_PER_SHELF = 32;
        const SHELVES_PER_WALL = 5;
        const WALLS_PER_ROOM = 4;
        const BOOKS_PER_ROOM = BOOKS_PER_SHELF * SHELVES_PER_WALL * WALLS_PER_ROOM; // 640
        const TOTAL_BOOKS = 70000;
        const TOTAL_ROOMS = Math.ceil(TOTAL_BOOKS / BOOKS_PER_ROOM); // ~110 rooms

        const WALL_NAMES = ['North', 'East', 'South', 'West'];

        // ============================================
        // PERSISTENCE (localStorage)
        // ============================================

        const STORAGE_KEYS = {
            BOOKMARKS: 'gutenberg-library-bookmarks',
            RECENTS: 'gutenberg-library-recents',
            READING_PROGRESS: 'gutenberg-library-progress',
            METADATA_CACHE: 'gutenberg-library-meta-cache',
            SETTINGS: 'gutenberg-library-settings'
        };

        function loadFromStorage(key, defaultValue = null) {
            try {
                const stored = localStorage.getItem(key);
                return stored ? JSON.parse(stored) : defaultValue;
            } catch (e) {
                console.warn('Failed to load from storage:', key, e);
                return defaultValue;
            }
        }

        function saveToStorage(key, value) {
            try {
                localStorage.setItem(key, JSON.stringify(value));
            } catch (e) {
                console.warn('Failed to save to storage:', key, e);
            }
        }

        // Load persisted data
        let bookmarks = loadFromStorage(STORAGE_KEYS.BOOKMARKS, []);
        let recents = loadFromStorage(STORAGE_KEYS.RECENTS, []);
        let readingProgress = loadFromStorage(STORAGE_KEYS.READING_PROGRESS, {});
        let metadataCache = loadFromStorage(STORAGE_KEYS.METADATA_CACHE, {});
        let settings = loadFromStorage(STORAGE_KEYS.SETTINGS, { 
            twoPageMode: false, 
            font: 'serif', 
            fontSize: 'medium',
            audioEnabled: false,
            volume: 30
        });

        // Book catalog cache (in-memory + persisted)
        const bookCache = new Map(Object.entries(metadataCache));

        function persistMetadataCache() {
            // Only keep last 500 entries to avoid storage bloat
            const entries = Array.from(bookCache.entries()).slice(-500);
            saveToStorage(STORAGE_KEYS.METADATA_CACHE, Object.fromEntries(entries));
        }

        // ============================================
        // AUDIO SYSTEM
        // ============================================

        const ambientAudio = document.getElementById('ambient-audio');
        let audioEnabled = settings.audioEnabled || false;
        let audioVolume = settings.volume || 30;

        // Page turn sound (Web Audio API for low latency)
        let audioContext = null;
        let pageTurnBuffer = null;

        async function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                // Create a simple page turn sound using oscillator
                const duration = 0.15;
                const sampleRate = audioContext.sampleRate;
                const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    // White noise with envelope
                    const envelope = Math.exp(-t * 20) * 0.3;
                    data[i] = (Math.random() * 2 - 1) * envelope;
                }
                pageTurnBuffer = buffer;
            } catch (e) {
                console.warn('Audio initialization failed:', e);
            }
        }

        function playPageTurn() {
            if (!audioEnabled || !audioContext || !pageTurnBuffer) return;
            try {
                const source = audioContext.createBufferSource();
                const gain = audioContext.createGain();
                source.buffer = pageTurnBuffer;
                gain.gain.value = audioVolume / 100 * 0.5;
                source.connect(gain);
                gain.connect(audioContext.destination);
                source.start();
            } catch (e) {
                // Ignore audio errors
            }
        }

        function toggleAudio() {
            audioEnabled = !audioEnabled;
            settings.audioEnabled = audioEnabled;
            saveToStorage(STORAGE_KEYS.SETTINGS, settings);
            
            const icon = document.getElementById('audio-toggle');
            if (audioEnabled) {
                icon.textContent = 'üîä';
                icon.classList.add('active');
                if (!audioContext) initAudio();
                ambientAudio.volume = audioVolume / 100;
                ambientAudio.play().catch(() => {});
            } else {
                icon.textContent = 'üîá';
                icon.classList.remove('active');
                ambientAudio.pause();
            }
        }

        document.getElementById('audio-toggle').addEventListener('click', toggleAudio);
        
        document.getElementById('volume-slider').addEventListener('input', (e) => {
            audioVolume = parseInt(e.target.value);
            settings.volume = audioVolume;
            saveToStorage(STORAGE_KEYS.SETTINGS, settings);
            ambientAudio.volume = audioVolume / 100;
        });

        // Initialize audio state
        if (audioEnabled) {
            document.getElementById('audio-toggle').textContent = 'üîä';
            document.getElementById('audio-toggle').classList.add('active');
        }
        document.getElementById('volume-slider').value = audioVolume;

        // ============================================
        // BOOKMARKS & RECENTS MANAGEMENT
        // ============================================

        function addToRecents(bookId, title, authors) {
            const existing = recents.findIndex(r => r.bookId === bookId);
            if (existing !== -1) {
                recents.splice(existing, 1);
            }
            recents.unshift({
                bookId,
                title,
                authors,
                timestamp: Date.now()
            });
            recents = recents.slice(0, 20); // Keep last 20
            saveToStorage(STORAGE_KEYS.RECENTS, recents);
            updateLibraryUI();
        }

        function isBookmarked(bookId) {
            return bookmarks.some(b => b.bookId === bookId);
        }

        function addBookmark(bookId, title, authors) {
            if (isBookmarked(bookId)) return;
            bookmarks.unshift({
                bookId,
                title,
                authors,
                timestamp: Date.now()
            });
            saveToStorage(STORAGE_KEYS.BOOKMARKS, bookmarks);
            updateLibraryUI();
            showToast('Bookmark added');
        }

        function removeBookmark(bookId) {
            bookmarks = bookmarks.filter(b => b.bookId !== bookId);
            saveToStorage(STORAGE_KEYS.BOOKMARKS, bookmarks);
            updateLibraryUI();
            showToast('Bookmark removed');
        }

        window.toggleBookmark = function() {
            if (!currentBookId) return;
            const titleEl = document.getElementById('reader-title');
            const authorEl = document.getElementById('reader-author');
            
            if (isBookmarked(currentBookId)) {
                removeBookmark(currentBookId);
                document.getElementById('bookmark-btn').classList.remove('bookmarked');
            } else {
                addBookmark(currentBookId, titleEl.textContent, authorEl.textContent);
                document.getElementById('bookmark-btn').classList.add('bookmarked');
            }
        };

        function saveReadingProgress(bookId, pageIndex, totalPages) {
            readingProgress[bookId] = {
                page: pageIndex,
                total: totalPages,
                timestamp: Date.now()
            };
            saveToStorage(STORAGE_KEYS.READING_PROGRESS, readingProgress);
        }

        function getReadingProgress(bookId) {
            return readingProgress[bookId] || null;
        }

        function getLastReadBook() {
            let lastBook = null;
            let lastTime = 0;
            for (const [bookId, progress] of Object.entries(readingProgress)) {
                if (progress.timestamp > lastTime && progress.page > 0) {
                    lastTime = progress.timestamp;
                    lastBook = { bookId: parseInt(bookId), ...progress };
                }
            }
            return lastBook;
        }

        // ============================================
        // TOAST NOTIFICATIONS
        // ============================================

        function showToast(message) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            container.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // ============================================
        // GUTENBERG API FUNCTIONS (with caching & debounce)
        // ============================================

        let hoverDebounceTimer = null;
        const HOVER_DEBOUNCE_MS = 150;

        async function fetchBookMetadata(bookId) {
            if (bookCache.has(bookId)) {
                return bookCache.get(bookId);
            }
            try {
                const response = await fetch(`/.netlify/functions/gutenberg?meta=${bookId}`);
                if (!response.ok) return null;
                const data = await response.json();
                const book = {
                    id: data.id,
                    title: data.title || 'Unknown Title',
                    authors: data.authors?.map(a => a.name).join(', ') || 'Unknown Author',
                    subjects: data.subjects || [],
                    languages: data.languages || [],
                };
                bookCache.set(bookId, book);
                // Persist cache occasionally
                if (bookCache.size % 10 === 0) {
                    persistMetadataCache();
                }
                return book;
            } catch (e) {
                console.error('Failed to fetch book metadata:', e);
                return null;
            }
        }

        function fetchBookMetadataDebounced(bookId, callback) {
            if (hoverDebounceTimer) {
                clearTimeout(hoverDebounceTimer);
            }
            // Return cached immediately if available
            if (bookCache.has(bookId)) {
                callback(bookCache.get(bookId));
                return;
            }
            hoverDebounceTimer = setTimeout(async () => {
                const meta = await fetchBookMetadata(bookId);
                callback(meta);
            }, HOVER_DEBOUNCE_MS);
        }

        async function fetchBookText(bookId) {
            try {
                const response = await fetch(`/.netlify/functions/gutenberg?id=${bookId}`);
                if (!response.ok) return null;
                return await response.text();
            } catch (e) {
                console.error('Failed to fetch book text:', e);
                return null;
            }
        }

        async function searchBooks(query, language = '', topic = '') {
            try {
                let url = `/.netlify/functions/gutenberg?search=${encodeURIComponent(query)}`;
                if (language) url += `&languages=${language}`;
                if (topic) url += `&topic=${encodeURIComponent(topic)}`;
                
                const response = await fetch(url);
                if (!response.ok) return [];
                const data = await response.json();
                // Cache the results
                if (data.results) {
                    for (const book of data.results) {
                        const cached = {
                            id: book.id,
                            title: book.title || 'Unknown Title',
                            authors: book.authors?.map(a => a.name).join(', ') || 'Unknown Author',
                            subjects: book.subjects || [],
                            languages: book.languages || [],
                        };
                        bookCache.set(book.id, cached);
                    }
                    persistMetadataCache();
                }
                return data.results || [];
            } catch (e) {
                console.error('Failed to search books:', e);
                return [];
            }
        }

        // ============================================
        // DETERMINISTIC BOOK LOCATION MAPPING
        // ============================================

        function bookIdToLocation(bookId) {
            const index = bookId - 1;
            const room = Math.floor(index / BOOKS_PER_ROOM);
            const inRoom = index % BOOKS_PER_ROOM;
            const wall = Math.floor(inRoom / (BOOKS_PER_SHELF * SHELVES_PER_WALL));
            const inWall = inRoom % (BOOKS_PER_SHELF * SHELVES_PER_WALL);
            const shelf = Math.floor(inWall / BOOKS_PER_SHELF);
            const volume = inWall % BOOKS_PER_SHELF;
            return { room, wall, shelf, volume, bookId };
        }

        function locationToBookId(room, wall, shelf, volume) {
            const index = room * BOOKS_PER_ROOM +
                          wall * BOOKS_PER_SHELF * SHELVES_PER_WALL +
                          shelf * BOOKS_PER_SHELF +
                          volume;
            return index + 1;
        }

        // ============================================
        // THREE.JS SCENE SETUP
        // ============================================

        const canvas = document.getElementById('scene');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.8;

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 50);
        camera.position.set(0, 1.6, 0);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0806);
        scene.fog = new THREE.FogExp2(0x0a0806, 0.08);

        const ambientLight = new THREE.AmbientLight(0x201510, 0.4);
        scene.add(ambientLight);

        // Materials
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x2a1f15, roughness: 0.9, metalness: 0.0 });
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1208, roughness: 0.95 });
        const ceilingMaterial = new THREE.MeshStandardMaterial({ color: 0x1f1a12, roughness: 0.9 });
        const shelfMaterial = new THREE.MeshStandardMaterial({ color: 0x4a2510, roughness: 0.7 });

        const BOOK_COLORS = [
            0x8B1A1A, 0x1A3C5A, 0x2B5329, 0x4A3728, 0x3A2E4D,
            0x5C4033, 0x2D4A2D, 0x4A1A2A, 0x1A4A4A, 0x5A4A32,
            0x3D2B1F, 0x2B3D5A, 0x6B3A2A, 0x2A4A3D, 0x4D3A5A,
            0x5A3A28, 0x283A5A, 0x3A5A28, 0x5A2838, 0x38285A,
        ];

        const columnMaterial = new THREE.MeshStandardMaterial({ color: 0x2a1f15, roughness: 0.85 });
        const signMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1208, roughness: 0.8 });
        const sharedMaterials = new Set([wallMaterial, floorMaterial, ceilingMaterial, shelfMaterial, columnMaterial, signMaterial]);

        // Sign texture loader
        const textureLoader = new THREE.TextureLoader();

        // ============================================
        // BOOK HIGHLIGHTING SYSTEM
        // ============================================

        let highlightedBookInfo = null;
        let highlightStartTime = 0;
        const HIGHLIGHT_DURATION = 4000; // 4 seconds
        const HIGHLIGHT_COLOR = new THREE.Color(0xFFD700); // Gold

        function highlightBook(bookId) {
            const location = bookIdToLocation(bookId);
            highlightedBookInfo = {
                bookId,
                room: location.room,
                wall: location.wall,
                shelf: location.shelf,
                volume: location.volume
            };
            highlightStartTime = performance.now();
        }

        function clearHighlight() {
            highlightedBookInfo = null;
        }

        // ============================================
        // TEXT CANVAS FOR IN-WORLD SIGNS
        // ============================================

        function createTextTexture(text, options = {}) {
            const {
                fontSize = 48,
                fontFamily = 'Georgia, serif',
                color = '#c4943a',
                backgroundColor = 'rgba(26, 18, 8, 0.9)',
                padding = 20,
                width = 256,
                height = 64
            } = options;

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            // Background
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, width, height);

            // Border
            ctx.strokeStyle = '#4a3520';
            ctx.lineWidth = 2;
            ctx.strokeRect(2, 2, width - 4, height - 4);

            // Text
            ctx.fillStyle = color;
            ctx.font = `${fontSize}px ${fontFamily}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, width / 2, height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function createShelfLabel(text, options = {}) {
            const {
                fontSize = 24,
                width = 128,
                height = 32
            } = options;

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            // Dark background
            ctx.fillStyle = 'rgba(26, 18, 8, 0.85)';
            ctx.fillRect(0, 0, width, height);

            // Subtle border
            ctx.strokeStyle = 'rgba(74, 53, 32, 0.6)';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, width, height);

            // Text
            ctx.fillStyle = '#8b7355';
            ctx.font = `${fontSize}px "IBM Plex Mono", monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, width / 2, height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // ============================================
        // HEXAGONAL ROOM GEOMETRY
        // ============================================

        const R = 3;
        const ROOM_HEIGHT = 3.2;
        const CORRIDOR_LENGTH = 2.5;
        const ROOM_DEPTH = R * Math.sqrt(3) + CORRIDOR_LENGTH;

        const HEX_VERTICES = [];
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i;
            HEX_VERTICES.push(new THREE.Vector3(R * Math.cos(angle), 0, R * Math.sin(angle)));
        }

        const BOOKSHELF_WALLS = [0, 2, 3, 5];
        const SHELF_HEIGHTS = [0.3, 0.85, 1.4, 1.95, 2.5];

        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        function createFullRoom(roomIndex, offsetZ) {
            const group = new THREE.Group();
            group.position.z = offsetZ;

            // Floor
            const floorShape = new THREE.Shape();
            for (let i = 0; i <= 6; i++) {
                const angle = (Math.PI / 3) * (i % 6);
                const x = R * Math.cos(angle);
                const z = R * Math.sin(angle);
                if (i === 0) floorShape.moveTo(x, z);
                else floorShape.lineTo(x, z);
            }
            const floorGeom = new THREE.ShapeGeometry(floorShape);
            floorGeom.rotateX(-Math.PI / 2);
            const floorMesh = new THREE.Mesh(floorGeom, floorMaterial);
            group.add(floorMesh);

            // Ceiling
            const ceilGeom = floorGeom.clone();
            const ceilMesh = new THREE.Mesh(ceilGeom, ceilingMaterial);
            ceilMesh.position.y = ROOM_HEIGHT;
            ceilMesh.rotation.x = Math.PI;
            group.add(ceilMesh);

            // Bookshelf walls
            for (const wallIdx of BOOKSHELF_WALLS) {
                const va = HEX_VERTICES[wallIdx];
                const vb = HEX_VERTICES[(wallIdx + 1) % 6];
                const wallLen = va.distanceTo(vb);
                const wallGeom = new THREE.PlaneGeometry(wallLen, ROOM_HEIGHT);
                const wallMesh = new THREE.Mesh(wallGeom, wallMaterial);

                const midpoint = new THREE.Vector3((va.x + vb.x) / 2, ROOM_HEIGHT / 2, (va.z + vb.z) / 2);
                wallMesh.position.copy(midpoint);

                const center = new THREE.Vector3((va.x + vb.x) / 2, 0, (va.z + vb.z) / 2);
                const inwardAngle = Math.atan2(-center.x, -center.z);
                wallMesh.rotation.y = inwardAngle;

                group.add(wallMesh);
            }

            // Passage archways
            const PASSAGE_WALLS = [1, 4];
            for (const passIdx of PASSAGE_WALLS) {
                const va = HEX_VERTICES[passIdx];
                const vb = HEX_VERTICES[(passIdx + 1) % 6];
                const center = new THREE.Vector3((va.x + vb.x) / 2, 0, (va.z + vb.z) / 2);
                const passAngle = Math.atan2(-center.x, -center.z);

                // Top beam
                const beamGeom = new THREE.BoxGeometry(R, 0.15, 0.2);
                const beamMesh = new THREE.Mesh(beamGeom, shelfMaterial);
                beamMesh.position.set(center.x, ROOM_HEIGHT - 0.075, center.z);
                beamMesh.rotation.y = passAngle;
                group.add(beamMesh);

                // Room number sign on beam
                const roomNum = roomIndex + 1;
                const signTexture = createTextTexture(`ROOM ${roomNum}`, {
                    fontSize: 36,
                    width: 200,
                    height: 48
                });
                const signGeom = new THREE.PlaneGeometry(0.6, 0.15);
                const signMatInstance = new THREE.MeshBasicMaterial({ map: signTexture, transparent: true });
                const signMesh = new THREE.Mesh(signGeom, signMatInstance);
                signMesh.position.set(center.x, ROOM_HEIGHT - 0.2, center.z);
                signMesh.position.add(new THREE.Vector3(-center.x, 0, -center.z).normalize().multiplyScalar(0.12));
                signMesh.rotation.y = passAngle;
                group.add(signMesh);

                // Side columns
                const colGeom = new THREE.BoxGeometry(0.15, ROOM_HEIGHT, 0.2);
                const col1 = new THREE.Mesh(colGeom, columnMaterial);
                col1.position.set(va.x, ROOM_HEIGHT / 2, va.z);
                col1.rotation.y = passAngle;
                group.add(col1);
                const col2 = new THREE.Mesh(colGeom, columnMaterial);
                col2.position.set(vb.x, ROOM_HEIGHT / 2, vb.z);
                col2.rotation.y = passAngle;
                group.add(col2);

                // Corridor
                const corridorWidth = 1.8;
                const corridorDepth = CORRIDOR_LENGTH / 2;
                const outwardDir = new THREE.Vector3(center.x, 0, center.z).normalize();
                const rightDir = new THREE.Vector3(-outwardDir.z, 0, outwardDir.x);

                const passageEdgeZ = R * Math.sqrt(3) / 2;
                const corridorCenter = center.clone().normalize().multiplyScalar(passageEdgeZ + corridorDepth / 2);

                // Corridor floor
                const corridorFloorGeom = new THREE.PlaneGeometry(corridorWidth, corridorDepth);
                const corridorFloor = new THREE.Mesh(corridorFloorGeom, floorMaterial);
                corridorFloor.rotation.x = -Math.PI / 2;
                corridorFloor.position.copy(corridorCenter);
                corridorFloor.position.y = 0;
                group.add(corridorFloor);

                // Corridor ceiling
                const corridorCeiling = new THREE.Mesh(corridorFloorGeom, ceilingMaterial);
                corridorCeiling.rotation.x = Math.PI / 2;
                corridorCeiling.position.copy(corridorCenter);
                corridorCeiling.position.y = ROOM_HEIGHT;
                group.add(corridorCeiling);

                // Corridor walls
                const corridorWallGeom = new THREE.PlaneGeometry(corridorDepth, ROOM_HEIGHT);

                const leftWallPos = corridorCenter.clone().add(rightDir.clone().multiplyScalar(-corridorWidth / 2));
                const leftWall = new THREE.Mesh(corridorWallGeom, wallMaterial);
                leftWall.position.copy(leftWallPos);
                leftWall.position.y = ROOM_HEIGHT / 2;
                leftWall.rotation.y = passAngle + Math.PI / 2;
                group.add(leftWall);

                const rightWallPos = corridorCenter.clone().add(rightDir.clone().multiplyScalar(corridorWidth / 2));
                const rightWall = new THREE.Mesh(corridorWallGeom, wallMaterial);
                rightWall.position.copy(rightWallPos);
                rightWall.position.y = ROOM_HEIGHT / 2;
                rightWall.rotation.y = passAngle - Math.PI / 2;
                group.add(rightWall);

                // Infill walls
                const gapPerSide = (R - corridorWidth) / 2;
                if (gapPerSide > 0.01) {
                    const infillGeom = new THREE.PlaneGeometry(gapPerSide, ROOM_HEIGHT);

                    const leftInfill = new THREE.Mesh(infillGeom, wallMaterial);
                    const leftInfillPos = center.clone()
                        .add(rightDir.clone().multiplyScalar(-(corridorWidth / 2 + gapPerSide / 2)));
                    leftInfill.position.copy(leftInfillPos);
                    leftInfill.position.y = ROOM_HEIGHT / 2;
                    leftInfill.rotation.y = passAngle;
                    group.add(leftInfill);

                    const rightInfill = new THREE.Mesh(infillGeom, wallMaterial);
                    const rightInfillPos = center.clone()
                        .add(rightDir.clone().multiplyScalar(corridorWidth / 2 + gapPerSide / 2));
                    rightInfill.position.copy(rightInfillPos);
                    rightInfill.position.y = ROOM_HEIGHT / 2;
                    rightInfill.rotation.y = passAngle;
                    group.add(rightInfill);
                }
            }

            // Lamps with more dynamic flicker
            const lampGeom = new THREE.SphereGeometry(0.12, 16, 16);
            const lampMat = new THREE.MeshBasicMaterial({ color: 0xFFE0A0 });
            const lamp1 = new THREE.Mesh(lampGeom, lampMat);
            lamp1.position.set(0.8, ROOM_HEIGHT - 0.2, 0);
            group.add(lamp1);
            const lamp2 = new THREE.Mesh(lampGeom, lampMat);
            lamp2.position.set(-0.8, ROOM_HEIGHT - 0.2, 0);
            group.add(lamp2);

            const light1 = new THREE.PointLight(0xFFD280, 2.0, 10, 1.2);
            light1.position.copy(lamp1.position);
            group.add(light1);
            const light2 = new THREE.PointLight(0xFFD280, 2.0, 10, 1.2);
            light2.position.copy(lamp2.position);
            group.add(light2);

            // Add bookshelves with books and wall/shelf signs
            const { bookMesh, bookMap, originalColors, shelfLabels } = addBookshelves(group, roomIndex);

            return { group, bookMesh, bookMap, originalColors, shelfLabels, lights: [light1, light2], lamps: [lamp1, lamp2], roomIndex };
        }

        function addBookshelves(group, roomIndex) {
            const SHELF_DEPTH = 0.25;
            const SHELF_THICKNESS = 0.02;
            const shelfLabels = [];

            // Shelf planks and wall/shelf labels
            for (let w = 0; w < BOOKSHELF_WALLS.length; w++) {
                const wallIdx = BOOKSHELF_WALLS[w];
                const va = HEX_VERTICES[wallIdx];
                const vb = HEX_VERTICES[(wallIdx + 1) % 6];
                const wallCenter = new THREE.Vector3((va.x + vb.x) / 2, 0, (va.z + vb.z) / 2);
                const inwardDir = new THREE.Vector3(-wallCenter.x, 0, -wallCenter.z).normalize();
                const wallAngle = Math.atan2(-wallCenter.x, -wallCenter.z);

                // Wall label (top of wall)
                const wallLabelTexture = createTextTexture(`WALL ${w + 1} ¬∑ ${WALL_NAMES[w]}`, {
                    fontSize: 28,
                    width: 220,
                    height: 40,
                    color: '#8b7355',
                    backgroundColor: 'rgba(26, 18, 8, 0.7)'
                });
                const wallLabelGeom = new THREE.PlaneGeometry(0.5, 0.1);
                const wallLabelMat = new THREE.MeshBasicMaterial({ map: wallLabelTexture, transparent: true });
                const wallLabelMesh = new THREE.Mesh(wallLabelGeom, wallLabelMat);
                const wallLabelPos = wallCenter.clone().add(inwardDir.clone().multiplyScalar(0.3));
                wallLabelPos.y = ROOM_HEIGHT - 0.15;
                wallLabelMesh.position.copy(wallLabelPos);
                wallLabelMesh.rotation.y = wallAngle;
                group.add(wallLabelMesh);

                for (let s = 0; s < SHELF_HEIGHTS.length; s++) {
                    const shelfGeom = new THREE.BoxGeometry(R - 0.1, SHELF_THICKNESS, SHELF_DEPTH);
                    const shelfMesh = new THREE.Mesh(shelfGeom, shelfMaterial);

                    const shelfPos = wallCenter.clone().add(inwardDir.clone().multiplyScalar(SHELF_DEPTH / 2 + 0.02));
                    shelfPos.y = SHELF_HEIGHTS[s];
                    shelfMesh.position.copy(shelfPos);
                    shelfMesh.rotation.y = wallAngle;
                    group.add(shelfMesh);

                    // Shelf label (small tag on side)
                    const startBookId = locationToBookId(roomIndex, w, s, 0);
                    const endBookId = locationToBookId(roomIndex, w, s, BOOKS_PER_SHELF - 1);
                    const shelfLabelTexture = createShelfLabel(`S${s + 1} ¬∑ #${startBookId}-${endBookId}`, {
                        fontSize: 16,
                        width: 140,
                        height: 24
                    });
                    const shelfLabelGeom = new THREE.PlaneGeometry(0.28, 0.05);
                    const shelfLabelMat = new THREE.MeshBasicMaterial({ map: shelfLabelTexture, transparent: true });
                    const shelfLabelMesh = new THREE.Mesh(shelfLabelGeom, shelfLabelMat);
                    
                    // Position at right edge of shelf
                    const wallDir = new THREE.Vector3().subVectors(vb, va).normalize();
                    const labelPos = shelfPos.clone()
                        .add(wallDir.clone().multiplyScalar((R - 0.1) / 2 - 0.15))
                        .add(inwardDir.clone().multiplyScalar(0.08));
                    labelPos.y = SHELF_HEIGHTS[s] + 0.03;
                    shelfLabelMesh.position.copy(labelPos);
                    shelfLabelMesh.rotation.y = wallAngle;
                    group.add(shelfLabelMesh);
                    
                    shelfLabels.push({ mesh: shelfLabelMesh, wall: w, shelf: s });
                }
            }

            // Books as instanced mesh
            const totalBooks = BOOKSHELF_WALLS.length * SHELF_HEIGHTS.length * BOOKS_PER_SHELF;
            const bookGeom = new THREE.BoxGeometry(0.07, 0.20, 0.18);
            const bookMat = new THREE.MeshStandardMaterial({ roughness: 0.6, metalness: 0.05 });
            const bookMesh = new THREE.InstancedMesh(bookGeom, bookMat, totalBooks);

            const bookMap = [];
            const originalColors = new Float32Array(totalBooks * 3);
            let instanceId = 0;
            const matrix = new THREE.Matrix4();
            const color = new THREE.Color();

            for (let w = 0; w < BOOKSHELF_WALLS.length; w++) {
                const wallIdx = BOOKSHELF_WALLS[w];
                const va = HEX_VERTICES[wallIdx];
                const vb = HEX_VERTICES[(wallIdx + 1) % 6];
                const wallCenter = new THREE.Vector3((va.x + vb.x) / 2, 0, (va.z + vb.z) / 2);
                const wallDir = new THREE.Vector3().subVectors(vb, va).normalize();
                const inwardDir = new THREE.Vector3(-wallCenter.x, 0, -wallCenter.z).normalize();
                const wallAngle = Math.atan2(-wallCenter.x, -wallCenter.z);

                for (let s = 0; s < SHELF_HEIGHTS.length; s++) {
                    for (let v = 0; v < BOOKS_PER_SHELF; v++) {
                        const slot = v - BOOKS_PER_SHELF / 2;
                        const slotWidth = (R - 0.2) / BOOKS_PER_SHELF;

                        const bookPos = wallCenter.clone()
                            .add(wallDir.clone().multiplyScalar(slot * slotWidth))
                            .add(inwardDir.clone().multiplyScalar(0.18));

                        const bookId = locationToBookId(roomIndex, w, s, v);
                        const seed = bookId;
                        const bookHeight = 0.18 + seededRandom(seed) * 0.06;
                        bookPos.y = SHELF_HEIGHTS[s] + SHELF_THICKNESS / 2 + bookHeight / 2;

                        matrix.identity();
                        matrix.makeRotationY(wallAngle);
                        matrix.setPosition(bookPos);
                        matrix.scale(new THREE.Vector3(1, bookHeight / 0.20, 1));
                        bookMesh.setMatrixAt(instanceId, matrix);

                        const colorIndex = bookId % BOOK_COLORS.length;
                        color.setHex(BOOK_COLORS[colorIndex]);
                        bookMesh.setColorAt(instanceId, color);
                        
                        // Store original color
                        originalColors[instanceId * 3] = color.r;
                        originalColors[instanceId * 3 + 1] = color.g;
                        originalColors[instanceId * 3 + 2] = color.b;

                        bookMap.push({ wall: w, shelf: s, vol: v, bookId, instanceId, worldPos: bookPos.clone() });
                        instanceId++;
                    }
                }
            }

            bookMesh.instanceMatrix.needsUpdate = true;
            bookMesh.instanceColor.needsUpdate = true;
            group.add(bookMesh);

            return { bookMesh, bookMap, originalColors, shelfLabels };
        }

        // ============================================
        // ROOM MANAGEMENT
        // ============================================

        let currentRoomIndex = 0;
        const rooms = new Map();

        function disposeRoom(room) {
            scene.remove(room.group);
            room.group.traverse((obj) => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material && !sharedMaterials.has(obj.material)) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => { if (!sharedMaterials.has(mat)) mat.dispose(); });
                    } else {
                        obj.material.dispose();
                    }
                }
            });
        }

        function clearAllRooms() {
            for (const [idx, room] of rooms) {
                disposeRoom(room);
            }
            rooms.clear();
        }

        function teleportTo(roomIndex, callback, highlightBookId = null) {
            roomIndex = Math.max(0, Math.min(TOTAL_ROOMS - 1, roomIndex));
            const fade = document.getElementById('transition-fade');
            fade.classList.add('active');
            setTimeout(() => {
                currentRoomIndex = roomIndex;
                camera.position.set(0, 1.6, 0);
                clearAllRooms();
                updateRooms();
                updateHUD();
                
                // Start highlight if requested
                if (highlightBookId) {
                    highlightBook(highlightBookId);
                }
                
                setTimeout(() => {
                    fade.classList.remove('active');
                    if (callback) callback();
                }, 100);
            }, 300);
        }

        function updateRooms() {
            const needed = new Set();
            for (let offset = -2; offset <= 2; offset++) {
                const idx = currentRoomIndex + offset;
                if (idx >= 0 && idx < TOTAL_ROOMS) {
                    needed.add(idx);
                }
            }

            // Remove unneeded rooms
            for (const [idx, room] of rooms) {
                if (!needed.has(idx)) {
                    disposeRoom(room);
                    rooms.delete(idx);
                }
            }

            // Add needed rooms
            for (const idx of needed) {
                if (!rooms.has(idx)) {
                    const offsetZ = (idx - currentRoomIndex) * ROOM_DEPTH;
                    const roomData = createFullRoom(idx, offsetZ);
                    scene.add(roomData.group);
                    rooms.set(idx, roomData);
                }
            }
        }

        function checkRoomTransition() {
            const localZ = camera.position.z;
            const halfDepth = ROOM_DEPTH / 2;

            if (localZ > halfDepth && currentRoomIndex < TOTAL_ROOMS - 1) {
                currentRoomIndex++;
                camera.position.z -= ROOM_DEPTH;
                for (const [idx, room] of rooms) {
                    room.group.position.z -= ROOM_DEPTH;
                }
                updateRooms();
                updateHUD();
            } else if (localZ < -halfDepth && currentRoomIndex > 0) {
                currentRoomIndex--;
                camera.position.z += ROOM_DEPTH;
                for (const [idx, room] of rooms) {
                    room.group.position.z += ROOM_DEPTH;
                }
                updateRooms();
                updateHUD();
            }
        }

        // ============================================
        // POINTER LOCK CONTROLS
        // ============================================

        const controls = new PointerLockControls(camera, document.body);

        let readerOpen = false;
        let searchOpen = false;
        let navOpen = false;
        let aboutOpen = false;
        let libraryOpen = false;
        let introHidden = false;

        canvas.addEventListener('click', (e) => {
            if (!readerOpen && !searchOpen && !navOpen && !aboutOpen && !libraryOpen && introHidden) {
                controls.lock();
            }
        });

        controls.addEventListener('lock', () => {
            document.getElementById('crosshair').classList.add('visible');
            document.getElementById('instructions').classList.add('hidden');
            // Start ambient audio on interaction
            if (audioEnabled && !audioContext) {
                initAudio();
                ambientAudio.volume = audioVolume / 100;
                ambientAudio.play().catch(() => {});
            }
        });

        controls.addEventListener('unlock', () => {
            document.getElementById('crosshair').classList.remove('visible');
            if (introHidden && !readerOpen && !searchOpen && !navOpen && !aboutOpen && !libraryOpen) {
                document.getElementById('instructions').classList.remove('hidden');
            }
        });

        // ============================================
        // MOVEMENT
        // ============================================

        const moveSpeed = 3.0;
        const keys = { forward: false, backward: false, left: false, right: false };

        window.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': keys.forward = true; break;
                case 'KeyS': if (controls.isLocked) keys.backward = true; break;
                case 'KeyA': keys.left = true; break;
                case 'KeyD': keys.right = true; break;
            }
        });

        window.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': keys.forward = false; break;
                case 'KeyS': keys.backward = false; break;
                case 'KeyA': keys.left = false; break;
                case 'KeyD': keys.right = false; break;
            }
        });

        // Collision detection
        const passageEdgeZ = R * Math.sqrt(3) / 2;
        const corridorHalfW = 0.9;
        const corridorEnd = passageEdgeZ + CORRIDOR_LENGTH / 2;

        const CORRIDOR_WALLS = [
            [corridorHalfW, passageEdgeZ, corridorHalfW, corridorEnd],
            [-corridorHalfW, passageEdgeZ, -corridorHalfW, corridorEnd],
            [-corridorHalfW, -passageEdgeZ, -corridorHalfW, -corridorEnd],
            [corridorHalfW, -passageEdgeZ, corridorHalfW, -corridorEnd],
            [corridorHalfW, passageEdgeZ, R / 2, passageEdgeZ],
            [-corridorHalfW, passageEdgeZ, -R / 2, passageEdgeZ],
            [corridorHalfW, -passageEdgeZ, R / 2, -passageEdgeZ],
            [-corridorHalfW, -passageEdgeZ, -R / 2, -passageEdgeZ],
        ];

        function checkSegmentCollision(pos, ax, az, bx, bz, minDist) {
            const dx = bx - ax, dz = bz - az;
            const len = Math.sqrt(dx * dx + dz * dz);
            if (len < 0.001) return;
            const nx = dx / len, nz = dz / len;
            const toCamX = pos.x - ax, toCamZ = pos.z - az;
            const proj = Math.max(0, Math.min(len, toCamX * nx + toCamZ * nz));
            const closeX = ax + nx * proj, closeZ = az + nz * proj;
            const dist = Math.sqrt((pos.x - closeX) ** 2 + (pos.z - closeZ) ** 2);
            if (dist < minDist && dist > 0.001) {
                const px = (pos.x - closeX) / dist, pz = (pos.z - closeZ) / dist;
                pos.x = closeX + px * minDist;
                pos.z = closeZ + pz * minDist;
            }
        }

        function applyCollision() {
            const pos = camera.position;
            const minDist = 0.35;

            for (const wallIdx of BOOKSHELF_WALLS) {
                const va = HEX_VERTICES[wallIdx];
                const vb = HEX_VERTICES[(wallIdx + 1) % 6];
                checkSegmentCollision(pos, va.x, va.z, vb.x, vb.z, minDist);
            }

            for (const seg of CORRIDOR_WALLS) {
                checkSegmentCollision(pos, seg[0], seg[1], seg[2], seg[3], minDist);
            }
        }

        // ============================================
        // RAYCASTING FOR BOOK SELECTION
        // ============================================

        const raycaster = new THREE.Raycaster();
        raycaster.far = 3;

        let hoveredBookId = null;

        document.addEventListener('click', async (event) => {
            if (!controls.isLocked) return;

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            for (const [idx, room] of rooms) {
                const intersects = raycaster.intersectObject(room.bookMesh);
                if (intersects.length > 0) {
                    const instanceId = intersects[0].instanceId;
                    const bookInfo = room.bookMap[instanceId];
                    openBook(bookInfo.bookId);
                    controls.unlock();
                    return;
                }
            }
        });

        // ============================================
        // SPINE LABEL SYSTEM (screen-space overlay)
        // ============================================

        let currentSpineLabel = null;

        function updateSpineLabel(bookInfo, screenPos) {
            let label = document.querySelector('.spine-label');
            if (!label) {
                label = document.createElement('div');
                label.className = 'spine-label';
                label.innerHTML = '<div class="spine-title"></div><div class="spine-author"></div>';
                document.getElementById('spine-label-container').appendChild(label);
            }
            
            label.style.left = `${screenPos.x}px`;
            label.style.top = `${screenPos.y - 30}px`;
            label.classList.add('visible');
            
            currentSpineLabel = { label, bookId: bookInfo.bookId };
            
            // Update content
            const titleEl = label.querySelector('.spine-title');
            const authorEl = label.querySelector('.spine-author');
            
            if (bookCache.has(bookInfo.bookId)) {
                const meta = bookCache.get(bookInfo.bookId);
                titleEl.textContent = meta.title.substring(0, 30) + (meta.title.length > 30 ? '...' : '');
                authorEl.textContent = meta.authors.substring(0, 25) + (meta.authors.length > 25 ? '...' : '');
            } else {
                titleEl.textContent = `Book #${bookInfo.bookId}`;
                authorEl.textContent = 'Loading...';
            }
        }

        function hideSpineLabel() {
            const label = document.querySelector('.spine-label');
            if (label) {
                label.classList.remove('visible');
            }
            currentSpineLabel = null;
        }

        // ============================================
        // BOOK READER UI
        // ============================================

        let currentBookId = null;
        let currentBookText = '';
        let currentBookPages = [];
        let currentPageIndex = 0;
        let detectedChapters = [];
        let twoPageMode = settings.twoPageMode || false;
        let currentFont = settings.font || 'serif';
        let currentFontSize = settings.fontSize || 'medium';
        const textCache = new Map();

        // In-book search state
        let readerSearchQuery = '';
        let readerSearchMatches = [];
        let readerSearchCurrentIndex = -1;

        function paginateText(text) {
            const lines = text.split('\n');
            const perPage = twoPageMode ? 35 : 40;
            const pages = [];
            for (let i = 0; i < lines.length; i += perPage) {
                pages.push(lines.slice(i, i + perPage).join('\n'));
            }
            return pages.length ? pages : [''];
        }

        function detectChapters(text) {
            const chapters = [];
            const lines = text.split('\n');
            const chapterPatterns = [
                /^(CHAPTER|Chapter|PART|Part|BOOK|Book)\s+([IVXLC\d]+)/,
                /^(CHAPTER|Chapter|PART|Part|BOOK|Book)\s+\d+/,
                /^([IVXLC]+)\.\s/,
                /^\d+\.\s+[A-Z]/,
            ];
            
            let lineCount = 0;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                for (const pattern of chapterPatterns) {
                    if (pattern.test(line)) {
                        const pageIndex = Math.floor(lineCount / (twoPageMode ? 35 : 40));
                        chapters.push({
                            title: line.substring(0, 50),
                            page: pageIndex,
                            line: lineCount
                        });
                        break;
                    }
                }
                lineCount++;
            }
            return chapters;
        }

        function updateChapterList() {
            const listEl = document.getElementById('chapter-list');
            if (detectedChapters.length === 0) {
                listEl.innerHTML = '<div class="empty-state">No chapters detected</div>';
                return;
            }
            
            listEl.innerHTML = detectedChapters.map((ch, i) => `
                <div class="chapter-item ${ch.page === currentPageIndex ? 'active' : ''}" 
                     onclick="jumpToChapter(${i})">
                    ${escapeHtml(ch.title)}
                </div>
            `).join('');
        }

        window.jumpToChapter = function(index) {
            if (index >= 0 && index < detectedChapters.length) {
                currentPageIndex = detectedChapters[index].page;
                renderPage();
                updateChapterList();
            }
        };

        window.toggleChapterSidebar = function() {
            const sidebar = document.getElementById('chapter-sidebar');
            sidebar.classList.toggle('visible');
            document.getElementById('toc-btn').classList.toggle('active', sidebar.classList.contains('visible'));
        };

        function renderPage() {
            const contentEl = document.getElementById('reader-content');
            const pageNumEl = document.getElementById('reader-page-num');
            const prevBtn = document.getElementById('prev-page-btn');
            const nextBtn = document.getElementById('next-page-btn');
            const pageJumpInput = document.getElementById('page-jump-input');

            const total = currentBookPages.length || 1;
            const idx = Math.max(0, Math.min(currentPageIndex, total - 1));
            currentPageIndex = idx;

            contentEl.classList.remove('loading');
            contentEl.classList.add('page-flip');
            requestAnimationFrame(() => contentEl.classList.remove('page-flip'));

            // Apply search highlighting if active
            let pageContent = currentBookPages[idx] || '';
            if (readerSearchQuery && readerSearchMatches.length > 0) {
                pageContent = highlightSearchInText(pageContent, readerSearchQuery);
            }
            contentEl.innerHTML = pageContent.replace(/\n/g, '<br>');
            
            // Update page jump input
            pageJumpInput.value = idx + 1;
            pageJumpInput.max = total;
            
            if (twoPageMode) {
                pageNumEl.textContent = `Page ${idx + 1}`;
                const rightContent = document.getElementById('reader-content-right');
                const rightPageNum = document.getElementById('reader-page-num-right');
                if (idx + 1 < total) {
                    let rightPageContent = currentBookPages[idx + 1] || '';
                    if (readerSearchQuery && readerSearchMatches.length > 0) {
                        rightPageContent = highlightSearchInText(rightPageContent, readerSearchQuery);
                    }
                    rightContent.innerHTML = rightPageContent.replace(/\n/g, '<br>');
                    rightPageNum.textContent = `Page ${idx + 2}`;
                    document.getElementById('reader-page-right').classList.add('visible');
                } else {
                    rightContent.innerHTML = '';
                    rightPageNum.textContent = '';
                    document.getElementById('reader-page-right').classList.remove('visible');
                }
                prevBtn.disabled = idx === 0;
                nextBtn.disabled = idx >= total - 2;
            } else {
                pageNumEl.textContent = `Page ${idx + 1} of ${total}`;
                document.getElementById('reader-page-right').classList.remove('visible');
                prevBtn.disabled = idx === 0;
                nextBtn.disabled = idx >= total - 1;
            }

            // Save reading progress
            if (currentBookId) {
                saveReadingProgress(currentBookId, idx, total);
            }
            
            // Update chapter highlight
            updateChapterList();
        }

        function highlightSearchInText(text, query) {
            if (!query) return escapeHtml(text);
            const escaped = escapeHtml(text);
            const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
            return escaped.replace(regex, '<span class="search-highlight">$1</span>');
        }

        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        window.jumpToPage = function() {
            const input = document.getElementById('page-jump-input');
            const page = parseInt(input.value) - 1;
            if (page >= 0 && page < currentBookPages.length) {
                currentPageIndex = page;
                renderPage();
                playPageTurn();
            }
        };

        window.toggleTwoPage = function() {
            twoPageMode = !twoPageMode;
            settings.twoPageMode = twoPageMode;
            saveToStorage(STORAGE_KEYS.SETTINGS, settings);
            
            const btn = document.getElementById('two-page-btn');
            btn.classList.toggle('active', twoPageMode);
            
            const leftPage = document.getElementById('reader-page-left');
            leftPage.classList.toggle('two-page-mode', twoPageMode);
            
            // Re-paginate current book
            if (currentBookText) {
                const cleanText = currentBookText.replace(/\r\n/g, '\n').replace(/\n{4,}/g, '\n\n\n');
                currentBookPages = paginateText(cleanText);
                detectedChapters = detectChapters(cleanText);
                // Adjust page index for two-page mode
                if (twoPageMode) {
                    currentPageIndex = Math.floor(currentPageIndex / 2) * 2;
                }
                renderPage();
            }
        };

        // Typography controls
        window.toggleTypographyDropdown = function() {
            const dropdown = document.getElementById('typography-dropdown');
            dropdown.classList.toggle('visible');
        };

        window.changeFont = function(font) {
            currentFont = font;
            settings.font = font;
            saveToStorage(STORAGE_KEYS.SETTINGS, settings);
            
            const contents = document.querySelectorAll('.reader-content');
            contents.forEach(el => {
                el.classList.remove('font-serif', 'font-baskerville', 'font-mono');
                el.classList.add(`font-${font}`);
            });
        };

        window.changeFontSize = function(size) {
            currentFontSize = size;
            settings.fontSize = size;
            saveToStorage(STORAGE_KEYS.SETTINGS, settings);
            
            const contents = document.querySelectorAll('.reader-content');
            contents.forEach(el => {
                el.classList.remove('font-size-small', 'font-size-medium', 'font-size-large', 'font-size-xlarge');
                el.classList.add(`font-size-${size}`);
            });
        };

        // In-book search
        window.openReaderSearch = function() {
            const searchBar = document.getElementById('reader-search-bar');
            searchBar.classList.add('visible');
            document.getElementById('reader-search-input').focus();
        };

        window.closeReaderSearch = function() {
            const searchBar = document.getElementById('reader-search-bar');
            searchBar.classList.remove('visible');
            readerSearchQuery = '';
            readerSearchMatches = [];
            readerSearchCurrentIndex = -1;
            document.getElementById('reader-search-info').textContent = '';
            renderPage(); // Remove highlights
        };

        window.readerSearchPrev = function() {
            if (readerSearchMatches.length === 0) return;
            readerSearchCurrentIndex = (readerSearchCurrentIndex - 1 + readerSearchMatches.length) % readerSearchMatches.length;
            goToSearchMatch();
        };

        window.readerSearchNext = function() {
            if (readerSearchMatches.length === 0) return;
            readerSearchCurrentIndex = (readerSearchCurrentIndex + 1) % readerSearchMatches.length;
            goToSearchMatch();
        };

        function goToSearchMatch() {
            if (readerSearchCurrentIndex < 0 || readerSearchCurrentIndex >= readerSearchMatches.length) return;
            const match = readerSearchMatches[readerSearchCurrentIndex];
            currentPageIndex = match.page;
            renderPage();
            document.getElementById('reader-search-info').textContent = 
                `${readerSearchCurrentIndex + 1} of ${readerSearchMatches.length}`;
        }

        document.getElementById('reader-search-input').addEventListener('input', (e) => {
            readerSearchQuery = e.target.value.trim();
            if (readerSearchQuery.length < 2) {
                readerSearchMatches = [];
                readerSearchCurrentIndex = -1;
                document.getElementById('reader-search-info').textContent = '';
                renderPage();
                return;
            }
            
            // Find all matches across pages
            readerSearchMatches = [];
            const regex = new RegExp(escapeRegex(readerSearchQuery), 'gi');
            for (let i = 0; i < currentBookPages.length; i++) {
                const matches = currentBookPages[i].match(regex);
                if (matches) {
                    for (const m of matches) {
                        readerSearchMatches.push({ page: i, text: m });
                    }
                }
            }
            
            readerSearchCurrentIndex = readerSearchMatches.length > 0 ? 0 : -1;
            document.getElementById('reader-search-info').textContent = 
                readerSearchMatches.length > 0 ? `1 of ${readerSearchMatches.length}` : 'No matches';
            
            if (readerSearchCurrentIndex >= 0) {
                goToSearchMatch();
            } else {
                renderPage();
            }
        });

        document.getElementById('reader-search-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (e.shiftKey) {
                    readerSearchPrev();
                } else {
                    readerSearchNext();
                }
            } else if (e.key === 'Escape') {
                closeReaderSearch();
            }
        });

        window.nextPage = function() {
            if (!readerOpen) return;
            const step = twoPageMode ? 2 : 1;
            if (currentPageIndex < (currentBookPages.length - step)) {
                currentPageIndex += step;
                renderPage();
                playPageTurn();
            }
        };

        window.prevPage = function() {
            if (!readerOpen) return;
            const step = twoPageMode ? 2 : 1;
            if (currentPageIndex >= step) {
                currentPageIndex -= step;
                renderPage();
                playPageTurn();
            }
        };

        window.openBook = async function(bookId, resumePage = null) {
            currentBookId = bookId;
            readerOpen = true;

            const location = bookIdToLocation(bookId);

            document.getElementById('reader-title').textContent = 'Loading...';
            document.getElementById('reader-author').textContent = '';
            document.getElementById('reader-coords').textContent = `Room ${location.room + 1} ¬∑ Wall ${location.wall + 1} (${WALL_NAMES[location.wall]}) ¬∑ Shelf ${location.shelf + 1} ¬∑ Volume ${location.volume + 1}`;
            document.getElementById('reader-content').textContent = 'Loading book text...';
            document.getElementById('reader-content').classList.add('loading');
            document.getElementById('reader-gutenberg-link').href = `https://www.gutenberg.org/ebooks/${bookId}`;
            document.getElementById('reader').classList.add('visible');
            
            // Reset search
            readerSearchQuery = '';
            readerSearchMatches = [];
            readerSearchCurrentIndex = -1;
            document.getElementById('reader-search-bar').classList.remove('visible');
            
            // Reset chapter sidebar
            document.getElementById('chapter-sidebar').classList.remove('visible');
            document.getElementById('toc-btn').classList.remove('active');
            
            // Update bookmark button state
            document.getElementById('bookmark-btn').classList.toggle('bookmarked', isBookmarked(bookId));
            
            // Update two-page button state
            document.getElementById('two-page-btn').classList.toggle('active', twoPageMode);
            document.getElementById('reader-page-left').classList.toggle('two-page-mode', twoPageMode);
            
            // Apply saved typography settings
            document.getElementById('font-select').value = currentFont;
            document.getElementById('font-size-select').value = currentFontSize;
            changeFont(currentFont);
            changeFontSize(currentFontSize);

            // Fetch metadata
            const meta = await fetchBookMetadata(bookId);
            if (meta) {
                document.getElementById('reader-title').textContent = meta.title;
                document.getElementById('reader-author').textContent = meta.authors;
                // Add to recents
                addToRecents(bookId, meta.title, meta.authors);
            } else {
                document.getElementById('reader-title').textContent = `Book #${bookId}`;
                document.getElementById('reader-author').textContent = '';
                addToRecents(bookId, `Book #${bookId}`, '');
            }

            // Fetch text (with cache)
            let text = textCache.get(bookId);
            if (!text) {
                text = await fetchBookText(bookId);
                if (text) textCache.set(bookId, text);
            }

            if (text) {
                currentBookText = text;
                const cleanText = text.replace(/\r\n/g, '\n').replace(/\n{4,}/g, '\n\n\n');
                currentBookPages = paginateText(cleanText);
                detectedChapters = detectChapters(cleanText);
                updateChapterList();
                
                // Resume from saved progress or specified page
                if (resumePage !== null) {
                    currentPageIndex = resumePage;
                } else {
                    const progress = getReadingProgress(bookId);
                    currentPageIndex = progress ? progress.page : 0;
                }
                
                renderPage();
            } else {
                currentBookText = '';
                currentBookPages = ['Unable to load book text. The book may not be available in plain text format.'];
                detectedChapters = [];
                currentPageIndex = 0;
                renderPage();
            }
        };

        window.closeBook = function() {
            document.getElementById('reader').classList.remove('visible');
            document.getElementById('reader-page-right').classList.remove('visible');
            document.getElementById('chapter-sidebar').classList.remove('visible');
            document.getElementById('typography-dropdown').classList.remove('visible');
            readerOpen = false;
            currentBookId = null;
            currentBookText = '';
            currentBookPages = [];
            currentPageIndex = 0;
            detectedChapters = [];
        };

        // Close typography dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('typography-dropdown');
            const btn = document.getElementById('typography-btn');
            if (!dropdown.contains(e.target) && e.target !== btn) {
                dropdown.classList.remove('visible');
            }
        });

        // ============================================
        // SEARCH UI
        // ============================================

        let searchResults = [];
        let selectedSearchIndex = -1;

        window.openSearch = function() {
            document.getElementById('search-panel').classList.add('visible');
            searchOpen = true;
            controls.unlock();
            setTimeout(() => {
                document.getElementById('search-input').focus();
            }, 300);
        };

        window.closeSearch = function() {
            document.getElementById('search-panel').classList.remove('visible');
            searchOpen = false;
            searchResults = [];
            selectedSearchIndex = -1;
        };

        window.performSearch = async function() {
            const query = document.getElementById('search-input').value.trim();
            if (!query) return;

            const language = document.getElementById('search-language').value;
            const topic = document.getElementById('search-topic').value;

            const resultsDiv = document.getElementById('search-results');
            resultsDiv.innerHTML = '<div class="loading-spinner"></div> Searching...';

            const results = await searchBooks(query, language, topic);
            searchResults = results.slice(0, 15);
            selectedSearchIndex = -1;

            if (searchResults.length === 0) {
                resultsDiv.innerHTML = '<p style="color:#8b7355;">No books found. Try different keywords or filters.</p>';
                document.getElementById('search-keyboard-hint').style.display = 'none';
                return;
            }

            renderSearchResults();
            document.getElementById('search-keyboard-hint').style.display = 'block';
        };

        function renderSearchResults() {
            const resultsDiv = document.getElementById('search-results');
            resultsDiv.innerHTML = searchResults.map((book, i) => {
                const location = bookIdToLocation(book.id);
                const authors = book.authors?.map(a => a.name).join(', ') || 'Unknown Author';
                const languages = book.languages?.join(', ') || '';
                const subjects = book.subjects?.slice(0, 2).join('; ') || '';
                const progress = getReadingProgress(book.id);
                const progressText = progress ? `Progress: Page ${progress.page + 1} of ${progress.total}` : '';
                return `
                    <div class="search-result-item ${i === selectedSearchIndex ? 'selected' : ''}" 
                         data-index="${i}"
                         onclick="goToBook(${book.id})">
                        <div class="search-result-title">${escapeHtml(book.title)}</div>
                        <div class="search-result-author">${escapeHtml(authors)}</div>
                        ${languages || subjects ? `<div class="search-result-meta">${languages ? `üìñ ${languages}` : ''} ${subjects ? `¬∑ ${subjects}` : ''}</div>` : ''}
                        <div class="search-result-location">Room ${location.room + 1} ¬∑ Wall ${location.wall + 1} ¬∑ Shelf ${location.shelf + 1}</div>
                        ${progressText ? `<div class="search-result-progress">${progressText}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        window.jumpToGutenbergId = function() {
            const bookId = parseInt(document.getElementById('search-gutenberg-id').value);
            if (!bookId || bookId < 1 || bookId > TOTAL_BOOKS) {
                showToast('Please enter a valid Gutenberg ID (1-70000)');
                return;
            }
            closeSearch();
            const location = bookIdToLocation(bookId);
            teleportTo(location.room, () => {
                openBook(bookId);
            }, bookId);
        };

        window.goToBook = function(bookId) {
            const location = bookIdToLocation(bookId);
            closeSearch();
            teleportTo(location.room, () => {
                openBook(bookId);
            }, bookId);
        };

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============================================
        // NAVIGATION UI
        // ============================================

        window.openNav = function() {
            document.getElementById('nav-panel').classList.add('visible');
            navOpen = true;
            controls.unlock();
        };

        window.closeNav = function() {
            document.getElementById('nav-panel').classList.remove('visible');
            navOpen = false;
        };

        window.navigateToCoords = function() {
            const room = parseInt(document.getElementById('nav-room').value) - 1 || 0;
            const wall = parseInt(document.getElementById('nav-wall').value) - 1 || 0;
            const shelf = parseInt(document.getElementById('nav-shelf').value) - 1 || 0;
            const vol = parseInt(document.getElementById('nav-vol').value) - 1 || 0;

            if (room < 0 || room >= TOTAL_ROOMS || wall < 0 || wall >= 4 ||
                shelf < 0 || shelf >= 5 || vol < 0 || vol >= 32) {
                return;
            }

            const bookId = locationToBookId(room, wall, shelf, vol);
            closeNav();
            teleportTo(room, () => {
                openBook(bookId);
            }, bookId);
        };

        window.navigateToGutenbergId = function() {
            const bookId = parseInt(document.getElementById('nav-gutenberg-id').value);
            if (!bookId || bookId < 1 || bookId > TOTAL_BOOKS) return;

            const location = bookIdToLocation(bookId);
            closeNav();
            teleportTo(location.room, () => {
                openBook(bookId);
            }, bookId);
        };

        // ============================================
        // MY LIBRARY PANEL
        // ============================================

        window.openLibrary = function() {
            document.getElementById('library-panel').classList.add('visible');
            libraryOpen = true;
            controls.unlock();
            updateLibraryUI();
        };

        window.closeLibrary = function() {
            document.getElementById('library-panel').classList.remove('visible');
            libraryOpen = false;
        };

        function updateLibraryUI() {
            // Continue reading banner
            const continueSection = document.getElementById('continue-reading-section');
            const lastBook = getLastReadBook();
            if (lastBook && lastBook.page > 0) {
                const meta = bookCache.get(lastBook.bookId);
                const title = meta?.title || `Book #${lastBook.bookId}`;
                const percent = Math.round((lastBook.page / lastBook.total) * 100);
                continueSection.innerHTML = `
                    <div class="continue-reading-banner" onclick="continueReading(${lastBook.bookId}, ${lastBook.page})">
                        <div class="continue-reading-label">Continue Reading</div>
                        <div class="continue-reading-title">${escapeHtml(title)}</div>
                        <div class="continue-reading-progress">Page ${lastBook.page + 1} of ${lastBook.total} (${percent}%)</div>
                    </div>
                `;
            } else {
                continueSection.innerHTML = '';
            }
            
            // Update indicator
            const hasContent = bookmarks.length > 0 || recents.length > 0 || lastBook;
            const indicator = document.querySelector('#library-btn .indicator');
            if (indicator) {
                indicator.style.display = hasContent ? 'block' : 'none';
            }

            // Bookmarks
            const bookmarksList = document.getElementById('bookmarks-list');
            if (bookmarks.length === 0) {
                bookmarksList.innerHTML = '<div class="empty-state">No bookmarks yet. Open a book and click üîñ to add one.</div>';
            } else {
                bookmarksList.innerHTML = bookmarks.map(b => {
                    const location = bookIdToLocation(b.bookId);
                    const progress = getReadingProgress(b.bookId);
                    const progressText = progress ? `Page ${progress.page + 1} of ${progress.total}` : '';
                    return `
                        <div class="bookmark-item" onclick="goToBookFromLibrary(${b.bookId})">
                            <button class="bookmark-remove" onclick="event.stopPropagation(); removeBookmarkFromUI(${b.bookId})">&times;</button>
                            <div class="search-result-title">${escapeHtml(b.title)}</div>
                            <div class="search-result-author">${escapeHtml(b.authors)}</div>
                            <div class="search-result-location">Room ${location.room + 1} ¬∑ Wall ${location.wall + 1} ¬∑ Shelf ${location.shelf + 1}</div>
                            ${progressText ? `<div class="search-result-progress">${progressText}</div>` : ''}
                        </div>
                    `;
                }).join('');
            }

            // Recents
            const recentsList = document.getElementById('recents-list');
            if (recents.length === 0) {
                recentsList.innerHTML = '<div class="empty-state">No recent books. Start exploring!</div>';
            } else {
                recentsList.innerHTML = recents.map(r => {
                    const location = bookIdToLocation(r.bookId);
                    const progress = getReadingProgress(r.bookId);
                    const progressText = progress ? `Page ${progress.page + 1} of ${progress.total}` : '';
                    return `
                        <div class="recent-item" onclick="goToBookFromLibrary(${r.bookId})">
                            <div class="search-result-title">${escapeHtml(r.title)}</div>
                            <div class="search-result-author">${escapeHtml(r.authors)}</div>
                            <div class="search-result-location">Room ${location.room + 1} ¬∑ Wall ${location.wall + 1} ¬∑ Shelf ${location.shelf + 1}</div>
                            ${progressText ? `<div class="search-result-progress">${progressText}</div>` : ''}
                        </div>
                    `;
                }).join('');
            }
        }

        window.goToBookFromLibrary = function(bookId) {
            closeLibrary();
            const location = bookIdToLocation(bookId);
            teleportTo(location.room, () => {
                openBook(bookId);
            }, bookId);
        };

        window.continueReading = function(bookId, page) {
            closeLibrary();
            const location = bookIdToLocation(bookId);
            teleportTo(location.room, () => {
                openBook(bookId, page);
            }, bookId);
        };

        window.removeBookmarkFromUI = function(bookId) {
            removeBookmark(bookId);
        };

        // Panel tabs
        document.querySelectorAll('.panel-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(`${tabName}-tab`).classList.add('active');
            });
        });

        // ============================================
        // RANDOM ROOM
        // ============================================

        window.randomRoom = function() {
            const randomRoomIdx = Math.floor(Math.random() * TOTAL_ROOMS);
            teleportTo(randomRoomIdx);
        };

        // ============================================
        // ABOUT MODAL
        // ============================================

        window.openAbout = function() {
            document.getElementById('about-overlay').classList.add('visible');
            document.getElementById('about-modal').classList.add('visible');
            aboutOpen = true;
            controls.unlock();
        };

        window.closeAbout = function() {
            document.getElementById('about-overlay').classList.remove('visible');
            document.getElementById('about-modal').classList.remove('visible');
            aboutOpen = false;
        };

        // ============================================
        // HUD UPDATE
        // ============================================

        function updateHUD() {
            const startBook = currentRoomIndex * BOOKS_PER_ROOM + 1;
            const endBook = Math.min((currentRoomIndex + 1) * BOOKS_PER_ROOM, TOTAL_BOOKS);
            document.getElementById('hud-coords').textContent = `Room ${currentRoomIndex + 1} of ${TOTAL_ROOMS}`;
            document.getElementById('hud-info').textContent = `Books #${startBook.toLocaleString()} ‚Äì #${endBook.toLocaleString()} ¬∑ ${BOOKS_PER_ROOM} books per room`;
        }

        // ============================================
        // BRIGHTNESS CONTROL
        // ============================================

        const brightnessSlider = document.getElementById('brightness-slider');
        brightnessSlider.addEventListener('input', (e) => {
            renderer.toneMappingExposure = e.target.value / 100;
        });

        // ============================================
        // INTRO SEQUENCE
        // ============================================

        const intro = document.getElementById('intro');
        intro.addEventListener('click', () => {
            if (intro.classList.contains('hidden')) return;
            intro.classList.add('hidden');
            introHidden = true;
            setTimeout(() => {
                intro.style.display = 'none';
            }, 1500);
        });

        // ============================================
        // ANIMATION LOOP
        // ============================================

        const clock = new THREE.Clock();
        let hoveredBook = null;
        const tempColor = new THREE.Color();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            const now = performance.now();

            if (controls.isLocked) {
                const direction = new THREE.Vector3();
                if (keys.forward) direction.z -= 1;
                if (keys.backward) direction.z += 1;
                if (keys.left) direction.x -= 1;
                if (keys.right) direction.x += 1;

                if (direction.length() > 0) {
                    direction.normalize();

                    const moveDir = direction.clone();
                    moveDir.applyQuaternion(camera.quaternion);
                    moveDir.y = 0;
                    moveDir.normalize();

                    camera.position.add(moveDir.multiplyScalar(moveSpeed * delta));

                    applyCollision();
                    checkRoomTransition();
                }

                // Book hover highlight
                if (hoveredBook) {
                    hoveredBook.mesh.setColorAt(hoveredBook.instanceId, hoveredBook.originalColor);
                    hoveredBook.mesh.instanceColor.needsUpdate = true;
                    hoveredBook = null;
                    document.getElementById('crosshair').style.borderColor = 'rgba(212, 197, 160, 0.5)';
                    document.getElementById('book-tooltip').classList.remove('visible');
                    hideSpineLabel();
                }

                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                for (const [idx, room] of rooms) {
                    const intersects = raycaster.intersectObject(room.bookMesh);
                    if (intersects.length > 0) {
                        const instanceId = intersects[0].instanceId;
                        const bookInfo = room.bookMap[instanceId];
                        room.bookMesh.getColorAt(instanceId, tempColor);

                        hoveredBook = {
                            mesh: room.bookMesh,
                            instanceId: instanceId,
                            originalColor: tempColor.clone()
                        };

                        // Brighten the book
                        tempColor.multiplyScalar(1.5);
                        room.bookMesh.setColorAt(instanceId, tempColor);
                        room.bookMesh.instanceColor.needsUpdate = true;
                        document.getElementById('crosshair').style.borderColor = 'rgba(196, 148, 58, 0.9)';

                        // Show tooltip with book info (debounced fetch)
                        if (hoveredBookId !== bookInfo.bookId) {
                            hoveredBookId = bookInfo.bookId;
                            const tooltip = document.getElementById('book-tooltip');
                            tooltip.querySelector('.title').textContent = `Book #${bookInfo.bookId}`;
                            tooltip.querySelector('.author').textContent = 'Click to read';
                            tooltip.querySelector('.location-hint').textContent = 
                                `Wall ${bookInfo.wall + 1} ¬∑ Shelf ${bookInfo.shelf + 1} ¬∑ Vol ${bookInfo.vol + 1}`;
                            tooltip.classList.add('visible');

                            // Fetch actual metadata with debouncing
                            fetchBookMetadataDebounced(bookInfo.bookId, (meta) => {
                                if (meta && hoveredBookId === bookInfo.bookId) {
                                    tooltip.querySelector('.title').textContent = meta.title;
                                    tooltip.querySelector('.author').textContent = meta.authors;
                                }
                            });
                        }

                        // Show spine label at book position (screen-space)
                        const worldPos = bookInfo.worldPos.clone();
                        worldPos.y += 0.15; // Above the book
                        worldPos.add(room.group.position);
                        const screenPos = worldPos.clone().project(camera);
                        const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                        
                        if (screenPos.z < 1) { // In front of camera
                            updateSpineLabel(bookInfo, { x, y });
                        } else {
                            hideSpineLabel();
                        }

                        break;
                    }
                }

                if (!hoveredBook) {
                    hoveredBookId = null;
                }
            }

            // Update book highlighting (search/teleport target glow)
            if (highlightedBookInfo) {
                const elapsed = now - highlightStartTime;
                if (elapsed > HIGHLIGHT_DURATION) {
                    // Restore original color and clear highlight
                    const room = rooms.get(highlightedBookInfo.room);
                    if (room) {
                        const bookEntry = room.bookMap.find(b => b.bookId === highlightedBookInfo.bookId);
                        if (bookEntry) {
                            const origR = room.originalColors[bookEntry.instanceId * 3];
                            const origG = room.originalColors[bookEntry.instanceId * 3 + 1];
                            const origB = room.originalColors[bookEntry.instanceId * 3 + 2];
                            tempColor.setRGB(origR, origG, origB);
                            room.bookMesh.setColorAt(bookEntry.instanceId, tempColor);
                            room.bookMesh.instanceColor.needsUpdate = true;
                        }
                    }
                    clearHighlight();
                } else {
                    // Pulsing glow effect
                    const room = rooms.get(highlightedBookInfo.room);
                    if (room) {
                        const bookEntry = room.bookMap.find(b => b.bookId === highlightedBookInfo.bookId);
                        if (bookEntry) {
                            const pulse = Math.sin(elapsed * 0.008) * 0.5 + 0.5; // 0-1 pulsing
                            const origR = room.originalColors[bookEntry.instanceId * 3];
                            const origG = room.originalColors[bookEntry.instanceId * 3 + 1];
                            const origB = room.originalColors[bookEntry.instanceId * 3 + 2];
                            
                            // Blend between original color and gold highlight
                            tempColor.setRGB(
                                origR + (HIGHLIGHT_COLOR.r - origR) * pulse * 0.7,
                                origG + (HIGHLIGHT_COLOR.g - origG) * pulse * 0.7,
                                origB + (HIGHLIGHT_COLOR.b - origB) * pulse * 0.7
                            );
                            room.bookMesh.setColorAt(bookEntry.instanceId, tempColor);
                            room.bookMesh.instanceColor.needsUpdate = true;
                        }
                    }
                }
            }

            // Enhanced light flicker effect with occasional stronger flickers
            for (const [idx, room] of rooms) {
                if (room.lights && room.lamps) {
                    const seed1 = room.roomIndex * 7;
                    const seed2 = room.roomIndex * 11;

                    // Base flicker
                    let flicker1 = Math.sin(elapsedTime * 2.3 + seed1) * 0.08
                                   + Math.sin(elapsedTime * 4.7 + seed1 * 2) * 0.05;
                    let flicker2 = Math.sin(elapsedTime * 2.1 + seed2) * 0.08
                                   + Math.sin(elapsedTime * 5.1 + seed2 * 2) * 0.05;

                    // Occasional stronger flicker (every ~5 seconds, random)
                    const flickerChance = Math.sin(elapsedTime * 0.2 + seed1) * Math.sin(elapsedTime * 0.13 + seed2);
                    if (flickerChance > 0.95) {
                        flicker1 += (Math.random() - 0.5) * 0.3;
                    }
                    if (Math.sin(elapsedTime * 0.17 + seed2) * Math.sin(elapsedTime * 0.23 + seed1) > 0.95) {
                        flicker2 += (Math.random() - 0.5) * 0.3;
                    }

                    room.lights[0].intensity = 2.0 + flicker1;
                    room.lights[1].intensity = 2.0 + flicker2;
                    
                    // Lamp glow color variation
                    const warmth1 = 0.95 + flicker1 * 0.3;
                    const warmth2 = 0.95 + flicker2 * 0.3;
                    room.lamps[0].material.color.setRGB(1, warmth1 * 0.88, warmth1 * 0.63);
                    room.lamps[1].material.color.setRGB(1, warmth2 * 0.88, warmth2 * 0.63);
                }
            }

            updateParticles(delta, elapsedTime);
            renderer.render(scene, camera);
        }

        // ============================================
        // ATMOSPHERIC DUST PARTICLES (Enhanced)
        // ============================================

        const PARTICLE_COUNT = 400;
        const particlePositions = new Float32Array(PARTICLE_COUNT * 3);
        const particleSizes = new Float32Array(PARTICLE_COUNT);
        const particleVelocities = [];
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            particlePositions[i * 3] = (Math.random() - 0.5) * 24;
            particlePositions[i * 3 + 1] = Math.random() * ROOM_HEIGHT;
            particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 24;
            particleSizes[i] = 0.008 + Math.random() * 0.012;
            particleVelocities.push(
                (Math.random() - 0.5) * 0.012,
                (Math.random() - 0.5) * 0.006,
                (Math.random() - 0.5) * 0.012,
                Math.random() * Math.PI * 2 // phase for floating motion
            );
        }
        
        const particleGeom = new THREE.BufferGeometry();
        particleGeom.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeom.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
        
        const particleMat = new THREE.PointsMaterial({
            color: 0xFFD280,
            size: 0.015,
            transparent: true,
            opacity: 0.3,
            sizeAttenuation: true,
        });
        const dustParticles = new THREE.Points(particleGeom, particleMat);
        scene.add(dustParticles);

        function updateParticles(delta, elapsedTime) {
            const positions = dustParticles.geometry.attributes.position.array;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const phase = particleVelocities[i * 4 + 3];
                
                // Add gentle floating motion
                const floatX = Math.sin(elapsedTime * 0.5 + phase) * 0.002;
                const floatY = Math.sin(elapsedTime * 0.3 + phase * 1.5) * 0.001;
                const floatZ = Math.cos(elapsedTime * 0.4 + phase * 0.7) * 0.002;
                
                positions[i * 3] += (particleVelocities[i * 4] + floatX) * delta * 60;
                positions[i * 3 + 1] += (particleVelocities[i * 4 + 1] + floatY) * delta * 60;
                positions[i * 3 + 2] += (particleVelocities[i * 4 + 2] + floatZ) * delta * 60;

                const dx = positions[i * 3] - camera.position.x;
                const dz = positions[i * 3 + 2] - camera.position.z;
                if (Math.abs(dx) > 12) positions[i * 3] = camera.position.x + (Math.random() - 0.5) * 20;
                if (Math.abs(dz) > 12) positions[i * 3 + 2] = camera.position.z + (Math.random() - 0.5) * 20;
                if (positions[i * 3 + 1] > ROOM_HEIGHT) positions[i * 3 + 1] = 0;
                if (positions[i * 3 + 1] < 0) positions[i * 3 + 1] = ROOM_HEIGHT;
            }
            dustParticles.geometry.attributes.position.needsUpdate = true;
            
            // Subtle opacity variation based on camera position
            const brightness = 0.25 + Math.sin(elapsedTime * 0.1) * 0.05;
            particleMat.opacity = brightness;
        }

        // ============================================
        // KEYBOARD SHORTCUTS
        // ============================================

        window.addEventListener('keydown', (e) => {
            if (readerOpen) {
                if (e.code === 'Escape') { 
                    if (document.getElementById('reader-search-bar').classList.contains('visible')) {
                        closeReaderSearch();
                    } else {
                        closeBook(); 
                    }
                }
                if (e.code === 'ArrowRight' || e.code === 'ArrowDown') { e.preventDefault(); nextPage(); }
                if (e.code === 'ArrowLeft' || e.code === 'ArrowUp') { e.preventDefault(); prevPage(); }
                if (e.code === 'KeyB') { toggleBookmark(); }
                if ((e.ctrlKey || e.metaKey) && e.code === 'KeyF') {
                    e.preventDefault();
                    openReaderSearch();
                }
            } else if (searchOpen) {
                if (e.code === 'Escape') { closeSearch(); }
                if (e.code === 'Enter') {
                    e.preventDefault();
                    if (e.target.id === 'search-gutenberg-id') {
                        jumpToGutenbergId();
                    } else if (selectedSearchIndex >= 0 && searchResults[selectedSearchIndex]) {
                        goToBook(searchResults[selectedSearchIndex].id);
                    } else {
                        performSearch();
                    }
                }
                // Arrow key navigation in search results
                if (e.code === 'ArrowDown' && searchResults.length > 0) {
                    e.preventDefault();
                    selectedSearchIndex = Math.min(selectedSearchIndex + 1, searchResults.length - 1);
                    renderSearchResults();
                    // Scroll into view
                    const selected = document.querySelector('.search-result-item.selected');
                    if (selected) selected.scrollIntoView({ block: 'nearest' });
                }
                if (e.code === 'ArrowUp' && searchResults.length > 0) {
                    e.preventDefault();
                    selectedSearchIndex = Math.max(selectedSearchIndex - 1, 0);
                    renderSearchResults();
                    const selected = document.querySelector('.search-result-item.selected');
                    if (selected) selected.scrollIntoView({ block: 'nearest' });
                }
            } else if (navOpen) {
                if (e.code === 'Escape') { closeNav(); }
            } else if (libraryOpen) {
                if (e.code === 'Escape') { closeLibrary(); }
            } else if (aboutOpen) {
                if (e.code === 'Escape') { closeAbout(); }
            }
        });

        // ============================================
        // WINDOW RESIZE
        // ============================================

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ============================================
        // INITIALIZATION
        // ============================================

        updateRooms();
        updateHUD();
        updateLibraryUI();
        animate();
    </script>
</body>
</html>